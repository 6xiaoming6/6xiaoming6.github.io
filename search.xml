<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Games101课堂笔记和作业</title>
      <link href="/2025/11/22/Games101/"/>
      <url>/2025/11/22/Games101/</url>
      
        <content type="html"><![CDATA[<h1 id="常用英语"><a href="#常用英语" class="headerlink" title="常用英语"></a>常用英语</h1><ol><li>raster 光栅</li><li>tringle 三角形</li><li>mesh 网格</li><li>Anti-Aliasing，AA 反走样（抗锯齿）</li></ol><h1 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h1><h2 id="Barycentric-Coordinates-重心坐标"><a href="#Barycentric-Coordinates-重心坐标" class="headerlink" title="Barycentric Coordinates(重心坐标)"></a>Barycentric Coordinates(重心坐标)</h2><p>在着色方法中的<strong>顶点着色</strong>部分提到了先求出三个顶点处的颜色，然后三角形内部的颜色采用<strong>插值</strong>实现在三个顶点间<strong>渐变</strong>颜色，为此引入了重心坐标来解决问题。本质上就是根据三角形的三个顶点的颜色值，得出三角形内部任意一点的颜色值，实现颜色的平滑过渡。</p><p>插值可以对三角形中的任意属性，比如任意像素的颜色、深度等，都可以通过插值处理。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240119171752928.png" alt="image-20240119171752928" style="zoom:67%;" /><p>给定三角形的三点坐标A, B, C，该<strong>平面内一点</strong>(x,y)可以写成这三点坐标的线性组合形式，即 <strong>( x , y ) &#x3D; α A + β B + γ C</strong>且满足 <strong>α + β + γ &#x3D; 1</strong>， 则称此时3个坐标A,B,C的权重<strong>α , β , γ</strong> 为点( x , y ) 的<strong>重心坐标</strong>。<br>【<strong>注意：<strong>只满足上面两个条件只是保证该点在三角形所在平面上。必须当</strong>α , β , γ</strong> 均为<strong>非负数</strong>时，该点才在三角形<strong>内部</strong>】</p><p>举个栗子：我们求A的重心坐标，如下图所示，可以得出A的重心坐标为(1，0，0)。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240119172353379.png" alt="image-20240119172353379" style="zoom:67%;" /><h3 id="三角形内任意一点中心坐标求解"><a href="#三角形内任意一点中心坐标求解" class="headerlink" title="三角形内任意一点中心坐标求解"></a>三角形内任意一点中心坐标求解</h3><p>对于三角形内任意一点，我们将该点与A,B,C相连，可以得到三个小三角形，那么与之对应的<strong>α , β , γ</strong> 值可以通过小三角形面积与总三角形面积的比值得到，如下图所示。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240119172733749.png" alt="image-20240119172733749" style="zoom:67%;" /><p>将上式进一步推导求解可以得到另外一种形式。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240119173117762.png" alt="image-20240119173117762" style="zoom:67%;" /><h3 id="应用重心坐标做插值处理"><a href="#应用重心坐标做插值处理" class="headerlink" title="应用重心坐标做插值处理"></a>应用重心坐标做插值处理</h3><p>通过上面的描述得来，在三角形中，我们可以把三角形内任一点的任意属性通过三个顶点的线性组合得来。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240119173224511.png" alt="image-20240119173224511" style="zoom: 67%;" /><h1 id="Transformation-变换"><a href="#Transformation-变换" class="headerlink" title="Transformation(变换)"></a>Transformation(变换)</h1><h2 id="2DTransformations-2维变换"><a href="#2DTransformations-2维变换" class="headerlink" title="2DTransformations(2维变换)"></a>2DTransformations(2维变换)</h2><h3 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h3><ul><li><h2 id="Scale-缩放变换"><a href="#Scale-缩放变换" class="headerlink" title="Scale(缩放变换)"></a>Scale(缩放变换)</h2></li></ul><p>把每个点的x,y坐标分别按相同的比例进行缩放。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240115120839898.png" alt="image-20240115120839898" style="zoom:50%;" /><p>这种操作可以写成以下的数学形式</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240115121232580.png" alt="image-20240115121232580" style="zoom:50%;" /><p>上式可以进一步写为矩阵相乘形式，S的那个矩阵称为<strong>缩放矩阵</strong>。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240115121305055.png" alt="image-20240115121305055" style="zoom:50%;" /><ul><li><h3 id="Relfection-反射变换"><a href="#Relfection-反射变换" class="headerlink" title="Relfection(反射变换)"></a>Relfection(反射变换)</h3></li></ul><p>其实就是镜像反转以下，数学中就是所有点根据y轴对称过去。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240115121527251.png" alt="image-20240115121527251" style="zoom: 50%;" /><ul><li><h3 id="Shear-错切变换"><a href="#Shear-错切变换" class="headerlink" title="Shear(错切变换)"></a>Shear(错切变换)</h3></li></ul><p>大概就是将原图根据一个角进行拉伸，如下图所示。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240115140057237.png" alt="image-20240115140057237" style="zoom:50%;" /><ul><li><h3 id="Rotate-旋转变换"><a href="#Rotate-旋转变换" class="headerlink" title="Rotate(旋转变换)"></a>Rotate(旋转变换)</h3></li></ul><p>就是图像绕着一个点进行选择，图中是绕原点逆时针旋转。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240115141040006.png" alt="image-20240115141040006" style="zoom:50%;" /><p>上述的所有变换都可以用下面的式子表示，如果符合这个式子的变换，那么叫做<strong>线性变换</strong>。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240115141150892.png" alt="image-20240115141150892" style="zoom:50%;" /><ul><li><h3 id="Translation-平移变换"><a href="#Translation-平移变换" class="headerlink" title="Translation(平移变换)"></a>Translation(平移变换)</h3></li></ul><p>就是把一个图像沿x、y轴平移一些距离，但是这种变换不能用上面的那种矩阵形式得来，所有平移变换<strong>不属于线性变换</strong>。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240115141704545.png" alt="image-20240115141704545" style="zoom:50%;" /><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240115141822651.png" alt="image-20240115141822651" style="zoom: 80%;" /><h3 id="Homogeneous-Matrix-齐次坐标"><a href="#Homogeneous-Matrix-齐次坐标" class="headerlink" title="Homogeneous Matrix(齐次坐标)"></a>Homogeneous Matrix(齐次坐标)</h3><p>由于<strong>平移变换并不满足线性变换的表达形式</strong>，所以在处理过程中要对平移操作当作特殊操作。为了解决这个问题，于是便引入了<strong>齐次坐标</strong>，通过给变换矩阵增加一个纬度，使得上述所有变换都有一个统一的形式表达（矩阵 <strong>·</strong> 向量）。</p><p>引入的新维度，向量和点的形式不同。对于一个点，新增纬度的值为1；对于一个向量，新增纬度的值为0。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240115145542395.png" alt="image-20240115145542395" style="zoom:67%;" /><p>从下图可以看到，通过外引入一个参数后，二维点坐标也变为了三维。但与此同时，平移变换也可以写成矩阵与向量相乘的统一形式。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240115145525316.png" alt="image-20240115145525316" style="zoom:50%;" /><p>在齐次坐标中任何一个点(x,y,w)，都可以转换成在笛卡尔坐标系中的点(x&#x2F;w,y&#x2F;w)。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240115150154510.png" alt="image-20240115150154510" style="zoom: 50%;" /><p>下图是一些变换在齐次变换中的二维变换矩阵。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240115150632168.png" alt="image-20240115150632168" style="zoom: 67%;" /><h3 id="Affine-Transformations-仿射变换"><a href="#Affine-Transformations-仿射变换" class="headerlink" title="Affine Transformations(仿射变换)"></a>Affine Transformations(仿射变换)</h3><p>对于所有可以用下列形式表示的变换，称为<strong>仿射变换</strong>。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240115150428521.png" alt="image-20240115150428521" style="zoom: 67%;" /><p>所有的仿射变换都可以通关引入齐次坐标写成以下形式。这样我们就把所有的变换统一成一种形式了。这种写法表示的是先进行线性变换，再进行平移操作。</p><p>可以看到变换矩阵的<strong>最后一列是与点平移有关的</strong>，<strong>最后一行是始终为(0, 0, 1)</strong>，左上角2x2大小的范围控制点的旋转平移等变换。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240115150537162.png" alt="image-20240115150537162" style="zoom: 67%;" /><h3 id="Composing-Transforms-组合变换"><a href="#Composing-Transforms-组合变换" class="headerlink" title="Composing Transforms(组合变换)"></a>Composing Transforms(组合变换)</h3><p>一系列复杂的变换都可以由这些基本变换得来，而且和变换的<strong>顺序有关</strong>(矩阵乘法不满足交换律)。从右向左运算结果依次作用于矩阵，下图中就表示先旋转45度，再平移一个单位。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240115144233249.png" alt="image-20240115144233249" style="zoom:80%;" /><p>由矩阵运算的结合律可知，下图等式右侧的n个矩阵可以先进行运算得到一3维个矩阵，再把这个矩阵和右侧向量相乘结果一样的。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240115144415627.png" alt="image-20240115144415627" style="zoom:67%;" /><h2 id="3DTransfroms-3维变换"><a href="#3DTransfroms-3维变换" class="headerlink" title="3DTransfroms(3维变换)"></a>3DTransfroms(3维变换)</h2><p>同样，在三维空间中也有平移变换，所以也需要引入齐次坐标，用四维的向量表示一个点或者向量，用四维矩阵表示3维空间的变换矩阵。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240115150829738.png" alt="image-20240115150829738" style="zoom:50%;" /><p>与二维变换类似，变换矩阵的最后一列是平移相关的参数，最后一行始终为(0, 0, 0, 1)，左上角3x3区域是旋转缩放等变换的参数。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240115150902525.png" alt="image-20240115150902525" style="zoom: 67%;" /><p>下面是三维空间中的旋转和平移变换矩阵：</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250903232724015.png" alt="image-20250903232724015" style="zoom:67%;" /><p>下面是三维空间中分别绕着x、y、z轴旋转的旋转矩阵。</p><p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250903232659772.png" alt="image-20250903232659772"></p><p>上面三个旋转矩阵都是针对于绕某个轴旋转的的情况下，那么对于一般情况下对于任意一个旋转，该怎么写旋转矩阵呢？</p><p>一种简单的做法就是将任意的旋转拆解为绕三个轴先后旋转的组合，再将三个旋转矩阵相乘即可，这里的旋转叫就叫做欧拉角（Euler Angles）。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250904234749225.png" alt="image-20250904234749225" style="zoom: 50%;" /><p>也可以使用<strong>罗德里格斯公式</strong>直接求出绕任意轴 $\vec{n}$ 旋转的旋转矩阵：</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250904234933674.png" alt="image-20250904234933674" style="zoom:67%;" /><h2 id="View-Camera-Transformation"><a href="#View-Camera-Transformation" class="headerlink" title="View&#x2F;Camera Transformation"></a>View&#x2F;Camera Transformation</h2><p>这一步可以按照拍照理解，就是将三维的世界投影到2维图像上。</p><p>对于一个相机，我们需要知道他的位置、正面朝向和上方向，分别就用 $\vec{e}$ 、 $\vec{y}$ 和 $\vec{t}$ 三个向量来表示。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240115155212445.png" alt="image-20240115155212445" style="zoom:50%;" /><p>对于拍照来说，只要背景一样、相机和拍摄物体的相对位置一样，不论在哪里拍出来的东西都是一样的。在渲染中也是一样的，无论相机在哪，角度如何。我们始终都把相机固定到固定位置，固定角度的状态，为了保证相机和物体的相对位置不发生变化，场景内的物体也要随相机做同样的变换。（这种理解和<strong>将顶点坐标从模型坐标系变换到摄像机坐标系的理解是等价的</strong>，前者是空间位置的变换，后者是坐标系的变换）</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250904235902312.png" alt="image-20250904235902312" style="zoom:67%;" /><p>为了简化计算，规定相机的固定状态：相机始终在(0,0,0)原点位置，且相机始终向-Z方向看，上方向为Y轴正方向。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240115155621631.png" alt="image-20240115155621631" style="zoom:67%;" /><p>当我们知道了相机的位置和旋转角度时，需要将相机变换到我们的固定状态去。首先使用平移变换将相机移动到坐标原点(0, 0, 0)，然后再进行旋转变换将相机的朝向与-z轴重合，上方向与y轴重合。当两个轴与坐标轴重合后，相机的右方向自然也就和x轴重合了。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250905224315450.png" alt="image-20250905224315450" style="zoom:67%;" /><p>​对于第一步平移的变换矩阵很好写。第二步需要将相机的各个方向进行旋转后与坐标轴重合，但是从任意轴旋转到坐标轴的旋转矩阵不好写，但是将坐标轴变换到任意轴的旋转矩阵是容易写出来的。又因为变换矩阵的逆矩阵表示相反的变换，所以我们可以写出将坐标轴变换到任意轴的旋转矩阵，再求其逆矩阵就得到了要求的旋转矩阵。又因为旋转矩阵是正交矩阵，正交矩阵的逆矩阵就是其转置矩阵，于是就求出了对应的旋转矩阵。</p><p>​于是我们要求的视图变换矩阵 <strong>ViewMatrix &#x3D; R * T</strong>。（将两个变换矩阵按照先平移后旋转的顺序相乘即可）</p><p>​由于要保证相机和场景内物体的相对运动不变，场景内的所有顶点也要乘上视图变化矩阵。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250905224957251.png" alt="image-20250905224957251" style="zoom:67%;" /><h2 id="Projection-Transformation-投影变换"><a href="#Projection-Transformation-投影变换" class="headerlink" title="Projection Transformation(投影变换)"></a>Projection Transformation(投影变换)</h2><p>投影分为<strong>正交投影</strong>和<strong>透视投影</strong>，两种投影的本质区别就是<strong>是否会产生进大远小的视觉效果</strong>后者会产生这种效果，前者则没有。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240115161825742.png" alt="image-20240115161825742" style="zoom:50%;" /><h3 id="Orthographic-Projection-正交投影"><a href="#Orthographic-Projection-正交投影" class="headerlink" title="Orthographic  Projection(正交投影)"></a>Orthographic  Projection(正交投影)</h3><p>正交投影较为简单，因为相机的投影盒是一个立方体。只需要先把投影盒中心平移到原点，场景中所有顶点跟随投影盒做相同平移变换；再投影盒范围缩放到[-1,1]，场景中的顶点也做同样的缩放变换。</p><p>这样变换后，所有在<strong>投影盒内的顶点坐标</strong>范围<strong>均为[-1, 1]</strong>，所有<strong>不在投影盒内的顶点坐标</strong>范围**都不在[-1, 1]**内。</p><p>所以正交投影矩阵也较为简单，只需要根据投影盒的边界进行一次平移变换和一次缩放变换即可。</p><p>下<strong>面图示及推到过程中和最终矩阵里的n，f以及其他边界，都是使用的边界的坐标值（有正有负）。</strong></p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240115162552686.png" alt="image-20240115162552686" style="zoom:67%;" /><h3 id="Perspective-Projection-透视投影"><a href="#Perspective-Projection-透视投影" class="headerlink" title="Perspective Projection(透视投影)"></a>Perspective Projection(透视投影)</h3><p>符合人眼看见的效果，会出现进大远小的视觉效果，会让平行线变得看起来不再平行。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240115164743885.png" alt="image-20240115164743885" style="zoom: 67%;" /><p>透视投影的视图就是从相机位置向朝向发射出一个锥型区域，而且进大远小。如果我们想得到透视投影的话，需要先把上图中的锥体<strong>挤压</strong>成右侧的立方体，然后再对立方体进行<strong>正交投影</strong>。最终的投影结果就是透视投影的结果。正交投影我们已经知道怎么做，最大的问题就是如何把锥体挤压成立方体，下面来具体介绍。</p><p>首先我们先侧面观察一下前后两个截面坐标之间的关系。由相似三角形的知识我们不难得出图中右侧的结论，因为挤压只会远端平面改变x和y的值，z并不改变，所以x和y值都满足图中右侧的关系。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240115165515788.png" alt="image-20240115165515788" style="zoom:67%;" /><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240115165630899.png" alt="image-20240115165630899" style="zoom:67%;" /><p>通过上图我们可以清晰的看到远端平面中x和y值挤压后变换的结果，在齐次坐标中对一点(x,y,z,1)，可以写出挤压后的点坐标(齐次坐标中参数同时乘一个数表示的还是一个点)，最终最右侧的坐标就是我们变换后的点坐标。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240115172433597.png" alt="image-20240115172433597" style="zoom: 67%;" /><p>坐标的变换可以通关乘一个变换矩阵得到，现在我们已经有了变换后的<strong>部分</strong>结果，可以反推出变换矩阵的<strong>部分内容</strong>。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240115172712495.png" alt="image-20240115172712495" style="zoom:67%;" /><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240115172749715.png" alt="image-20240115172749715" style="zoom:67%;" /><p>然后问题就会转换成求变换矩阵第三行这个较为简单的问题。</p><p>在变换中有两个观测事实：</p><ol><li>近平面的所有点都不会发生改变(变换矩阵乘近平面的任何点还是会得到原来的点)。</li><li>远平面的经过变换之后不会发生改变</li></ol><p>下面是根据<strong>第一条</strong>事实得出的等式</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240115173354452.png" alt="image-20240115173354452" style="zoom:67%;" /><p>可以写出变换矩阵第三行的部分内容为(0,0,A,B)，其中A,B未知。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240115173806097.png" alt="image-20240115173806097" style="zoom:67%;" /><p>现在根据<strong>第二条</strong>事实可以再写出一个等式。(取远端平面上的**(0,0,f)**点为例)</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240115173819454.png" alt="image-20240115173819454" style="zoom:67%;" /><p>最终可以根据二元一次方程组解法求出A和B最大值。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240115173933835.png" alt="image-20240115173933835" style="zoom:67%;" /><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240115174004580.png" alt="image-20240115174004580" style="zoom:67%;" /><p>根据这个变换矩阵把锥形体挤压为标准立方体后，再进行正交投影即可得到透视投影的结果。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250910103731638.png" alt="image-20250910103731638" style="zoom: 80%;" /><p><strong>PS：由于我们这里是右手坐标系，摄像机是看向-z轴的。这里所提到的n和f是指近平面和远平面与相机的z坐标，而near和far表示距离是z坐标的绝对值。前面说了我们是看向-z轴的所以，近平面和远平面的z坐标均为负数，因此有near &#x3D; -n，far &#x3D; -f，将其带入矩阵可得：</strong></p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250910105939911.png" alt="image-20250910105939911" style="zoom: 80%;" /><p>这样变换后，我们可以发现：近平面zNear的z坐标为1，远平面zFar的z坐标为-1。也就是说，离摄像机越近的物体z值越大，离摄像机越远的物体z值越小，这和深度测试中是相反的，也不符合人直觉。</p><p>为了解决这一问题，我们需要将z轴进行翻转，使得我们的z值和深度测试中是对应的，即距离近z值小，距离远z值大。（如果在投影矩阵的推到中将近平面映射到-1，远平面映射到1，最终得到的投影矩阵是一样的）。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250910111222175.png" alt="image-20250910111222175" style="zoom:80%;" /><p>再将投影矩阵和翻转矩阵相乘，我们也就从右手坐标系转到了左手坐标系。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250910111246438.png" alt="image-20250910111246438" style="zoom:80%;" /><p>也等价于这个矩阵(都用包围盒边界坐标轴表示)。</p><p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250910113957251.png" alt="image-20250910113957251"></p><p>其中为了简化透视投影中各项参数的定义，使其更符合人的直觉，定义参数aspect和fov。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250910085929626.png" alt="image-20250910085929626" style="zoom:67%;" /><p>我们可以利用fov，aspect，near和far求出l，r，b，t。</p><p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250910090048434.png" alt="image-20250910090048434"></p><h2 id="Viewport-Transformation-视口变换"><a href="#Viewport-Transformation-视口变换" class="headerlink" title="Viewport Transformation(视口变换)"></a><strong>Viewport Transformation</strong>(视口变换)</h2><p>这个变换就是把我们经过MVP操作得到的标准立方体在二维平面的投影均匀的映射到屏幕范围内，即[-1,1]^2→[0,width]*[0,height], 其中width和height指屏幕分辨率大小。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240116200330459.png" alt="image-20240116200330459" style="zoom:50%;" /><p>下面就是变换矩阵，操作是先把原来[-1,1]^2的图拉伸到[0,width]*[0,height]的大小，然后再平移使得左下角在原点。这样我们就可以把三维空间中的任意变换放到屏幕上了。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240116200341692.png" alt="image-20240116200341692" style="zoom: 67%;" /><p><strong>MVP概念</strong></p><p>MPV是计算机图形学中前面三中变换的缩写,我们把三维空间转换维二维图片首先要经过MVP操作，然后进行光栅化，就可以转换成2维图像呈现出来。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240116194407072.png" alt="image-20240116194407072" style="zoom:67%;" /><h1 id="rasterization-光栅化"><a href="#rasterization-光栅化" class="headerlink" title="rasterization(光栅化)"></a>rasterization(光栅化)</h1><p>经过上述变换操作，我们可以得到三维空间中的任意物体变换后在屏幕中分布的信息（NDC坐标，范围[-1, 1]），然后我们需要进行视口变换，将范围为[-1, 1]的各个点坐标映射到大小为width × height的二维屏幕的像素坐标上，最终把颜色绘制在屏幕上的一个个像素块上。</p><p>而这里说的<strong>光栅化</strong>就是就是根据这些点信息转化为像素并<strong>画到屏幕上的过程</strong>。</p><h2 id="视口变换"><a href="#视口变换" class="headerlink" title="视口变换"></a>视口变换</h2><p>在这里，我们将一个个的像素看做大小都相等的正方向块，而且每个像素块内的颜色都是一样的（即每个像素块都是纯色块）。</p><p>下图定义了一个屏幕空间，左下角是(0, 0)点，屏幕空间由一个个像素组成。像素的坐标都为整数，且从0开始，下图中蓝色的像素坐标为(2, 1)。像素的中心点就在正方形的中心，每个像素长度为1，那么对于坐标为(x, y)的像素来说，其中心点坐标为</p><p>(x+0.5, y+0.5)。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250905231834967.png" alt="image-20250905231834967" style="zoom:50%;" /><p>定义好了屏幕空间后，我们就可以将将范围为[-1, 1]的各个点坐标映射到大小为width × height的二维屏幕空间上。将范围为[-1, 1]的x和y坐标分别映射为[0, width]和[0, height]。 z坐标的变换现在暂时不用关系，后面介绍遮挡时会用到。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250905232201174.png" alt="image-20250905232201174" style="zoom:50%;" /><p>实现这样的变换，只需要构造这样一个视口变换矩阵即可。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250905232309485.png" alt="image-20250905232309485" style="zoom:50%;" /><h2 id="走样"><a href="#走样" class="headerlink" title="走样"></a>走样</h2><p>当我们想把一个图像绘制到屏幕上时（这里用三角形举例，三角形用的多），在<strong>简单采样</strong>中会根据像素的中心点是否在三角形内来决定这个像素的颜色，在屏幕中显示出这些像素的颜色，实现在屏幕的绘制，如下图所示。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240116222801328.png" alt="image-20240116222801328" style="zoom:67%;" /><p>但是我们希望看到的三角形是下图中所示的样子，通过上面的变换会出现很多的棱角，就出现了所谓的<strong>锯齿</strong>效果，也叫走样。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240116222858676.png" alt="image-20240116222858676" style="zoom: 80%;" /><h2 id="反走样"><a href="#反走样" class="headerlink" title="反走样"></a>反走样</h2><p>锯齿的学名叫做<strong>Aliasing(走样)</strong>，在很多情况下都会出现，如下图所示。将一张图片不断放大，当放大到一定程度时就会看到这些小锯齿。为了解决这种问题，我们要进行<strong>反走样(Anti-Aliasing，AA)或抗锯齿</strong>。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240116223218011.png" alt="image-20240116223218011" style="zoom: 50%;" /><h3 id="模糊处理"><a href="#模糊处理" class="headerlink" title="模糊处理"></a>模糊处理</h3><p>简单的解决方法就是我们<strong>先</strong>对原图像进行<strong>模糊处理</strong>，然后再对<strong>模糊后的图像</strong>进行<strong>采样</strong>，可以在一定程度上消除锯齿。必须是<strong>先模糊再采样</strong>才有效果，如果对先采样得到的锯齿图片模糊处理则不会有效果。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240116223531674.png" alt="image-20240116223531674" style="zoom:67%;" /><p>模糊处理的方法就是对图像进行<strong>卷积操作</strong>，使得每一块区域内的值有一个平均，从而达到模糊处理的效果。下图就是卷积操作的一个示例图，这里我们把用于卷积运算的那个矩阵叫做<strong>滤波器</strong>。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240116223923769.png" alt="image-20240116223923769" style="zoom: 67%;" /><p>对于部分在三角形内部的像素块来说，不使用01变换的方式，而是将这个像素内部的值做一个平均操作，本质上也就是进行了一个卷积操作。这样处理过后，三角形边界的像素即使部分在三角形内部，也会有一个模糊后的颜色，会让边缘的锯齿变得光滑一些，以达到反走样的效果。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250807211000337.png" alt="image-20250807211000337" style="zoom:50%;" /><p>反走样的原理并不复杂，但是要实现这一效果需要知道三角形覆盖某一像素的面积，这一才能将像素部分区域的颜色平均到整个像素中。我们无法准确的计算出这一结果，但是可以通过一些算法来<strong>近似计算道三角形覆盖某一像素的面积</strong>。</p><p>常见的抗锯齿方法（<strong>超采样</strong>）有：MSAA（多重采样抗锯齿，Multisample Anti-Aliasing），FXAA（快速近似抗锯齿，Fast Approximate Anti-Aliasing），TAA（时间性抗锯齿，Temporal Anti-Aliasing）。这些方法都不是提高采样率，增大分辨率实现抗锯齿的，只是使用某种方法近似计算一个像素在三角形内的面积，更好的实现图像的模糊操作。本质上还是通过先<strong>模糊</strong>后采样的策略实现抗锯齿的。</p><p>也可以通过<strong>超分辨率</strong>技术解决抗锯齿：DLSS（深度学习超采样，Deep Learning Supre Sampling），本质上是把一张低分辨率的图片放大为一张高分辨率的图片，放大后多出来的像素细节就使用深度学习进行补全，通过**提高了分辨率(采样率)**来实现抗锯齿。</p><h3 id="MSAA-Multi-Sample-AA"><a href="#MSAA-Multi-Sample-AA" class="headerlink" title="MSAA(Multi Sample AA)"></a>MSAA(Multi Sample AA)</h3><p>MSAA对多边形的边缘进行多重采样（通常是 2x、4x、8x），假设使用的是4x的MSAA，就会将像素内的采样点由变为4x4&#x3D;16个，相当于把一个像素划分为了4x4的网格。根据在三角形内部的点数来估计一个像素在三角形内部的面积。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250807212441176.png" alt="image-20250807212441176" style="zoom: 50%;" /><p>下图是2x的例子，根据一个像素在三角形内部的采样点占一个像素所有采样点的百分比估计一个像素在三角形内的面积。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250807212643581.png" alt="image-20250807212643581" style="zoom: 67%;" /><p>显然，一个像素的采样点越多，抗锯齿的效果越好，但是带来的性能消耗也越多，因为一个像素判断的采样点所作的运算也更多。</p><h3 id="FXAA-Fast-Approximate-AA"><a href="#FXAA-Fast-Approximate-AA" class="headerlink" title="FXAA(Fast Approximate AA)"></a>FXAA(Fast Approximate AA)</h3><p>对于一个三角形来说，我们需要抗锯齿的地方就是三角形的边界部分。FXAA的做法就是集中于边界的处理，通过卷积操作找到原始图像的边界线，然后只对边界部分进行抗锯齿。FXAA所带来的开销很小。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250807214222852.png" alt="image-20250807214222852" style="zoom: 80%;" /><h3 id="TAA-Tempoal-AA"><a href="#TAA-Tempoal-AA" class="headerlink" title="TAA(Tempoal AA)"></a>TAA(Tempoal AA)</h3><h2 id="Z-Buffer算法-解决物体间的先后顺序遮挡问题"><a href="#Z-Buffer算法-解决物体间的先后顺序遮挡问题" class="headerlink" title="Z-Buffer算法(解决物体间的先后顺序遮挡问题)"></a>Z-Buffer算法(解决物体间的先后顺序遮挡问题)</h2><p>在前面我们学习了如何解决走样问题，可以使图像的效果更好，但是对于三维空间中的物体不同的远近物体之间会有遮挡问题，所以这一次我们就学习如何在二维图像中呈现出这种<strong>遮挡效果</strong>，用到的算法就是<strong>Z-Buffer</strong>算法。</p><p>Z-Buffer算法需要维护一个数组<strong>zbuffer</strong>，这个数组记录了三角形中所有<strong>像素</strong>的深度，初始为<strong>无限大</strong>。（这里说的深度是指该像素距离相机远近的距离，深度越小离相机越近，会遮盖住深度达的像素）。然后在渲染图像时遍历每个三角形上的像素点(x,y)，与该位置的zbuffer的值进行比较，如果小则更新zbuffer数组，表示这个像素离相机更近，要覆盖这个位置原来的像素，并把这个像素颜色更新为新像素的颜色。下图是具体的算法流程。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240118132918032.png" alt="image-20240118132918032" style="zoom:67%;" /><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240118132939130.png" alt="image-20240118132939130" style="zoom:67%;" /><p>当每一个三角形不是太大或者太小时，每个三角形所覆盖的像素都是一定数量的常数的，所以我们渲染时只需要扫描n个三角形就实现了图像的遮盖效果，所以Z-Buffer算法的事件复杂度可以看作O(n)的。</p><h1 id="Shading-着色"><a href="#Shading-着色" class="headerlink" title="Shading(着色)"></a>Shading(着色)</h1><p>前面两大节已经学习了变换和光栅化，可以通过各种各样的变换的组合实现多种图形效果，并通过光栅化把三维的物体绘制到二维的屏幕上面，现在我们就要考虑如何将这些颜色绘制到对应的像素上，实现绘制彩色的图片。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>进入一个新的阶段，为了解决新的问题，需要定义和引入一些东西。这些向量都是单位向量，只是为了表示方向。另外这里我们说的只是<strong>局部着色</strong>，对每一个着色点来说，我们<strong>只考虑这一个点</strong>的光照方向以及亮度等，并<strong>不考虑</strong>是否有其他物体遮挡住它，阴影效果后面再说如何解决。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240118135837094.png" alt="image-20240118135837094" style="zoom:80%;" /><h2 id="Lambert漫反射模型"><a href="#Lambert漫反射模型" class="headerlink" title="Lambert漫反射模型"></a>Lambert漫反射模型</h2><h3 id="Diffuse-Reflect-漫反射"><a href="#Diffuse-Reflect-漫反射" class="headerlink" title="Diffuse Reflect(漫反射)"></a>Diffuse Reflect(漫反射)</h3><p>漫反射是光从一定角度入射之后从入射点向四面八方反射，且每个不同方向反射的光的强度相等，而产生漫反射的原因是物体表面的粗糙，导致了这种物理现象的发生。</p><p>我们可以通过着色点表面与光照的不同角度出现不同的光照效果模拟漫反射。</p><p>其中就有Lambert’s cosine law(Lambert’s余弦定理)即，<strong>c o s θ &#x3D; l ⋅ n</strong> ，其中<strong>l</strong> 是入射光方向，<strong>n</strong> 为平面法线方向。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240118140822720.png" alt="image-20240118140822720" style="zoom:67%;" /><h3 id="光的传播"><a href="#光的传播" class="headerlink" title="光的传播"></a>光的传播</h3><p>除了需要知道光的入射角角度，还需要知道距离光源的距离，以便计算光的强度。</p><p>我们假设点光源在各个方向开始扩散，各个方向的速度和能量都相同，那么就会像水波纹那样向外扩散，假设能量不受损，根据能量守恒定律可以求出距离点光源任意距离的光的强度。如下图所示，可以看到距离点光源越远，光照强度就越低。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240118141508079.png" alt="image-20240118141508079" style="zoom:67%;" /><p>于是结合以上两点，我们可以综合得出漫反射的模拟模型</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240118142007087.png" alt="image-20240118142007087" style="zoom:67%;" /><p>k<del>d</del>表示的是<strong>漫反射系数</strong>，决定了这一点对光的吸收能力的大小。当k<del>d</del>为1时表示为白色，即反射所有光，当k<del>d</del>为0时表示为黑色，即吸收所有光。这个属性可以表示物体某一点的明暗程度。</p><p>L<del>d</del>表示的是漫反射反射出去的光。</p><p>从上式可以看出，漫反射与我们的<strong>观测方向v无关</strong>，即从哪个方向观察漫反射的结果都是一样的。</p><h2 id="Blinn-Phong镜面反射模型"><a href="#Blinn-Phong镜面反射模型" class="headerlink" title="Blinn-Phong镜面反射模型"></a>Blinn-Phong镜面反射模型</h2><p>在现实生活中不止有漫反射，还存在着镜面反射。镜面反射可以使物体表面出现高光，例如下图中左边是只有漫反射的效果，右侧则是考虑了镜面反射的效果，可以使得物体看起来更加逼真。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240118143849681.png" alt="image-20240118143849681" style="zoom:67%;" /><p>镜面反射的方向和入射角与法线的角度相同。下图中R表示镜面反射的方向，当R的方向与观察方向V很接近时，就会产生<strong>HighLight</strong>(<strong>高光)</strong>。就好比拿着镜子对准太阳，当我们人眼的观测角度和太阳光的反射角度非常接近时会晃眼，高光就是和这个差不多。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240118144017886.png" alt="image-20240118144017886" style="zoom:67%;" /><p>在Blinn-Phon镜面反射模型中，引入了<strong>h(半程向量)</strong>，半程向量时I和<strong>V</strong>夹角的<strong>角平分线</strong>方向，可以通过两个向量相加再归一化得到班车向量<strong>h</strong>。在这个模型中认为当h和<strong>n</strong>很接近时，能在一定程度上表示了<strong>V和R</strong>很接近，这样就简化了运算，n和h的接近程度可以通过点乘得到结果。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240118144255239.png" alt="image-20240118144255239" style="zoom:67%;" /><p>我们可以看到模型中的式子中有个指数<strong>p</strong>，这是用来控制高光的生成范围的，我们一般希望高光在很小的一个范围内，击中一小块区域内很亮，随着指数的增大，可以实现这种效果。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240118144948456.png" alt="image-20240118144948456" style="zoom:67%;" /><h2 id="泛光模型"><a href="#泛光模型" class="headerlink" title="泛光模型"></a>泛光模型</h2><p>泛光模型即只考虑环境光，这是最简单的<strong>经验</strong>模型，只会去考虑环境光的影响，并且不会去精确的描述，而只是用一个简单的式子表示。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240118145209844.png" alt="image-20240118145209844" style="zoom:67%;" /><p>其中<strong>Ka</strong>代表物体表面对环境光的反射率，<strong>Ia</strong>代表入射环境光的亮度。</p><p>最后在渲染的时候，我们整体考虑环境光、漫反射光和镜面反射光，就能呈现出较好的模拟效果。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240118145358529.png" alt="image-20240118145358529" style="zoom:67%;" /><p>最终效果演示图如下所示。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240118145434108.png" alt="image-20240118145434108" style="zoom:67%;" /><h2 id="着色方法-频率"><a href="#着色方法-频率" class="headerlink" title="着色方法(频率)"></a>着色方法(频率)</h2><p>前面我们只是针对一个点进行着色，现在就开始对整体进行渲染。下图是三种不同的渲染方法产生的结果，根据渲染所选取的对象不同，得到的结果也不同。大致可以分为三类：面着色，顶点着色，像素着色。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240118150140996.png" alt="image-20240118150140996" style="zoom:67%;" /><h3 id="Flat-Shading-面着色"><a href="#Flat-Shading-面着色" class="headerlink" title="Flat Shading(面着色)"></a>Flat Shading(面着色)</h3><p>面着色，顾名思义以每一个<strong>面</strong>作为一个着色单位。模型数据大多以很多个三角面进行存储，因此也就记录了每个面的法线向量，利用每个面的法线向量进行一次Blinn-Phong反射光照模型的计算，将该颜色赋予整个面。</p><h3 id="Gouraud-Shading-顶点着色"><a href="#Gouraud-Shading-顶点着色" class="headerlink" title="Gouraud Shading(顶点着色)"></a>Gouraud Shading(顶点着色)</h3><p>顶点着色，会对<strong>每个三角形的顶点</strong>进行一次着色，三角形的内部通过渐变的形式进行着色。现在最大的问题就是如何求出每个顶点的法向量，从下图我们可以看到，一个顶点会被多个面共享，所以一个顶点的法向量可以通过这些<strong>共享面</strong>的<strong>法向量求平均值</strong>得来。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240118151316581.png" alt="image-20240118151316581" style="zoom:67%;" /><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240118151614959.png" alt="image-20240118151614959" style="zoom:67%;" /><p>对于三角形内的一点，我们已经有了三个顶点的法线，内部的法线是在顶点之间平滑过渡的。</p><h3 id="Phong-Shading-像素着色"><a href="#Phong-Shading-像素着色" class="headerlink" title="Phong Shading(像素着色)"></a>Phong Shading(像素着色)</h3><p>像素着色，会对每一个像素（片元）都进行一次着色。</p><p>下图是一个对比，每一行都是相同的模型，随着向下走，模型的三角形数量不断的增加。可见随着三角形数量的增加，三种着色频率的区别并不是太大。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240118151009539.png" alt="image-20240118151009539" style="zoom:67%;" /><h1 id="Graphics-Pipeline-图形管线"><a href="#Graphics-Pipeline-图形管线" class="headerlink" title="Graphics Pipeline(图形管线)"></a>Graphics Pipeline(图形管线)</h1><p>从三维空间映射到二维屏幕上的一系列过程叫做图形管线。这一套流程被写在硬件中，现在普遍是由显卡执行这一套操作。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240118152205254.png" alt="image-20240118152205254" style="zoom:67%;" /><ol><li><strong>顶点处理</strong>的作用是指<strong>对所有的顶点数据进行Model，View，和Projection的变换，最终得到投影到二维平面的坐标信息</strong>(同时为了Zbuffer保留深度z值)。当然如果超出观察空间的会被剪裁掉(关于剪裁的知识因为闫老师的课并没有多提，所以本系列笔记也暂未设及到，但是会在之后进行该部分知识的补充)。</li></ol><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240118154558385.png" alt="image-20240118154558385" style="zoom: 80%;" /><ol start="2"><li>三角形处理也十分容易理解，就是<strong>将所有的顶点按照原几何信息，变成三角面，每个面由3个顶点组成</strong>。</li><li>光栅化所执行的操作就是，<strong>找到屏幕中的哪些像素在三角形内</strong>，即找出哪些像素是我们需要绘制上色的。</li></ol><p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240118154611553.png" alt="image-20240118154611553"></p><ol start="4"><li>在进行完三角形的光栅化之后，知道了哪些在三角形内的像素可以被显示。由于多个三角形直接会存在遮挡关系，在片元处理之前，还<strong>需要使用Z-Buffer算法计算每个片元的可见性</strong>。只有最终不被遮挡的片元才能进入片元处理阶段进行着色。</li></ol><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240118154659249.png" alt="image-20240118154659249" style="zoom: 80%;" /><ol start="5"><li><p>片元处理阶段就是<strong>决定了每一个像素的最终颜色</strong>，也就是俗称的着色。顶点处理阶段可以使用每个顶点的顶点颜色进行着色，其他片元的颜色会通过插值算法计算出自己的颜色。如果向实现Phong式着色的话还必须到片元处理阶段拿到每个像素进行着色。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240118154648252.png" alt="image-20240118154648252" style="zoom: 80%;" /></li><li><p>最后一步！Framebuffer的处理，就是将所有的像素颜色信息整合在一起，输送给显示设备加以显示。这也就完成了整个图形渲染管线了。</p></li></ol><h1 id="Texture-Mapping-纹理映射"><a href="#Texture-Mapping-纹理映射" class="headerlink" title="Texture Mapping(纹理映射)"></a>Texture Mapping(纹理映射)</h1><p>先看这样一张图，对于图片中的任何一个物体，每个点都有不同的颜色。前面学习漫反射可以知道，每个点的颜色是可以通过漫反射系数的调节改变的。但是一个物体的这么多点，我们显然不可能手动设置每一个点的颜色，于是便有了纹理映射技术。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240118160139682.png" alt="image-20240118160139682" style="zoom:67%;" /><p>纹理是一张二维的图，覆盖在物体表面。大概原理就是一个三维物体的表明可以通过展开形成一个二维的平面，可以找到与之对应的二维图片覆盖在表明，形成了不同的颜色和样式。所以实现物体平面上任何一个点与纹理上任何一个点像映射的过程叫做纹理映射。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240118160357193.png" alt="image-20240118160357193" style="zoom:67%;" /><p>如下图所示，我们可以先用通用着色器渲染出模型的样子，然后再把最右侧的纹理贴在模型上，就形成了中间的最终模型。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240118160640194.png" alt="image-20240118160640194" style="zoom:67%;" /><h2 id="纹理坐标系-UV"><a href="#纹理坐标系-UV" class="headerlink" title="纹理坐标系(UV)"></a>纹理坐标系(UV)</h2><p>纹理坐标系通常用u、v两个字母表示坐标系的值，u和v的值都在[0,1]之间，如下图所示。至于一个顶点所对应在纹理空间的坐标是怎么得到的，这就并不是程序员们关心的了，我们在编程前是假设已经知道了顶点到纹理坐标的映射关系。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240118160923315.png" alt="image-20240118160923315" style="zoom:67%;" /><p>下面是纹理坐标具体使用的伪代码：大致流程就是我们根据在屏幕上的每一个位置获取其对应的uv坐标，再根据uv坐标到贴图获取该位置的颜色，最后用这个颜色替换屏幕上这点的颜色，就实现了贴材质到模型上。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240119185608675.png" alt="image-20240119185608675" style="zoom: 50%;" /><h2 id="当纹理过大或者过小引起的问题及解决方案"><a href="#当纹理过大或者过小引起的问题及解决方案" class="headerlink" title="当纹理过大或者过小引起的问题及解决方案"></a>当纹理过大或者过小引起的问题及解决方案</h2><h3 id="纹理过小问题"><a href="#纹理过小问题" class="headerlink" title="纹理过小问题"></a>纹理过小问题</h3><p>如果纹理大小可以正好与屏幕上对应区域大小相同，每一个像素都能对应上。但是当纹理过小时，我们就需要对纹理进行放大，那么纹理上的一个像素可能会覆盖屏幕上的几个像素，导致两个像素的中心点对应不上，如下图所示红色位置。那么此时我们该如何计算这一点的颜色呢，如果只是简单的选择离他最近的点的颜色，会导致照片出现失真显示，就会在照片上出现像素块，这显然是不可取的。</p><p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240119191029096.png" alt="image-20240119191029096"></p><h3 id="双线性插值"><a href="#双线性插值" class="headerlink" title="双线性插值"></a>双线性插值</h3><p>第一步，取出离红色点最近的4个黑色顶点，分别算出，该红色点在水平及竖直方向偏移的距离s,t。</p><p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240119191257173.png" alt="image-20240119191257173"></p><p>接着先利用s，可以线性插值出如下图所示的u0，u1点的颜色值</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240119191335576.png" alt="image-20240119191335576" style="zoom:67%;" /><p>最后利用t，颜色值u0，u1插值出红色点的颜色值</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240119191430598.png" alt="image-20240119191430598" style="zoom: 50%;" /><p>最后得出该点的颜色就综合考虑了周围四个点的颜色，会让图片看起来有种平滑过渡的效果。下图就是最近距离和双线性插值的结构比较，可以明显看出右边的效果比坐标的好了很多。</p><p>由于Nearest是直接选取离自己最近的像素点，所以会出现几个像素都是一个颜色，导致图像中出现一些像素块。而双线性插值则是将周围几个点的值进行插值，会得到更平滑的过渡效果。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240119191651120.png" alt="image-20240119191651120" style="zoom:67%;" /><h3 id="纹理过大问题"><a href="#纹理过大问题" class="headerlink" title="纹理过大问题"></a>纹理过大问题</h3><p>当纹理过大时，会产生比纹理过小更严重的问题。正常情况下，我们希望看到这样的渲染结果。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240119211505394.png" alt="image-20240119211505394" style="zoom:67%;" /><p>但是实际上会出现这样的结果</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240119211546161.png" alt="image-20240119211546161" style="zoom:67%;" /><p>这是因为透视投影存在进大远小的效果，所以远处的一片材质在屏幕空间中可能只对应了几个像素，我们用这几个像素来呈现这一片的颜色，肯定会造成很严重的失真。如下图所示，距离相机越远，一个像素所包含的纹理范围(纹素)就越多，造成的问题也就越严重，所以我们就需要想办法解决这一问题。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240119211726573.png" alt="image-20240119211726573" style="zoom:67%;" /><h3 id="MipMap"><a href="#MipMap" class="headerlink" title="MipMap"></a>MipMap</h3><p>​对应上面区域中的一个像素包含一片区域的贴图，这个只选取范围贴图中的某给颜色表示这块纹理显然是不合理的，所以我们干脆就对这块区域内的颜色求平均值，而屏幕空间中该像素的颜色就为这块纹理颜色的平均值。</p><p>​而MipMap技术就允许我们进行<strong>范围查询</strong>，从而得到这片区域的颜色的平均值。但是MipMap只能对<strong>正方形区域</strong>做近似查询(得出的结果是大约值，不是准确值)，但是速度很快。</p><p>​具体做法就是根据原始图像通过不断的向下缩放分辨率生产其他层的低分辨率图像，level 0代表的是原始纹理，也是精度最高的纹理，随着level的提升，每提升一级将4个相邻像素点求均值合为一个像素点，因此越高的level也就代表了更大的footprint的区域查询。接下来要做的就是根据屏幕像素的footprint大小选定不同level的texture，再进行点查询即可，而这其实就相当于在原始texture上进行了区域查询！</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240119212630596.png" alt="image-20240119212630596" style="zoom:67%;" /><p>​那么我们如何选择第几层的材质查询呢？</p><p>​在屏幕空间中取当前像素点的右方和上方的两个相邻像素点(4个全取也可以)，分别查询得到这3个点对应在Texture space的坐标，计算出当前像素点与右方像素点和上方像素点在Texture space的距离，二者取最大值，计算公式如图中所示，那么level D就是这个距离的log2值 (D &#x3D; log2L) 。根据计算出来的L进一步求出D从而选择对应缩放级别的图片。</p><p>​mipmap的核心就是针对不同的像素区域选择合适的缩放级别的纹理，使得1像素 ≈ 1纹素，避免多个纹素对应一个像素产生走样问题。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240119213407192.png" alt="image-20240119213407192" style="zoom:67%;" /><p>​<strong>注意</strong>这里我们求得的D可能不是一个整数，就比如我们得到了1.8，但是我们没有1.8层的图片。这里就可以再次用插值处理，先对第一层查询插值得到一个值，再去第二层查询插值得到一个值，最后根据第1层和第2层得到的信息插值出来第1.8层的信息，供需要插值三次，所以叫做<strong>三线性插值</strong>。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240119214127535.png" alt="image-20240119214127535" style="zoom:67%;" /><h3 id="各向异性过滤MipMap"><a href="#各向异性过滤MipMap" class="headerlink" title="各向异性过滤MipMap"></a>各向异性过滤MipMap</h3><p>应用了MipMap后，我们得到的图如下，可以看到没有很好的解决问题，这是因为MipMap只能解决<strong>方形</strong>的区域，对于一些矩形或者不规则区域，则无法进行处理。而屏幕空间中的一个像素映射到纹理上并不都是方形区域，甚至会出现不规则的斜着的区域。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240119214324256.png" alt="image-20240119214324256" style="zoom: 50%;" /><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240119214548681.png" alt="image-20240119214548681" style="zoom:50%;" /><p>各向异性过滤MipMap允许处理矩形区域和方形区域，但是对于一些斜着的或者不规则的无法处理，但是也可以进一步增强图片的效果。</p><h2 id="纹理映射的应用"><a href="#纹理映射的应用" class="headerlink" title="纹理映射的应用"></a>纹理映射的应用</h2><h1 id="Geometry-几何"><a href="#Geometry-几何" class="headerlink" title="Geometry(几何)"></a>Geometry(几何)</h1><p>计算机图形学中，要表示各种各样的模型，而如何更好的表示这些模型就离不开几何。几何可以分为<strong>隐式</strong>几何和<strong>显式</strong>几何两种。</p><h2 id="隐式几何"><a href="#隐式几何" class="headerlink" title="隐式几何"></a>隐式几何</h2><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>所谓隐式，就是不会告诉你任何关于点的信息，只会告诉我们这些点之间满足的关系，即各种各样的函数。比如下图中给出了球面方程，我们可以知道在球面上的所有点都满足这个方程，但是具体具体是哪一个点我们无法得知。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240120103636172.png" alt="image-20240120103636172" style="zoom:67%;" /><p>对于隐式的来说，我们可以很容易判断某一个点在球外、球内还是球面上，但是我们无法知道都有哪些点在球面上，因为对于一个面来说有无限多的点。</p><h3 id="其他表示方法"><a href="#其他表示方法" class="headerlink" title="其他表示方法"></a>其他表示方法</h3><h4 id="代数表示"><a href="#代数表示" class="headerlink" title="代数表示"></a>代数表示</h4><p>代数表示顾名思义就是用数学表达式描述一个曲面，这是最简单的表达方式，对于简单几何能很好描述，但是对于一些复杂几何就不太好描述了。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240120105335229.png" alt="image-20240120105335229" style="zoom:67%;" /><h4 id="Constructive-Solid-Geometry-CSG"><a href="#Constructive-Solid-Geometry-CSG" class="headerlink" title="Constructive Solid Geometry(CSG)"></a>Constructive Solid Geometry(CSG)</h4><p>这种表示方法允许对基本几何进行布尔运算，通过不同的操作组合来表示复杂几何。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240120105706250.png" alt="image-20240120105706250" style="zoom:50%;" /><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240120105719539.png" alt="image-20240120105719539" style="zoom:67%;" /><h2 id="显式几何"><a href="#显式几何" class="headerlink" title="显式几何"></a>显式几何</h2><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>显示与隐式是相对的，和之前的三角形表示一样，我们知道了所有的点坐标或者通过映射关系得到所有点坐标。通过这些点构建一个曲面。如下图所示，我们用这一一种坐标的映射也可以得到一个球面。</p><p>​                                       <img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240120104901725.png" alt="image-20240120104901725" style="zoom: 50%;" /></p><p>但是对于显示来说，我们很容易得到曲面上的所有点，但是很难判断某一点与该曲面的关系。</p><p>所以两者各有利弊，各有不同的适用范围。</p><h3 id="其他表示方法-1"><a href="#其他表示方法-1" class="headerlink" title="其他表示方法"></a>其他表示方法</h3><h4 id="Point-Cloud-点云"><a href="#Point-Cloud-点云" class="headerlink" title="Point Cloud(点云)"></a>Point Cloud(点云)</h4><p>是最简单的表示方法，就是用一堆点构成曲面，点多模型就精细，点少就不那么精细。理论上用点云方式可以表示任何形状的几何，但是点的密度要足够高。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240120111557918.png" alt="image-20240120111557918" style="zoom:67%;" /><h3 id="Polygon-Mesh-多边形网格"><a href="#Polygon-Mesh-多边形网格" class="headerlink" title="Polygon Mesh(多边形网格)"></a>Polygon Mesh(多边形网格)</h3><p>用三角形面通过连接组合，形成其他曲面。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240120111809818.png" alt="image-20240120111809818" style="zoom:67%;" /><h2 id="Bezier-Curves-贝塞尔曲线"><a href="#Bezier-Curves-贝塞尔曲线" class="headerlink" title="Bézier Curves(贝塞尔曲线)"></a>Bézier Curves(贝塞尔曲线)</h2><p>P0,P1,P2,P3都是控制点，P0和P3是终点和七点，P1和P2控制曲线的走向。其实贝塞尔曲线的定义很像参数方程，给定一个参数，t∈[0,1]就能确定贝塞尔曲线上的一点，倘若取完所有t值，就能得到完整的贝塞尔曲线，了解一下大概之后，接下来我们就开始介绍计算曲线的过程。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240120112603359.png" alt="image-20240120112603359" style="zoom: 50%;" /><p>选择一个最简单的形式，即只有三个控制点。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240120113632915.png" alt="image-20240120113632915" style="zoom:67%;" /><p>第一步选定一个参数 t∈[0,1]，在b0b1线段 上进行插值</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240120113727263.png" alt="image-20240120113727263" style="zoom:67%;" /><p>在b1b2线段上做同样操作</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240120113802086.png" alt="image-20240120113802086" style="zoom:67%;" /><p>最后在线段b0^1^b1^1^上再次插值就可以得到贝塞尔曲线在t时刻的点，遍历所有的情况就可以绘制出贝塞尔曲线。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240120113910603.png" alt="image-20240120113910603" style="zoom:67%;" /><p> 对于n个点的操作也一样，都是不断重复一个操作，下图就是4个控制点的绘制过程。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240120114021767.png" alt="image-20240120114021767" style="zoom:67%;" /><p>对于t时刻的贝塞尔曲线上的点，我们可以递归式的求解出来，具体形式如下图所示，该点由其他线段插值得来。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240120114222128.png" alt="image-20240120114222128" style="zoom:50%;" /><p>于是我们可以通过数学表达式写出来，如下图所示，任意时刻贝塞尔曲线一点的坐标与所有控制点和t有关。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240120114350164.png" alt="image-20240120114350164" style="zoom:50%;" /><p>​可以看到贝塞尔曲线是一个关于t的多项式，其中的B一栏是一个特殊系数，对于这样一个特殊系数其实也有一个多项式与之对应，正是<strong>伯恩斯坦多项式</strong>。n个控制点的贝塞尔曲线为n-1次。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240120114635728.png" alt="image-20240120114635728" style="zoom:67%;" /><p><strong>贝塞尔曲线的性质：</strong></p><p>​<strong>1 必定经过起始与终止控制点</strong><br>​<strong>2 必定经与起始与终止线段相切</strong><br>​<strong>3 具有仿射变换性质，可以通过移动控制点移动整条曲线</strong><br>​<strong>4 凸包性质，曲线一定不会超出所有控制点构成的多边形范围</strong></p><p>但是对于高阶的贝塞尔曲线不好控制，当下图中11个控制点绘制曲线是，可以发现效果并不是很好。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240120120058617.png" alt="image-20240120120058617" style="zoom:67%;" /><p>为了解决这个问题，于是就有了<strong>Piecewise Curves</strong>即分段的曲线，先分别用几个控制点绘制好曲线，再把几段曲线连接起来。现在普遍采用四个控制点描绘一段曲线，即下图中所示，然后再把各个曲线连接起来。然后我们通过控制这些控制点调整曲线的形状。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240120120720675.png" alt="image-20240120120720675" style="zoom:67%;" /><h2 id="Bezier-Surfaces-贝塞尔曲面"><a href="#Bezier-Surfaces-贝塞尔曲面" class="headerlink" title="Bézier Surfaces(贝塞尔曲面)"></a>Bézier Surfaces(贝塞尔曲面)</h2><p>理解了贝塞尔曲线不难理解，贝塞尔曲面就是将2维过渡到3维。如下图所示，就是利用了4x4 即16个控制点绘制出的曲面。二维的需要一个参数t，那么三维的就需要两个参数来描述，记作u,v，在任意时刻(u1.v1)，都可以找到一个点，遍历所有情况就能组成贝塞尔曲面。</p><p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240120125237415.png" alt="image-20240120125237415"></p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240120125420963.png" alt="image-20240120125420963" style="zoom:67%;" /><p><strong>网格细分是指将一个模型的面合理的分成更多小的面，从而提升模型精度，提高渲染效果</strong><br><strong>网格简化是指将一个模型的面合理的合成更少的面，从而降低模型精度，为特定情形下提供使用(如LOD技术)</strong></p><h2 id="Mesh-Subdivision-网格细分"><a href="#Mesh-Subdivision-网格细分" class="headerlink" title="Mesh Subdivision(网格细分)"></a>Mesh Subdivision(网格细分)</h2><p>从下图可以知道，细分就是把一个三角形合理分为更多更小的面，从而提高模型的精度，使模型有更多的细节。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240123095715936.png" alt="image-20240123095715936" style="zoom: 67%;" /><p>细分过程中我们需要做两件事情，<strong>一</strong>是将一个三角形细分为更多小的三角形，二是改变小三角形的位置，使细分后的模型表面看起来更加圆滑，而不是棱角分明。如下图所示，把一个多面体变为圆形。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240123100115787.png" alt="image-20240123100115787" style="zoom:50%;" /><h3 id="Loop细分-Loop-Subdivision"><a href="#Loop细分-Loop-Subdivision" class="headerlink" title="Loop细分(Loop Subdivision)"></a>Loop细分(Loop Subdivision)</h3><h4 id="划分三角形"><a href="#划分三角形" class="headerlink" title="划分三角形"></a>划分三角形</h4><p>将每一个三角形按照下图的方式划分为4个小三角形</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240123100241925.png" alt="image-20240123100241925" style="zoom:67%;" /><h4 id="改变顶点位置"><a href="#改变顶点位置" class="headerlink" title="改变顶点位置"></a>改变顶点位置</h4><p>我们把划分好的三角形的顶点分为<strong>新顶点</strong>和<strong>旧顶点</strong>两类，新顶点就是划分出来的小三角形产生的新顶点，下图中红圈标记的点。旧顶点就是原先大三角形的顶点，下图中的黑色点。</p><p>对于每一个<strong>新顶点</strong>，都做下图中右侧的处理，移动顶点的位置</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240123100843592.png" alt="image-20240123100843592" style="zoom: 50%;" /><p>对于每一个旧顶点，做以下操作。其中n是该顶点的度，更新旧顶点需要依赖周围顶点的信息和自身的信息，进行加权平均得来的。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240123101543442.png" alt="image-20240123101543442" style="zoom: 80%;" /><h3 id="Catmull-Clark细分-Catmull-Clark-Subdivision"><a href="#Catmull-Clark细分-Catmull-Clark-Subdivision" class="headerlink" title="Catmull-Clark细分(Catmull-Clark Subdivision)"></a>Catmull-Clark细分(Catmull-Clark Subdivision)</h3><p>先说明一些定义：</p><p><strong>1 对于所有不是四边形的面，称之为Non-quad face</strong><br><strong>2 所有度不为4的顶点称之为奇异点</strong></p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240123113806433.png" alt="image-20240123113806433" style="zoom: 80%;" /><p>每次细分步骤如图中右下角所示，在每个面中都添加一个点，在每条边的中点也都添加一个点，面上的新顶点连接所有边上的新顶点</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240123113910545.png" alt="image-20240123113910545" style="zoom: 80%;" /><p>从中我们可以观察到一些性质：</p><p><strong>1 有几个非四边形面，就会多出几个奇异点，所以现在一共有2+2 &#x3D; 4个</strong><br><strong>2 新多出来的奇异点的度数与原来所在面的边数相等，如这里就是3度</strong><br><strong>3 第一次细分之后所有面都会变成四边形，且往后奇异点数目不再增加</strong></p><p>再次细分后奇异点的数量也不再增加。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240123113947015.png" alt="image-20240123113947015" style="zoom:67%;" /><p>以上我们明白了如何增加新顶点，与Loop细分类似，同样需要去调整各类顶点的位置，这里将所有的顶点分为三类，对于各类顶点位置调整如下图所示：</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240123114145199.png" alt="image-20240123114145199" style="zoom: 90%;" /><h2 id="Mesh-Smplication-网格简化"><a href="#Mesh-Smplication-网格简化" class="headerlink" title="Mesh Smplication(网格简化)"></a>Mesh Smplication(网格简化)</h2><p>简化操作顾名思义就是减少模型中三角形面，以达到某种目的，在特定情况下会使用。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240123095726935.png" alt="image-20240123095726935" style="zoom:67%;" /><p>举个栗子，对于用不同数量的三角形组成的骷髅模型来说，从远处看区别并不是很大，我们就没有必要在远处还渲染这么复杂的模型，在很多游戏中也是如此，远处的模型看起来会模糊也是这个道理，一般模型的精度会根据距离的远近选择。距离模型远的时候三角形数量少一点，距离近的时候再增加三角形的数量。和前面的MipMap原理类似，远处精度低，进出精度高。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240123103438083.png" alt="image-20240123103438083" style="zoom: 50%;" /><p>这里介绍的方法叫做<strong>边坍缩</strong>方法，如下图所示，就是把一条边的两个顶点合并为一给顶点。但是我们需要解决的问题是简化需要尽可能的保存原模型的形状，我们该如何选择坍缩的边是关键。</p><p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240123105045421.png" alt="image-20240123105045421"></p><p>再次我们引入<strong>二次度量</strong>这个概念，即坍缩之后蓝色新顶点所在的位置与原来各个平面的垂直距离之和。</p><p>如果能够使得这个误差最小那么对整个模型样貌修改一定程度上也会较小。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240123105637261.png" alt="image-20240123105637261" style="zoom: 67%;" /><p>那么我们需要做的整体流程就很明确了：</p><p><strong>1 为模型每条边赋值，其值为坍缩这条边之后，代替两个老顶点的新顶点所能得到的最小二次误差度量</strong><br><strong>2 选取权值最小的边做坍缩，新顶点位置为原来计算得出使得二次误差最小的位置</strong><br><strong>3 坍缩完之后，与之相连其他的边的位置会改动，更新这些边的权值</strong><br><strong>4 重复2-3步，直到到达终止条件</strong></p><p>这其实是一个标准的贪心算法，可能到不了全局最优解，但事实证明最终的结果依然相当不错。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240123110518727.png" alt="image-20240123110518727" style="zoom:67%;" /><h1 id="Ray-Tracing-光线追踪"><a href="#Ray-Tracing-光线追踪" class="headerlink" title="Ray Tracing(光线追踪)"></a>Ray Tracing(光线追踪)</h1><p>​对于前面着色部分介绍的Blinn-Phong模型来说，它是一个<strong>局部模型</strong>，<strong>无法处理全局</strong>的效果。以下图为例，物体接收的的光除了我们的光影之外，还有可能会接收到由其他物体反射而来的光，这是Blinn-Phong模型所无法处理的，而光线追踪正是为了解决这种问题所提出的一种全局光照模型。但是光栅化虽然图形质量一般，但是速度快；光线追踪虽然提高了图像质量，但是会增大计算量，速度会很慢。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240123115856784.png" alt="image-20240123115856784" style="zoom: 80%;" /><p>​为了方便我们的计算实现光线追踪，我们需要对光线做出一些假设：</p><p><strong>1. 光线一定沿着直线传播</strong><br><strong>2. 光线之间无法碰撞</strong>（两条光线相交后互不影响，各自都还沿各自的方向传播）<br><strong>3. 光线路径可逆，即从A发出的到B的光线，一定也可以从B发出到A（中途可发生反射和折射）</strong></p><p>​考虑一下对光线的第三条假设：<strong>光路可逆</strong>，所有进入到人眼的光，都可从人眼发出光按照原路反方向返回，那么利用这种模拟从人眼发射光线的方法不就可以还原出所有的光路了呢？没错这就是光线追踪的核心想法。</p><p>​光线追踪的做法就是从<strong>相机随机向场景中投射光线</strong>，光线在世界中不断进行反射，<strong>反射一定次数后再和光源相连</strong>。这样我们就反向模拟出了一条从光源出发，经过多次反射后进入相机的光线了。</p><h2 id="Whitted-Style光线追踪原理"><a href="#Whitted-Style光线追踪原理" class="headerlink" title="Whitted-Style光线追踪原理"></a>Whitted-Style光线追踪原理</h2><p>​具体流程入下图所示，首先从相机出发发射一条光线（红色线），光线穿过的像素会对应场景中的一个位置，该位置有物体，说明光线会在该点发生反射。再在该点和光源位置连线（蓝色线），判断该点是否在阴影中，如果不在阴影中，就说明我们找到了一条可行的光线通路，计算该光路最终的能量，进而求出该像素的颜色。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250920225124855.png" alt="image-20250920225124855" style="zoom:50%;" /><p>​从人眼或相机向每个像素点发射一条光线，与场景中的物体相交（只考虑相交的距离最近的点，后面的点会被遮挡住）。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240123140652541.png" alt="image-20240123140652541" style="zoom: 120%;" /><p>​因为我们只会看到最前面的物体，后面被遮挡的就看不到了，所以<strong>只考虑与物体最近的交点</strong>。从该点出发，连接光源，只需要判断该连线是否会被遮挡就能判断该点是否在阴影中。同时我们也能得到该点的观测方向，光源方向和法线方向，可以计算出该点的颜色。但是这样也只是考虑了**局部（光线只弹射了一次）<strong>的光照情况，下面就开始考虑</strong>全局（光线弹射多次）**的光照。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240123141041856.png" alt="image-20240123141041856"  /><p>​如果上图中的球体是一个玻璃状透明球体，不仅会发生反射，也会发生折射，折射的光也会再反射到其他物体最终进入人眼，所以这步我们就开始考虑全局的这些光照。</p><p>​我们把如下图所示的所有会发生反射和折射的点与光源连接，判断哪些点可以进入人眼。最后将这些可以进入人眼处的颜色考虑到该像素颜色的计算中，就得到了最终的颜色。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240123141359000.png" alt="image-20240123141359000"  /><p>这部分知识说明一下基本原理，具体实际的解决方法后面会再说明。</p><h2 id="光线的表示方式"><a href="#光线的表示方式" class="headerlink" title="光线的表示方式"></a>光线的表示方式</h2><p>为了实际解决光线追踪的技术问题，我们需要大量的计算，所以需要对光线进行表示，以便进行数学运算。</p><p>我们把光线看作一条可以无限延伸的射线，起点 <strong>o</strong> 就是<strong>点光源</strong>的位置，<strong>t</strong> 表示光线传播的时间，**d **是光线的方向向量。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240123142152633.png" alt="image-20240123142152633" style="zoom:67%;" /><h2 id="光线与物体求交的方法"><a href="#光线与物体求交的方法" class="headerlink" title="光线与物体求交的方法"></a>光线与物体求交的方法</h2><h3 id="隐式表面求交"><a href="#隐式表面求交" class="headerlink" title="隐式表面求交"></a>隐式表面求交</h3><p>​光线的数学形式我们已经给出，隐式几何表面也会给出一个表达式，我们可以用几何中求交点的方法求解。<strong>两个图形的交点必然都满足两个图形的表达式</strong>，所以我们只需<strong>联立解方程</strong>即可。</p><p>​对于下面圆形和光线求交来说，只需用求根公式求解即可，但是要注意满足求解的 <strong>t</strong> 是<strong>实数</strong>并且为<strong>正数</strong>。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240123143010839.png" alt="image-20240123143010839" style="zoom:67%;" /><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240123143020376.png" alt="image-20240123143020376" style="zoom:67%;" /><p>所以对于普遍的隐式曲面，只需联立方程求解即可，最后解出来的参数 <strong>t 是有意义的正实数</strong>就说明光线和物体表面有交点。</p><p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240123143128061.png" alt="image-20240123143128061"></p><h3 id="显式表面求交"><a href="#显式表面求交" class="headerlink" title="显式表面求交"></a>显式表面求交</h3><p>​对于显示曲面来说，我们不知道曲面的表达式，无法直接求解。但是曲面都是由许多个三角形组成的，我们可以通过<strong>遍历所有三角形</strong>，查看是否有<strong>三角形与光线相交</strong>。当然如果只是简单的全局遍历是非常慢的，后面会介绍如何加速这一过程。 </p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240123143726106.png" alt="image-20240123143726106" style="zoom:67%;" /><p>​现在就需要解决<strong>如何求出光线与三角形面的交点</strong>。因为三角形肯定在一个平面内，所以我们可以先判断光线是否与该平面相交，再判断交点是否在三角形内即可。</p><p>我们把这个问题分解为两个问题：</p><p><strong>1.光线是否与三角形所在平面相交</strong></p><p><strong>2.如果相交，交点是否在三角形内</strong></p><p>如果相交，且交点在三角形内，那么就得到了我们想要的交点。</p><p>为了解决这个问题，下面给出平面的表示方法：</p><p>即用一个<strong>法向量</strong>和<strong>一个点</strong>确定一个唯一的平面，具体数学表达式如下图所示。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240123145234557.png" alt="image-20240123145234557" style="zoom: 80%;" /><p>有了表达式，我们就可以直接带入求解，得到交点。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240123145345522.png" alt="image-20240123145345522" style="zoom:67%;" /><p>​上面的解法是分成两个步骤求解的，但是可以利用下面的算法直接判断光线是否和三角形相交。（本质上来说该算法所做的也是上面两个步骤，只是可以直接用算法一步到位求解）。</p><p>​用下图的<strong>Möller-Trumbore 算法</strong>可以快速求解出<strong>三维空间中光线和三角形平面的交点的重心坐标</strong>，并判断是否在三角形内部即可。因为求出的是交点的三维重心坐标的形式，性质与二维的一致。如果b1, b2, 1-b1-b2<strong>三个系数都是非负数且和为1</strong>，就说明交点在三角形内，即光线和三角形有交点。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240123145908559.png" alt="image-20240123145908559" style="zoom:67%;" /><h2 id="光线与物体相交计算加速"><a href="#光线与物体相交计算加速" class="headerlink" title="光线与物体相交计算加速"></a>光线与物体相交计算加速</h2><p>​前面在显示曲面求交点部分介绍要与每一个三角形判断是否相交，但是如果屏幕分辨率过大，场景中模型三角形数量又很多，最终每渲染一次的速度都会非常非常慢，所以我们需要对这一过程进行加速。加速的过程其实就是尽量跳过不可能与光线相交的三角形，避免大量的无效计算。</p><h3 id="轴对齐包围盒-Axis-Aligned-Bounding-Box，AABB"><a href="#轴对齐包围盒-Axis-Aligned-Bounding-Box，AABB" class="headerlink" title="轴对齐包围盒(Axis Aligned Bounding Box，AABB)"></a>轴对齐包围盒(Axis Aligned Bounding Box，AABB)</h3><p>​利用一个包围盒包住该物体，在与该物体的三角面计算求交之前先判断光线是否与包围盒相交，倘若连包围盒都与光线没有交点的话，那么显然包围盒内部的物体肯定不会和光线有交点。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240123154149307.png" alt="image-20240123154149307" style="zoom:67%;" /><p>​而所谓AABB也是一种包围盒，也是由三对无限大平面的交集构成，只不过AABB的任意一对平面都与x-axis，y-axis或者z-axis垂直，所以称之为轴对齐包围盒。如下图所示： </p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240123154206346.png" alt="image-20240123154206346" style="zoom:67%;" /><p>我们以2D AABB为例子，因此只有x，y两对平面，3D情况可类推：</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240123154239099.png" alt="image-20240123154239099" style="zoom:67%;" /><p>​首先如上图最左边所示，求出光线与x平面的交点，将<strong>先进入的交点(偏小的那个)记为 tmin</strong>, <strong>后出去的交点(偏大的那个)记为 tmax</strong>，紧接着如中间图所示计算出光线与y平面的两个交点同样记为另外一组tmin, tmax，当然计算的过程中要注意如果任意的 t &lt; 0，那么这代表的是光线反向传播与对应平面的交点。</p><p>我们可以得到以下性质：</p><p><strong>1 只有当光线进入了所有的平面才算是真正进入了盒子中</strong><br><strong>2 只要当光线离开了任一平面就算是真正离开了盒子</strong><br>所以对每对平面的tmin，tmax做如下运算(负的也没有关系)</p><p><strong>tenter  &#x3D; max ⁡{ tmin ⁡ } , texit  &#x3D; min ⁡{ tmax ⁡ }</strong></p><p>​我们可以根据 tenter 和 texit 的正负值推断光线与AABB是否有交点。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240123154511161.png" alt="image-20240123154511161"  /><p>在计算光线和平面是否相交时，我们可以使用更方便的方法。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240123154759265.png" alt="image-20240123154759265"  /><p>​使用AABB方法可以加速判断光线是否与物体相交，那么具体应用在光线追踪加速上，AABB该如何应用，下面介绍两种加速光线追踪的方法：</p><h3 id="Uniform-Spatial-Partitions-均匀空间划分"><a href="#Uniform-Spatial-Partitions-均匀空间划分" class="headerlink" title="Uniform Spatial Partitions (均匀空间划分)"></a>Uniform Spatial Partitions (均匀空间划分)</h3><p>​首先将场景中的物体都包在一个包围盒内，再将大包围盒均匀地划分为若干个大小相等的小格子，记录下所有与物体表面相交的格子。下面的图是以二维的为例，三维场景的计算过程和二维的一样。</p><p>​这样就完成了场景的预处理，处理光线相交时，只需要判断与光线相交的格子内是否有物体即可：如果格子内没有物体，那么光线自然不会与物体相交；如果格子内有物体，就说明光线可能会和物体有交点，计算判断光线和物体表面是否有交点。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250806165529162.png" alt="image-20250806165529162" style="zoom:67%;" /><p>​这样就可以用光线于盒子的相交判断是否与物体有相交的可能，避免了光线与场景内所有物体判断是否相交，可以一定程度上进行加速。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250806170253933.png" alt="image-20250806170253933" style="zoom:67%;" /><p>​这种空间划分的方法在物体均匀分布的场景中加速效果较好，但是对于大规模的空旷且集中的场景中，效果没有那么好。对于大面积的空白区域来说，仍然使用多个小格子划分是不合理的，对于密集的区域划分多个格子，空旷的区域使用少量的大格子效果会更好更合理。</p><h3 id="不均匀空间划分"><a href="#不均匀空间划分" class="headerlink" title="不均匀空间划分"></a>不均匀空间划分</h3><p>​为了解决均匀划分中的问题，可以采用空间树形划分，划分方式多种多样，但本质上思想都是一样的。按照某一种划分方式划分空间，当某个格子内没有物体或者物体很少的时候就停止划分。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250806171203512.png" alt="image-20250806171203512" style="zoom:67%;" /><p>​由于八叉树的划分方式与纬度有关，空间纬度越高，划分次数越多，所以重点介绍KD-tree，下面是KD-tree具体划分的一个例子，划分后可以将空间划分为一个树形结构，场景中的所<strong>有叶子节点存储自己所包围的物体</strong>。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250806171657884.png" alt="image-20250806171657884" style="zoom: 50%;" /><p>判断光线相交时，先从根节点（最大的包围盒）开始判断，如果光线与包围盒A相交，则继续判断子节点1和B是否与光线相交，递归遍历相交的节点。</p><p>当光线与叶子节点的包围盒相交时，要与子节点保存的所有物体判断是否相交。（叶子节点存储所有物体，与叶子节点相交说明光线有可能与叶子节点内的物体相交，要判断一下）</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250806171918631.png" alt="image-20250806171918631" style="zoom: 50%;" /><p>​在使用KD-tree划分空间时，会不可避免的出现包围盒和物体相交的情况，但是计算三角形和包围盒的相交是比较麻烦的事情，而且一个物体可能会和多个包围盒相交，那么这些相交的包围盒所在的子节点都要存储一份该物体。</p><p>简而言之，使用KD-tree会带来以下问题：</p><ol><li>计算三角形和包围盒相交是困难的</li><li>一个物体可能会被存储多份（与该物体相交的包围盒都要保存该物体）</li></ol><p>为了解决这些问题，就要避免出现包围盒和物体相交的情况，BVH就解决了这一问题。</p><h3 id="层次包围体（Bounding-Volume-Hierarchy，BVH）"><a href="#层次包围体（Bounding-Volume-Hierarchy，BVH）" class="headerlink" title="层次包围体（Bounding Volume Hierarchy，BVH）"></a>层次包围体（Bounding Volume Hierarchy，BVH）</h3><p>​前面介绍的划分都是基于空间的划分，但是<strong>BVH是基于物体的划分</strong>，保证了<strong>每个物体只会在一个包围盒内</strong>。</p><p>​BVH的划分方式是<strong>递归地将物体划分为两部分</strong>，再根据每部分的物体计算每部分的包围盒，以此类推，递归划分。当某个节点内的物体小于某个阈值时停止划分该节点。</p><p>​这样的划分并不是严格根据空间划分的，所以不同包围盒之间是会出现相互重叠的，但是可以保证每个物体只会在一个包围盒内，避免了物体和包围盒相交的情况。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250921225006212.png" alt="image-20250921225006212" style="zoom:80%;" /><p>​下面是可以在划分节点时让BVH更好划分的两个技巧：</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250806173704528.png" alt="image-20250806173704528" style="zoom:50%;" /><p>​下面是用BVH划分场景后，计算光线是否和光线相交的算法的伪代码：</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250806173720121.png" alt="image-20250806173720121" style="zoom: 50%;" /><h2 id="辐射度量学"><a href="#辐射度量学" class="headerlink" title="辐射度量学"></a>辐射度量学</h2><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250806180301199.png" alt="image-20250806180301199" style="zoom:50%;" /><h3 id="为什么要学辐射度量学"><a href="#为什么要学辐射度量学" class="headerlink" title="为什么要学辐射度量学"></a>为什么要学辐射度量学</h3><p>在前面提到的whited-style光线追踪模型，它真的是一个正确的模型吗？显然不是，原因如下：</p><p><strong>1 whited-style光线追踪并没有对漫反射的光线进行追踪，而是直接返回当前着色点颜色。</strong><br><strong>2 在计算光源直接照射的贡献时，使用了Blinn-Phong模型，而Blinn-Phong模型本身就是一个不准确的经验模型，使用的这种模型的whited-style光线追踪自身自然也是不正确的。</strong></p><p>最终得到的渲染结果和现实相差还是比较大的，为了渲染结果更接近现实，我们要对光及光的各种描述有更加符合物理世界的规则，所以需要学习辐射度量学来解决这一问题。</p><p>辐射度量学其实是对光照的一套测量系统和单位，它能够准确的描述光线的物理性质。</p><p>具体来说，我们需要明白的是其中的几个关于光线概念，分别为：<br><strong>辐射能量(Radiant energy)</strong>，<strong>辐射通量(Radiant flux)</strong>，<strong>辐射强度(Radiant intensity)</strong>，<strong>irradiance</strong>，<strong>radiance</strong>。</p><h3 id="辐射能量-Radiant-energy"><a href="#辐射能量-Radiant-energy" class="headerlink" title="辐射能量(Radiant energy)"></a><strong>辐射能量(Radiant energy)</strong></h3><p>看起来比较直观，单位是<strong>焦耳</strong>，可以类比热学中的<strong>功</strong>。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240126104345583.png" alt="image-20240126104345583" style="zoom:67%;" /><h3 id="辐射通量-Radiant-flux-power"><a href="#辐射通量-Radiant-flux-power" class="headerlink" title="辐射通量(Radiant flux)(power)"></a>辐射通量(Radiant flux)(power)</h3><p>根据定义来说是单位时间内接收、发散等的能量，单位是<strong>瓦特</strong>或<strong>流明</strong>（也就是我们常说的光的<strong>亮度</strong>），可以类比热学中的<strong>功率</strong>。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240126104446840.png" alt="image-20240126104446840" style="zoom:67%;" /><h3 id="辐射强度-Radiant-intensity"><a href="#辐射强度-Radiant-intensity" class="headerlink" title="辐射强度(Radiant intensity)"></a><strong>辐射强度(Radiant intensity)</strong></h3><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240126113442916.png" alt="image-20240126113442916" style="zoom:67%;" /><p><strong>1 Radiant itensity其实就是指从一个光源出发某一方向上的亮度，也就是光源某根光线的亮度</strong><br><strong>2 Irradiance指某一微小平面所接受到的光线亮度</strong><br><strong>3 radiance衡量的是一条传播光线所具有的亮度(不受传播方向影响)</strong><br>（这里的亮度也可以理解为radiant flux(power)）</p><p>从定义来看，在·就是每<strong>单位立体角</strong>的<strong>Radiant flux</strong> (power) 。也即<strong>单位时间</strong>内，在<strong>单位立体角</strong>上接收或发散的光的能量。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240126113544202.png" alt="image-20240126113544202" style="zoom:67%;" /><p>那么立体角是什么呢？</p><p>我们首先看<strong>二维平面中弧度</strong>怎么计算。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240126113716465.png" alt="image-20240126113716465" style="zoom:80%;" /><p>其实立体角就是弧度在三维空间中的推广，即<strong>三维球体</strong>中的弧度。即立体角度所对应球上的投影面积比上半径的平方，整个球的立体角为4 π。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240126113813374.png" alt="image-20240126113813374" style="zoom: 80%;" /><p>​那么对于Radiant intensity的定义当中，微分立体角dω 计算如下：<br><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240126113944642.png" alt="image-20240126113944642" style="zoom:67%;margin-left:300px"/></p><p>​注意在<strong>计算微分立体角之前，我们其实选定了空间当中的一个方向（由θ ,ϕ所确定），称这个方向为ω，是一个单位向量</strong>。然后才在此基础之上分别对 θ ,ϕ 增加 dθ ,dϕ 经计算得到最终的 dω 。</p><p>​至此<strong>Radiant intensity</strong>的物理含义此时就很清楚了，即<strong>光源向某一方向所发射出的单位立体角的功率</strong>，简而言之就是<strong>光源在某个方向上的亮度</strong>如何！</p><p>​因此对于各向同性点光源来说，每个方向相同距离的亮度或者说能量都一样。因为已经定义了 <em>I</em> 为单位时间、单位立体角上接收或散发的能量，ϕ为光源单位时间散发的能量，那么将该点光源所有方向立体角的intesity求和可得该光影单位时间所散发的能量 ϕ。具体公式如下图所示：</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240126114124196.png" alt="image-20240126114124196" style="zoom:67%;" /><h3 id="Irradiance-考虑所有方向"><a href="#Irradiance-考虑所有方向" class="headerlink" title="Irradiance(考虑所有方向)"></a>Irradiance(考虑所有方向)</h3><p>​从定义来看是指单<strong>位照射面积的power</strong>，但是表明必须要和光线垂直才可直接这样写，否则要乘cos值。说明了光照的能量会随着接触面积的减小而减小。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240126105602149.png" alt="image-20240126105602149" style="zoom: 80%;" /><p>​在Blinn-Phong模型所提到的光线越远会越加衰减：</p><p>​该现象也完全可以用irradiance解释，因为光的功率 ϕ 始终一致，离点光源所照射到的圆球面积也就越大，因此根据irradiance的式子，分母的<strong>面积值</strong>也就<strong>越大</strong>，<strong>irradiance</strong>也就<strong>越小</strong>。（光的功率 ϕ 不变，点光源向四面八方均匀发射光线，所以能量被均匀的分布在一个球面上，距离越远，球面面积越大，对应每个方向的功率也就越小）。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240126110237885.png" alt="image-20240126110237885" style="zoom: 80%;" /><h3 id="Radiance-只考虑一个方向"><a href="#Radiance-只考虑一个方向" class="headerlink" title="Radiance(只考虑一个方向)"></a>Radiance(只考虑一个方向)</h3><p>​所谓radiance就是指<strong>每单位立体角，每单位垂直面积的power</strong>。直观来看的话，很像是Intensity和irradiance的结合。<strong>它同时指定了光的方向与照射到的表面所接受到的亮度</strong>。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240126110654997.png" alt="image-20240126110654997" style="zoom: 80%;" /><p>这个量可以把前面的<strong>Irradiance</strong>和<strong>Intensity</strong>两个量联系在一起。</p><p>Irradiance表示单位面积的power，所以<strong>Radiance</strong>可以理解为<strong>单位立体角</strong>的<strong>Irradiance</strong></p><p>Intensity表示单位立体角的power，所以<strong>Radiance</strong>可以理解为<strong>单位面积</strong>的<strong>Intensity</strong></p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240126111114950.png" alt="image-20240126111114950" style="zoom:50%;" /><p>两者的区别在与是否考虑方向性：</p><p><strong>Irradiance</strong>指该单位面积接收的<strong>四面八方</strong>的光线的<strong>power的总和</strong>。简单来说就是某块区域收到的的power总和。</p><p><strong>Radiance</strong>指从该单位面积区域出发的某<strong>一方向</strong>辐射的<strong>power</strong>。简单来说就是某块区域某个方向发散的光线的power。</p><p>最后可得到下图中所式Irradiance和Radiance的联系：</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240126113127927.png" alt="image-20240126113127927" style="zoom:67%;" /><p>观察一下积分后的式子，<strong>E(p)<strong>就是点</strong>p</strong>的<strong>irradiance</strong>，那么该积分式子的物理含义便是，一个点(微分面积元)所接收到的亮度(irradiance)，由所有不同方向的入射光线亮度(radiance)共同贡献得到。</p><h3 id="双向反射分布函数-Bidirectional-Reflectance-Distribution-Function，BRDF"><a href="#双向反射分布函数-Bidirectional-Reflectance-Distribution-Function，BRDF" class="headerlink" title="双向反射分布函数(Bidirectional Reflectance Distribution Function，BRDF)"></a>双向反射分布函数(Bidirectional Reflectance Distribution Function，BRDF)</h3><p>​介绍了上面这些概念后，我们就开始更具体的描述一下反射。BRDF可以更具体的给出某点的<strong>入射光线经过反射后每个方向的反射光线的能量是多少</strong>，可以更真实的模拟真实的反射。</p><p>​现在我们可以换个角度理解反射，如下图所示：光线从某一方向照射到物体表面一点(表面微元)，会先吸收一部分能量，然后四处扩散这些能量。即根据入射光计算表明微元处的<strong>Radiance</strong>，然后再向四处扩散计算四周每个方向的<strong>Radiance</strong>。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240126154411561.png" alt="image-20240126154411561" style="zoom: 80%;" /><p>​在理想光滑表面会把入射光线完全反射到镜面反射方向，其它方向则完全没有。如理想粗糙表面会把入射光线均匀的反射到所有方向。因此所谓BRDF就是描述这样一个从不同方向入射之后，<strong>反射光线分布情况</strong>(每一个出射方向的能量的比例)的函数，定义如下：</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240126154918469.png" alt="image-20240126154918469" style="zoom: 80%;" /><p>​上图中下方的式子即为BRDF，它就收两个参数入射光方向ωi,反射光方向ωr ，<strong>函数值</strong>为反射光的<strong>radiance</strong>与入射光的<strong>iiradiance</strong>的比值。表明出射光在该方向的能量比例。</p><p>​借助BRDF，我们可以写出<strong>反射方程</strong>：</p><p>​简单描述就是入射点处吸收的iradiance乘以在该出射方向的比例，对于相机观测方向来说，所观察到的光的能量就是空间中所有能打到该点的radiance向该方向反射的radiance之和，所以要对半球面积分求和。（对于反射来说，我们只考虑上半球面，下半球面相当于从背面过来的，我们认为这部分贡献为0，所以不考虑 ）</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240126155600307.png" alt="image-20240126155600307" style="zoom: 50%;" /><p>​进一步考虑方程的通用性，加上物体自身发出的光线，就形成了<strong>渲染方程</strong>。渲染方程将光分为两部分：物体自身产生的向外发散的光(方程的前一项)、外来的光照射在物体表面被反射的光(方程的后一项)。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240126160230963.png" alt="image-20240126160230963" style="zoom:67%;" /><p>​其中<strong>L e ( p, ωo )L</strong> 为自发光项，反射方程中的<strong>cosθ</strong>用，<strong>n ⋅ ωi</strong>代替。(tips：所有光线方向均指向外)</p><p>​下面从点光源到多种光源具体解释一下渲染方程：</p><p>​对于点光源来说，本身就足够小，不用求积分。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240126163604630.png" alt="image-20240126163604630" style="zoom: 80%;" /><p>​对于多个点光源，只需要将其反射光的反射相加即可。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240126163614339.png" alt="image-20240126163614339" style="zoom: 80%;" /><p>​对于面光源来说，只需要将面上所有点光源累加即可。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240126163715862.png" alt="image-20240126163715862" style="zoom: 80%;" /><p>​再进一步加上场景中其他物体的间接反射光，也就形成了全局光照。</p><p>​可以把其它物体同样考虑成面光源，对其所占立体角进行积分即可，只不过对其它物体的立体角积分不像是面光源所有入射方向都有radiance，物体的立体角可能只有个别几个方向有入射的radiance(即多次物体间光线反射之后恰好照射到着色点x)，其它方向没有，但本质上都可以视作是面光源。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240126163819892.png" alt="image-20240126163819892" style="zoom: 80%;" /><p>​为了求解方便，我们转换一下参数，利用数学推导得出下图中式子：</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240126163906892.png" alt="image-20240126163906892" style="zoom: 80%;" /><p>​再进一步转化为线性表达式的形式：</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240126163915914.png" alt="image-20240126163915914" style="zoom: 80%;" /><p>​最终求解L可得：</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240126164022107.png" alt="image-20240126164022107" style="zoom: 80%;" /><p>​E为自身作为光源发出的光，KE则代表对光源反射一次的结果，即直接光照，那么前两项之和就是光栅化当中着色所考虑的结果，对于全局光照来说，还考虑了K^2^E，即一次弹射的间接照明，K^3^E 就是两次弹射的间接照明，依次类推。</p><p>​这样来看整个结果是不是就很清晰了，就是<strong>光源发光</strong>加上<strong>直接光照</strong>与<strong>多次间接光照</strong>的结果！而这一切都是从渲染方程推导而来的，因此这也正是渲染方程的物理意义！</p><h1 id="路径追踪-Path-Tracing"><a href="#路径追踪-Path-Tracing" class="headerlink" title="路径追踪(Path Tracing)"></a>路径追踪(Path Tracing)</h1><p>​我们虽然得到了渲染方程，但是是积分形式的渲染方程，为了得到可以具体实现应用，还需要对这个方程进行求解。但是渲染方程时积分的形式，我们无法准确求解，可以使用<strong>蒙特卡洛积分</strong>来<strong>求解渲染方程</strong>。</p><h2 id="蒙特卡洛积分-Monte-Carlo-Integration"><a href="#蒙特卡洛积分-Monte-Carlo-Integration" class="headerlink" title="蒙特卡洛积分(Monte Carlo Integration)"></a>蒙特卡洛积分(Monte Carlo Integration)</h2><p>​对于一个给定的函数<strong>f(x)</strong>，我们很容易求其在某一区间内的积分值，但是如下图中所示，我们<strong>无法准确写出其表达式</strong>，求[a,b]区间内的积分会非常困难，所以就有了蒙特卡洛积分。</p><p>​所以<strong>蒙特卡洛积分的目的：</strong> 当一个积分很难通过解析式得到答案的时候可以通过蒙特卡洛的方式<strong>近似</strong>得到积分结果。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240127163006089.png" alt="image-20240127163006089" style="zoom:67%;" /><p>​具体做法就是随机从[a,b]内取一点xi，求出这点的f(xi)，并用结果当作矩形的高,矩形的长为b-a，我们就用这样<strong>一个矩形的面积近似代替曲线面积</strong>。当我们<strong>取样的点足够多</strong>，并将<strong>这些面积进行平均求和</strong>，最后的结果就会非常<strong>接近原曲线围成的面积</strong>。蒙特卡洛积分的一般形式如下：</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240127164446051.png" alt="image-20240127164446051" style="zoom: 80%;" /><p>​假设我们做的是均匀采样，即<strong>p(x) &#x3D; 1&#x2F;(b-a)</strong>，带入可得到下式：</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240127164529009.png" alt="image-20240127164529009" style="zoom:90%;" /><h2 id="路径追踪-Path-Tracing-1"><a href="#路径追踪-Path-Tracing-1" class="headerlink" title="路径追踪(Path Tracing)"></a>路径追踪(Path Tracing)</h2><p>​我们先回顾一下前面的渲染方程，可以看到这个方程还是比较复杂的，并且由于多次的反射，函数还是一个递归式求解的，求解还是比较困难的。但是我们可以用<strong>蒙特卡洛积分进行求近似解</strong>。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240127165550323.png" alt="image-20240127165550323" style="zoom:67%;" /><p>要想解出以上方程的解主要有两个难点：</p><ol><li><strong>积分的计算</strong></li><li><strong>递归形式</strong></li></ol><p>​在进入具体计算之前，对渲染方程做出一点小修改，即舍弃一下自发光项(假设除了光源其他物体不会发光), 以方便进行计算推导：</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240127185658277.png" alt="image-20240127185658277"  /><p>​首先我们只考虑直接光照，即没有经过其他物体反射直接从光源照射到物体表面。我们考虑的光源都是面光源，点光源实际上实现比较困难。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240127185817756.png" alt="image-20240127185817756" style="zoom: 67%;" /><p>​观察该修改过之后的方程其实就只是一个单纯的积分计算了，其物理含义为着色点p到摄像机或人眼的Radiance值。</p><p>这么一个积分式我们直接展开计算是比较困难的，所以可以利用蒙特卡洛积分进行近似相等，近似结果如下：</p><p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240127190144947.png" alt="image-20240127190144947"></p><p>​正如一开始所说，先单独考虑直接光照，因此只有当采样的方向ωi击中光源的时候，光源才会对该着色点有贡献，计算伪代码如下：</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240127190233240.png" alt="image-20240127190233240" style="zoom: 80%;" /><p>​通过上面步骤，我们就解决了如何求积分的问题。但既然是为了实现全局光照，只考虑直接光照显然是不够的，我们必须把简介光照也考虑进来。如下图中情况所示，光线经过多次反射才进入相机。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240127190422104.png" alt="image-20240127190422104" style="zoom: 50%;" /><p>​那么该怎么样求出P点接收到的间接光线呢，对于Q到P的光线来说，我们可以此时把Q点看作一个光源，然后Q点向P点发散的Radiance，这就求出了P点接收到的间接入射光，这显然是一个递归式的求解过程，这也是为什么这个方法叫做路径追踪。伪代码如下：</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240127190846711.png" alt="image-20240127190846711" style="zoom: 80%;" /><p>​至此，我们成功通过蒙特卡洛的方式解出了渲染方程的积分值，也通过考虑直接光照与间接光照解决了递归的问题。但是现在还有一个致命的问题，对于递归算法来说，运行过程就好像数据结构中的树，每一个节点都会向下延伸n个子节点，这样下去数量级会爆炸式增长，这显然不是我们所希望看到的。</p><p>​就如下图所示，每次都采样100个点，即发射100条光线，经过反射一次后，反射处每次又会都发射100条光线，光线数量随反射次数乘指数级增长。</p><p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240127191033675.png" alt="image-20240127191033675"></p><p>​那么该如何解决这个问题呢？因为N表示蒙特卡洛积分的样本数量，但是根据指数函数会爆炸式增长，为了防止出现这种情况，我们只能将<strong>N取1</strong>，即<strong>每次只向一个方向发射光线</strong>。这样才不会随着反弹次数的增加指数级增长。</p><p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240127191431445.png" alt="image-20240127191431445"></p><p>​但是蒙特卡洛积分又是近似值，N&#x3D;1必然会导致得出的结果不准确，所以我们就需要多次执行这个递归算法，找到多条路径，最终的结果取平均值，尽量的减小误差。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240127191534017.png" alt="image-20240127191534017"  /><p>​下面是改良后的伪代码：</p><p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240127191608911.png" alt="image-20240127191608911"></p><p>​通过对经过像素的光线重复采样，每次在反射的时候只按分布随机选取一个方向，解决了只对经过像素的光线采样一次，而对反射光线按分布采样多次所导致的光线爆炸问题。</p><p>​但是现在问题还是没有解决，作为一个递归算法，可<strong>拆分子问题</strong>和<strong>结束条件</strong>两个因素缺一不可，我们的伪代码中似乎还没有说明递归应该什么时候停止，目前的算法只会一直递归下去，不会停止，这显然也是一个致命的问题。但是我们并不知道准确的退出次数，所以精妙的采用了<strong>俄罗斯轮盘赌(Russian Roulette)</strong>。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240127191908076.png" alt="image-20240127191908076" style="zoom:67%;" /><p>​给你一把左轮，两发子弹，你不知道哪一发会真正的射出子弹，因此拿这把左轮射自己，你有4&#x2F;6的概率活下来，这就是俄罗斯轮盘赌的概念。</p><p>​将其应用在路径追踪当中，首先设定一个概率P , <strong>有P的概率光线会继续递归并设置返回值为Lo &#x2F; P</strong>，有<strong>1 − P 的概率光线停止递归，并返回0</strong>。这样巧妙的设定之下光线一定会在某次反射之后停止递归，并且计算的结果依然是无偏的，因为最终的期望不变，证明如下：</p><p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240127192007558.png" alt="image-20240127192007558"></p><p>​至此伪代码可以改进为如下形式：</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240127192043052.png" alt="image-20240127192043052"  /><p>​到此看来我们的算法好像已经很完善了，但是最后还是有一个小问题，那就是<strong>算法的效率并不高</strong>。</p><p>​如下图所示：我们从某点向空间中上半球发射光线，随着光源区域的变小，可以到达光源的有效光线的比例也在减少。换句话说就是我们花费了大量的时间计算了不需要的方向，这导致这个算法效率比较低。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240127192146861.png" alt="image-20240127192146861" style="zoom: 80%;" /><p>​出现上述问题是因为我们是在空间中半球进行采样，那么我们直接在光源处进行采样，所有的计算不就都是有意义的计算了吗。但最大的问题就是如何将<strong>从对任意方向的采样转换到在光源上的采样</strong>，这就要最牛逼的数学登场了。</p><p>​假设光源的面积为A，那么对光源进行采样的pdf &#x3D; 1&#x2F;A (因为∫ pdf ⁡dA &#x3D; 1 )，但原始的渲染方程：</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240127192733131.png" alt="image-20240127192733131"  /><p>​显然两个方程的微分变量不同，我们要想把dw转换为dA，由微积分的知识可知，必须找到变量w和A之间的关系。如下图所示，我们可以理解为dw是光源上面积为dA的部分投影到球面上后所对应的立体角dw。</p><p>​首先将<strong>光源面乘以余弦值</strong>将光源面投影到与打出的光线垂直的方向，又因为立体角的定义是面积除以距离的平方，所以可以求出投影后的光源面积对应的立体角，将dw替换为dA的表达式即可。</p><p>​等式是由前面讲的立体角部分推导而来，左侧为<strong>立体角</strong>，右侧为<strong>球面的面积与半径的平方的比值</strong>。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240127192854758.png" alt="image-20240127192854758" style="zoom: 80%;" /><p>​根据这一关系，进行积分变量的替换后，渲染方程可以写为：</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240127193308830.png" alt="image-20240127193308830"  /><p>​这样便成功从 <strong>ωi</strong> 积分转到了对光源面积A的积分，就可以利用蒙特卡洛的方法对光源进行采样从而计算直接光照的积分值了，对于间接光照，依然采用先前的方法进行光线方向的均匀采样。最终伪代码如下，分直接光照和间接光照两部分计算：</p><p>​上一部分是计算直接光照，下部分会根据概率判断是否继续计算间接光照。这就得到了最终的路径追踪的算法。因为直接光照我们可以直接对光源采样得到，不需要用俄罗斯轮盘赌的方法进行判断；而间接光照由于需要递归多次，我们就用俄罗斯轮盘赌的方法结束递归。</p><p>​并且对应间接光照的部分，只计算来自非光源的反射光，因为这部分是直接光，第一部分就已经计算了，所以只需要计算由周围其他物体反射来的间接光。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240127193406394.png" alt="image-20240127193406394"  /><p>​另外计算直接光照的时候还需要判断光源与着色点之间是否有物体遮挡，该做法也很简单，只需从着色点x向光源采样点x’发出一条检测光线判断是否与光源之外的物体相交即可，如图所示:</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240127193550723.png" alt="image-20240127193550723"  /><h1 id="PBR（Physical-Based-Renderer）"><a href="#PBR（Physical-Based-Renderer）" class="headerlink" title="PBR（Physical Based Renderer）"></a>PBR（Physical Based Renderer）</h1><h2 id="Microfacet-Model（微表面模型）"><a href="#Microfacet-Model（微表面模型）" class="headerlink" title="Microfacet Model（微表面模型）"></a>Microfacet Model（微表面模型）</h2><h1 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h1><h1 id="games101作业"><a href="#games101作业" class="headerlink" title="games101作业"></a>games101作业</h1><h2 id="作业1"><a href="#作业1" class="headerlink" title="作业1"></a>作业1</h2><h2 id="作业2"><a href="#作业2" class="headerlink" title="作业2"></a>作业2</h2><h3 id="正常"><a href="#正常" class="headerlink" title="正常"></a>正常</h3><p>最普通的情况下没有进行任何的反走样，只是单纯的判断某个像素中心点在不在三角形内，再使用z-buffer算法更新frame_buffer中各像素的颜色值。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;Screen space rasterizationvoid rst::rasterizer::rasterize_triangle(const Triangle&amp; t) &#123;    auto v &#x3D; t.toVector4();        Vector3f triangleVector[3];    triangleVector[0] &#x3D; &#123; v[0].x(), v[0].y(), v[0].z() &#125;;    triangleVector[1] &#x3D; &#123; v[1].x(), v[1].y(), v[1].z() &#125;;    triangleVector[2] &#x3D; &#123; v[2].x(), v[2].y(), v[2].z() &#125;;    &#x2F;&#x2F;计算三角形的包围盒，加速光栅化    float minX &#x3D; INFINITY, minY &#x3D; INFINITY;    float maxX &#x3D; 0.0f, maxY &#x3D; 0.0f;    for (auto p : v)    &#123;        minX &#x3D; std::min(minX, p.x());        minY &#x3D; std::min(minY, p.y());        maxX &#x3D; std::max(maxX, p.x());        maxY &#x3D; std::max(maxY, p.y());    &#125;    &#x2F;&#x2F;使用z-buffer算法正常采样    for (int x &#x3D; (int)minX; x &lt;&#x3D; (int)maxX; x++)        for (int y &#x3D; (int)minY; y &lt;&#x3D; (int)maxY; y++)        &#123;            if (insideTriangle(x + 0.5f, y + 0.5f, triangleVector))            &#123;                auto[alpha, beta, gamma] &#x3D; computeBarycentric2D(x, y, t.v);                float w_reciprocal &#x3D; 1.0&#x2F;(alpha &#x2F; v[0].w() + beta &#x2F; v[1].w() + gamma &#x2F; v[2].w());                float z_interpolated &#x3D; alpha * v[0].z() &#x2F; v[0].w() + beta * v[1].z() &#x2F; v[1].w() + gamma * v[2].z() &#x2F; v[2].w();                z_interpolated *&#x3D; w_reciprocal;                &#x2F;&#x2F;如果当前像素深度值小于该像素的深度缓冲，则更新该像素的颜色缓冲                if (z_interpolated &lt; depth_buf[get_index(x,y)])                &#123;                    depth_buf[get_index(x, y)] &#x3D; z_interpolated;                    Vector3f point &#x3D; &#123; (float)x, (float)y, z_interpolated &#125;;                    Vector3f color &#x3D; t.getColor();                    set_pixel(point, color);               &#125;            &#125;        &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然可以正确绘制出来并且遮挡关系也正确，但是当我们放大图片后就会发现锯齿效果明显，所以需要反走样。</p><p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250910234251287.png" alt="image-20250910234251287" style="zoom: 67%;display = inline-block" /><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250910234354624.png" alt="image-20250910234354624" style="zoom: 40%;" /></p><h3 id="MSAA2X"><a href="#MSAA2X" class="headerlink" title="MSAA2X"></a>MSAA2X</h3><p>为了实现抗锯齿，这里使用MSAA2X，即使用每个像素4倍采样，以此实现抗锯齿。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;分别存放每个像素的4个采样块的深度缓冲和颜色缓冲，且大小是原来的4倍std::vector&lt;Eigen::Vector3f&gt; sup_frame_buf;std::vector&lt;float&gt; sup_depth_buf;&#x2F;&#x2F;传入正常的像素坐标和第i个采样块的标号，计算该采样块的序号（像素内4个采样块的序号从左到右，从上到下依次为0 1 2 3）int rst::rasterizer::get_supre_index(int x, int y, int i)&#123;    int row &#x3D; 2 * y + i &#x2F; 2;    int col &#x3D; 2 * x + i % 2;    return (height * 2 - 1 - row) * width * 2 + col;&#125;&#x2F;&#x2F;MSAA2x超采样float offets[4][2] &#x3D; &#123;    &#123;0.25,0.75&#125;,    &#123;0.75,0.75&#125;,    &#123;0.25,0.25&#125;,    &#123;0.75,0.25&#125;,&#125;;for(int x &#x3D; (int)minX; x &lt;&#x3D; (int)maxX; x++)    for (int y &#x3D; (int)minY; y &lt;&#x3D; (int)maxY; y++)    &#123;        &#x2F;&#x2F;遍历所有像素时，将每个像素的四个采样块也都看做单独的像素，记录每个采样块最终的颜色        int cnt &#x3D; 0;        for (int i &#x3D; 0; i &lt; 4; i++)        &#123;            if (insideTriangle(x + offets[i][0], y + offets[i][1], triangleVector))            &#123;                cnt++;                                auto [alpha, beta, gamma] &#x3D; computeBarycentric2D(x, y, t.v);                float w_reciprocal &#x3D; 1.0 &#x2F; (alpha &#x2F; v[0].w() + beta &#x2F; v[1].w() + gamma &#x2F; v[2].w());                float z_interpolated &#x3D; alpha * v[0].z() &#x2F; v[0].w() + beta * v[1].z() &#x2F; v[1].w() + gamma * v[2].z() &#x2F; v[2].w();                z_interpolated *&#x3D; w_reciprocal;                if (z_interpolated &lt; sup_depth_buf[get_supre_index(x, y ,i)])                &#123;                    sup_depth_buf[get_supre_index(x, y, i)] &#x3D; z_interpolated;                    sup_frame_buf[get_supre_index(x, y, i)] &#x3D; t.getColor();                &#125;            &#125;        &#125;        &#x2F;&#x2F;如果有一个采样块的颜色更新了，那么这个大像素的颜色就需要更新        if (cnt)        &#123;            Vector3f color &#x3D; Vector3f::Zero();            for (int i &#x3D; 0; i &lt; 4; i++) color +&#x3D; 0.25 * sup_frame_buf[get_supre_index(x, y, i)];            set_pixel(Vector3f&#123;(float)x, (float)y ,1.0&#125;, color);        &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终得到的图片即使放大同样的倍数也不会有明显的锯齿。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250910235144201.png" alt="image-20250910235144201" style="zoom: 67%;" />]]></content>
      
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL学习笔记</title>
      <link href="/2025/11/22/OpenGL/"/>
      <url>/2025/11/22/OpenGL/</url>
      
        <content type="html"><![CDATA[<h1 id="OpenGL介绍"><a href="#OpenGL介绍" class="headerlink" title="OpenGL介绍"></a>OpenGL介绍</h1><h2 id="图形API"><a href="#图形API" class="headerlink" title="图形API"></a>图形API</h2><p>OpenGL被认为是一个图形API(Application Programming Interface, 应用程序编程接口)，包含一系列可以操作图形、图像的函数。但是OpenGL实际上并不是一个供外界调用的API，它本质上是一个由<a href="http://www.khronos.org/">Khronos组织</a>制定并维护的规范。</p><p>OpenGL规定了每个函数的定义，输入和输出值，并不关心内部是如何实现的(类似java中的interface)。</p><p>也因此OpenGL的实现基本是由各大显卡厂商完成，各厂商要遵守这个规范，一般写在显卡的驱动程序中。开发者使用OpenGL时调用指定的函数，即可使用在不同显卡的设备中运行同一段代码。</p><p>在 OpenGL 中，<strong>默认的坐标系是右手坐标系</strong>，可以使用右手来判断坐标轴的正方向。</p><ul><li><strong>右手定则</strong>：<ul><li>伸出右手，<strong>拇指 &#x3D; X 轴（→）</strong>，<strong>食指 &#x3D; Y 轴（↑）</strong>，<strong>中指 &#x3D; Z 轴（☞ 屏幕外）</strong>。</li><li>这种定义下，<strong>摄像机默认看向 -Z 方向</strong>（即屏幕内）。</li></ul></li></ul><h2 id="立即模式和核心模式"><a href="#立即模式和核心模式" class="headerlink" title="立即模式和核心模式"></a>立即模式和核心模式</h2><p>早期的OpenGL使用<strong>立即渲染模式</strong>（Immediate mode，也就是固定渲染管线），这个模式下绘制图形很方便。OpenGL的大多数功能都被库隐藏起来，开发者很少有控制OpenGL如何进行计算的自由。</p><p><strong>OpenGL3.2</strong>开始，规范文档开始废弃立即渲染模式，并鼓励开发者在OpenGL的<strong>核心模式</strong>(Core-profile)下进行开发，这个分支的规范完全移除了旧的特性。</p><p>虽然OpenGL的新版本一直在更新，但是作为初学者从支持核心模式的旧版本开始学习也是没问题的。因为所有OpenGL的更高的版本都是在3.3的基础上，引入了额外的功能，并没有改动核心架构。新版本只是引入了一些更有效率或更有用的方式去完成同样的功能。因此，所有的概念和技术在现代OpenGL版本里都保持一致。当你的经验足够，你可以轻松使用来自更高版本OpenGL的新特性。</p><h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><h2 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h2><p>OpenGL中<strong>默认</strong>规定三角形的三个顶点的连接顺序为<strong>逆时针</strong>，即将<strong>逆时针方向</strong>连接的三角形视为<strong>正面</strong>，但是对于正面判定也可以通过OpenGL中的函数进行修改。</p><p>规定了三角形的正反面后，在后续进行渲染时，不会渲染反面三角形（反面三角形是被遮挡看不到的，跳过渲染节省计算量）。</p><h1 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h1><p>CMake 是个一个开源的跨平台自动化建构系统，用来管理软件建置的程序，并不依赖于某特定编译器，并可支持多层目录、多个应用程序与多个函数库。 CMake 本身不是构建工具，而是生成构建系统的工具，它生成的构建系统可以使用不同的编译器和工具链。</p><p>CMake使用**CMakeLists.txt（文件名不可变）**文件作为配置文件，用于定义项目的构建规则、依赖关系、编译选项等。每个 CMake 项目通常包含一个或多个 CMakeLists.txt 文件。</p><h2 id="简单的CMake项目工程"><a href="#简单的CMake项目工程" class="headerlink" title="简单的CMake项目工程"></a>简单的CMake项目工程</h2><p>下面是一个简单CMake项目示例，项目文件夹中只有一个main.cpp作为源文件。</p><p>下面是该项目的CMakeLists.txt文件内容：</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment">#设置该CMake项目的最低CMake版本要求</span><span class="token keyword">cmake_minimum_required</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">3.17</span><span class="token punctuation">)</span><span class="token comment">#设置项目名称</span><span class="token keyword">project</span><span class="token punctuation">(</span>OpenGL<span class="token punctuation">)</span><span class="token comment">#设置项目所使用的c++版本为c++17</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">CMAKE_CXX_STANDARD</span> <span class="token number">17</span><span class="token punctuation">)</span><span class="token comment">#指定要生成的可执行文件和其源文件（第一个参数是生成的可执行文件的名称，后面的参数是源文件）</span><span class="token comment">#参数之间空格隔开</span><span class="token keyword">add_executable</span><span class="token punctuation">(</span>OpenGLStudy <span class="token string">"main.cpp"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250411204132847.png" alt="image-20250411204132847" style="zoom: 67%;" /><p>项目文件准备完成后，使用vs按照上图所示操作打开CMake项目，vs会根据配置文件生成对应的文件。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250411204540750.png" alt="image-20250411204540750" style="zoom:67%;" /><p>如上图所示，在项目根目录下会生成out文件夹，里面存放的就是生成的目标文件。因此在分享项目工程时，out文件夹和.vs文件夹可以删除，这些都是IDE自动生成的，而且比较大。在根目录下的out&#x2F;build&#x2F;x64-Debug目录下可以看到生成的可执行文件，名称和我们在CMakeLists.txt中定义的一样。</p><h2 id="多源文件编译"><a href="#多源文件编译" class="headerlink" title="多源文件编译"></a>多源文件编译</h2><p>实际开发中，肯定不可能只有一个main.cpp文件，我们肯定会创建许多类，会有多个cpp文件。</p><p>如下图所示，新建了func.h和func.cpp文件，在main.cpp文件中使用了func.cpp实现的add函数，此时如果直接运行代码会报错，因为我们并没有将func.cpp加入到CMake的编译目标中。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250411215637145.png" alt="image-20250411215637145" style="zoom:67%;" /><p>我们有两种解决方法：</p><ol><li>手动将所有的cpp文件加入到CMakeLists.txt中的源文件中</li></ol><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment">#设置该CMake项目的最低CMake版本要求</span><span class="token keyword">cmake_minimum_required</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">3.17</span><span class="token punctuation">)</span><span class="token comment">#设置项目名称</span><span class="token keyword">project</span><span class="token punctuation">(</span>00_Test<span class="token punctuation">)</span><span class="token comment">#设置项目所使用的c++版本为c++17</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">CMAKE_CXX_STANDARD</span> <span class="token number">17</span><span class="token punctuation">)</span><span class="token comment">#指定要生成的可执行文件和其源文件（第一个参数是生成的可执行文件的名称，后面的参数是源文件）</span><span class="token keyword">add_executable</span><span class="token punctuation">(</span>OpenGLStudy <span class="token string">"main.cpp"</span> <span class="token string">"func.cpp"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>将根目录下的所有cpp找到并定义为一个新变量，使用该变量代替所有的源文件</li></ol><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment">#设置该CMake项目的最低CMake版本要求</span><span class="token keyword">cmake_minimum_required</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">3.17</span><span class="token punctuation">)</span><span class="token comment">#设置项目名称</span><span class="token keyword">project</span><span class="token punctuation">(</span>00_Test<span class="token punctuation">)</span><span class="token comment">#设置项目所使用的c++版本为c++17</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">CMAKE_CXX_STANDARD</span> <span class="token number">17</span><span class="token punctuation">)</span><span class="token comment">#搜索当前目录下的所有cpp文件，加入到RES变量中</span><span class="token comment"># . 表示当前目录</span><span class="token keyword">aux_source_directory</span><span class="token punctuation">(</span>. RES<span class="token punctuation">)</span><span class="token comment">#指定要生成的可执行文件和其源文件，使用RES变量替换所有的源文件名称</span><span class="token comment">#$&#123;RES&#125;表示将变量里面cpp都展开，效果和第一种等效</span><span class="token keyword">add_executable</span><span class="token punctuation">(</span>OpenGLStudy <span class="token punctuation">$&#123;</span>RES<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一种比较简单暴力，但是维护困难，不推荐。</p><p>第二种效果和第一种是等价的，但是由CMake自动完成，快捷容易维护。</p><h2 id="多文件夹编译"><a href="#多文件夹编译" class="headerlink" title="多文件夹编译"></a>多文件夹编译</h2><p>开发中为了规范，不可能将所有的cpp文件都放在根目录下，因此我们会创建专门的文件夹存放对应的cpp文件。</p><p>如下图所示，我们将func.cpp和func.h放在了funcs文件夹下，里面存放的都是我们自己实现的函数，但是这样一来CMake就会找不到func.cpp文件而报错。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250412112710734.png" alt="image-20250412112710734" style="zoom: 67%;" /><ol><li>首先我们先在funcs目录下新建一个CMakeLists.txt文件，编译时将该目录下的所有cpp文件编译为一个lib库</li></ol><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250412114046837.png" alt="image-20250412114046837" style="zoom:67%;" /><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment">#递归扫描当前目录下的所有cpp文件，将其存到FUNCS变量</span><span class="token comment">#GLOB_RECURSE表示递归查询；FUNCS表示变量名；./*.cpp表示该目录下的所有cpp文件</span><span class="token keyword">file</span><span class="token punctuation">(</span>GLOB_RECURSE FUNCS ./*.cpp<span class="token punctuation">)</span><span class="token comment">#将FUNCS变量中的所有cpp文件编译成名字为MyFuncLib的lib库</span><span class="token comment">#第一个参数是编译成的lib库的名字</span><span class="token keyword">add_library</span><span class="token punctuation">(</span>MyFuncLib <span class="token punctuation">$&#123;</span>FUNCS<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>接下来只需要在根目录下的CMakeLists.txt文件中将生成的lib库连接到可执行文件即可</li></ol><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment">#设置该CMake项目的最低CMake版本要求</span><span class="token keyword">cmake_minimum_required</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">3.17</span><span class="token punctuation">)</span><span class="token comment">#设置项目名称</span><span class="token keyword">project</span><span class="token punctuation">(</span>00_Test<span class="token punctuation">)</span><span class="token comment">#设置项目所使用的c++版本为c++17</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">CMAKE_CXX_STANDARD</span> <span class="token number">17</span><span class="token punctuation">)</span><span class="token comment">#---------------------------------------------------------------------新增</span><span class="token comment">#将funcs文件夹加入编译系统(会执行该文件夹下的CMakeLists.txt文件)</span><span class="token keyword">add_subdirectory</span><span class="token punctuation">(</span>funcs<span class="token punctuation">)</span><span class="token comment">#搜索当前目录下的所有cpp文件，加入到RES变量中</span><span class="token comment"># . 表示当前目录</span><span class="token keyword">aux_source_directory</span><span class="token punctuation">(</span>. RES<span class="token punctuation">)</span><span class="token comment">#指定要生成的可执行文件和其源文件，使用RES变量替换所有的源文件名称</span><span class="token comment">#$&#123;RES&#125;表示将变量里面cpp都展开，效果和第一种等效</span><span class="token keyword">add_executable</span><span class="token punctuation">(</span>OpenGLStudy <span class="token punctuation">$&#123;</span>RES<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">#---------------------------------------------------------------------新增</span><span class="token comment">#将funcs目录下生成的连接库连接到我们最终生成的的可执行文件中</span><span class="token keyword">target_link_libraries</span><span class="token punctuation">(</span>OpenGLStudy MyFuncLib<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250412115430563.png" alt="image-20250412115430563" style="zoom:67%;" /><p>最后可以在生成的out目录下找到func文件夹，里面就是生成的lib库。</p><h2 id="资源拷贝"><a href="#资源拷贝" class="headerlink" title="资源拷贝"></a>资源拷贝</h2><p>在进行OpenGL开发中，我们会经常使用各种各样的图片素材，或者其他第三方的dll库，我们开发中会在根目录下创建对应的文件夹存放我们的素材和第三方链接库。</p><p>但是这些文件要放在最后生成的可执行文件同目录下才可以被正确的使用，但是CMake生成的可执行文件在out目录里。所以我们必须手动的将这些文件夹复制到可执行文件的同目录下，不仅麻烦而且容易出错。</p><p>为了方便，我们可以使用CMake的资源拷贝功能，自动的将这些文件复制到可执行文件统计目录下，只需要每次添加新素材或者链接库时重新生成一下即可，CMake会自动拷贝这些文件。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250412115647966.png" alt="image-20250412115647966" style="zoom:67%;" /><p>想实现这个功能，只需要在根目录下的CMakeLists.txt文件中添加这两句指令即可</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment">#资源拷贝</span><span class="token comment">#给出需要拷贝的资源路径，将路径里的文件放到ASSETS变量中</span><span class="token keyword">file</span><span class="token punctuation">(</span>GLOB ASSETS <span class="token string">"./assets"</span> <span class="token string">"./thirdParty/test.dll"</span><span class="token punctuation">)</span><span class="token comment">#将ASSETS中的内容都拷贝到可执行文件所在目录下</span><span class="token comment">#CMAKE_BINARY_DIR指的是当前项目可执行文件的所在目录</span><span class="token keyword">file</span><span class="token punctuation">(</span>COPY <span class="token punctuation">$&#123;</span>ASSETS<span class="token punctuation">&#125;</span> DESTINATION <span class="token punctuation">$&#123;</span><span class="token variable">CMAKE_BINARY_DIR</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250412120621684.png" alt="image-20250412120621684" style="zoom:67%;" /><p>编写完成后在重新生成即可看到所需要的文件已经被拷贝到了可执行文件所在目录。</p><h1 id="GLAD"><a href="#GLAD" class="headerlink" title="GLAD"></a>GLAD</h1><p>GLAD是一个 <strong>OpenGL 函数加载库</strong>，用于动态加载 OpenGL 驱动程序的函数指针。因为OpenGL是一个规范，只对各个函数进行了定义，并没有具体实现，具体的实现在各个显卡的驱动程序里。所以我们想使用某个函数，就必须从驱动程序中拿到对应的函数指针。我们可以手动指定加载哪些函数的函数指针，但是函数有那么多，我们不可能每一个都手动加载进来。</p><p>GLAD就帮我们完成了这一工程，只需要使用GLAD提供的几行代码，就可以完成对应函数指针的加载。</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>访问<a href="https://glad.dav1d.de/%E5%8D%B3%E5%8F%AF%E6%89%BE%E5%88%B0glad%E7%9A%84%E4%B8%8B%E8%BD%BD%E7%95%8C%E9%9D%A2%EF%BC%8C%E8%BF%9B%E5%85%A5%E5%90%8E%E6%88%91%E4%BB%AC%E4%BC%9A%E7%9C%8B%E5%88%B0%E5%A6%82%E4%B8%8B%E5%86%85%E5%AE%B9%EF%BC%9A">https://glad.dav1d.de/即可找到glad的下载界面，进入后我们会看到如下内容：</a></p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250412171016000.png" alt="image-20250412171016000" style="zoom: 50%;" /><p>我们只需选择对应的选项，再点击右下角的生成按钮，即可获得对应的代码。获取的文件如下图所示，我们可以获得对应的头文件和源代码。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250412171141544.png" alt="image-20250412171141544" style="zoom:67%;" /><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250412171614442.png" alt="image-20250412171614442" style="zoom:67%;" /><p>这里引入项目的方式和GLFW类似，直接将include里面的东西都复制到thirdParty目录下的include文件夹中，但由于直接提供了源码，为了方便起见，我们直接将源码glad.c放到和main.cpp同样的目录下。</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment">#CMakeLists.txt只需要修改这一句即可，将glad.c连接到可执行文件中</span><span class="token keyword">add_executable</span><span class="token punctuation">(</span>OpenGLStudy <span class="token string">"main.cpp"</span> <span class="token string">"glad.c"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;&#x2F;&#x2F;gald的引入要在glfw上面，不然会报错#include &lt;glad&#x2F;glad.h&gt;#include &lt;GLFW&#x2F;glfw3.h&gt;int main()&#123;std::cout&lt;&lt;&quot;Hello World&quot;&lt;&lt;std::endl;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>使用gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)代码即可完成加载，如果加载成功会返回true，加载失败返回false。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if(gladLoadGLLoader((GLADloadproc)glfwGetProcAddress) )&#123;    std::cout&lt;&lt;&quot;加载成功&quot;&lt;&lt;std::endl;&#125;else&#123;    std::cout&lt;&lt;&quot;加载失败&quot;&lt;&lt;std::endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="GLFW"><a href="#GLFW" class="headerlink" title="GLFW"></a>GLFW</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>如果我们想进行图形学的编程，必然需要创建一个窗口展示效果，但是不同的操作系统创建一个窗口的方式天差地别且还需要考虑与OpenGL等图形学API的兼容性。GLFW是一个轻量级的 <strong>跨平台窗口和输入管理库</strong>，专门为 OpenGL&#x2F;Vulkan 设计。其只负责创建窗口、处理用户输入（键盘&#x2F;鼠标&#x2F;手柄）、控制上下文（OpenGL 渲染环境）等操作，相当于为我们创建了一个画布，我们可以使用OpenGL规定的API在该窗口绘制图形。</p><h2 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h2><p>到官网下载对应的库（下载源码自己编译或者下载已经编译好的库），这里使用官方提供的已经编译好的库。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250412162250191.png" alt="image-20250412162250191" style="zoom:67%;" /><p>打开文件夹可以看到如上图所示的文件，include文件夹里存放的是我们要引用的头文件，下面lib开头的是各个版本的链接库，现在使用的是vs2019，所以选择lib-vc2019里面的库。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250412162410785.png" alt="image-20250412162410785" style="zoom:50%;" /><p>进入之后可以看到上图所示的链接库，根据不同的方案使用不同的库。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250412162452050.png" alt="image-20250412162452050" style="zoom:50%;" /><p>为了方便起见，直接使用第一种静态链接的方式。</p><p>照下图所示新建一个项目，thirdParty文件夹用来存放所有的第三方库，include文件夹存放头文件，lib文件夹存放对应的lib链接文件。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250412165203427.png" alt="image-20250412165203427" style="zoom:67%;" /><p>下面就是设置引入路径和链接路径，引入路径就是在写代码时#include搜寻的目录，链接路径就是链接时搜寻的路径。</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment">#设置该CMake项目的最低CMake版本要求</span><span class="token keyword">cmake_minimum_required</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">3.17</span><span class="token punctuation">)</span><span class="token comment">#设置项目名称</span><span class="token keyword">project</span><span class="token punctuation">(</span>01_Config<span class="token punctuation">)</span><span class="token comment">#设置项目所使用的c++版本为c++17</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">CMAKE_CXX_STANDARD</span> <span class="token number">17</span><span class="token punctuation">)</span><span class="token comment">#将存放头文件的路径加入引入路径</span><span class="token comment">#如果不设置，在main.cpp只能#include "thirdParty/include/GLFW/glfw.h"引入</span><span class="token comment">#设置后，在main.cpp就可以#include "GLFW/glfw.h"引入</span><span class="token keyword">include_directories</span><span class="token punctuation">(</span>SYSTEM <span class="token punctuation">$&#123;</span><span class="token variable">CMAKE_SOURCE_DIR</span><span class="token punctuation">&#125;</span>/thirdParty/include<span class="token punctuation">)</span><span class="token comment">#将存放链接库的路径加入链接路径</span><span class="token keyword">link_directories</span><span class="token punctuation">(</span>SYSTEM <span class="token punctuation">$&#123;</span><span class="token variable">CMAKE_SOURCE_DIR</span><span class="token punctuation">&#125;</span>/thirdParty/lib<span class="token punctuation">)</span><span class="token keyword">add_executable</span><span class="token punctuation">(</span>OpenGLStudy <span class="token string">"main.cpp"</span><span class="token punctuation">)</span><span class="token comment">#CMake会根据我们设置的链接路径寻找该lib文件</span><span class="token keyword">target_link_libraries</span><span class="token punctuation">(</span>OpenGLStudy glfw3.lib<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样配置完成后我们就可以运行成功了。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include &quot;GLFW&#x2F;glfw3.h&quot;int main()&#123;std::cout&lt;&lt;&quot;Hello World&quot;&lt;&lt;std::endl;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="创建窗口"><a href="#创建窗口" class="headerlink" title="创建窗口"></a>创建窗口</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;glad&#x2F;glad.h&gt;&#x2F;&#x2F;这个头文件引用要在glfw头文件引用上方#include &lt;GLFW&#x2F;glfw3.h&gt;int main()&#123;    &#x2F;&#x2F;初始化    glfwInit();    &#x2F;&#x2F;设置主版本号、次版本号 用的是4.6版本，所以是4和6    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);    &#x2F;&#x2F;设置OpenGL启用核心模式    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);    &#x2F;&#x2F;创建窗体对象    GLFWwindow* window &#x3D; glfwCreateWindow(800, 600, &quot;OpenGL&quot;, NULL, NULL);    &#x2F;&#x2F;设置OpenGL绘制的窗口    glfwMakeContextCurrent(window);    &#x2F;&#x2F;执行循环，窗口关闭时退出循环    while (!glfwWindowShouldClose(window))    &#123;        &#x2F;&#x2F;执行        glfwPollEvents();    &#125;    &#x2F;&#x2F;退出程序前的清理工作    glfwTerminate();    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h2><p>和其他框架一样，OpenGL也有一套事件监听系统，但是事件的回调函数需要我们自己根据定义自己实现，并且手动将窗口和事件回调函数绑定。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include &lt;glad&#x2F;glad.h&gt;&#x2F;&#x2F;这个头文件引用要在glfw头文件引用上方#include &lt;GLFW&#x2F;glfw3.h&gt;&#x2F;&#x2F;定义一个窗口大小改变时的回调函数，与window窗口绑定void frameBufferSizeCallBack(GLFWwindow* window, int width, int height)&#123;    std::cout &lt;&lt; width &lt;&lt; &quot; &quot; &lt;&lt; height &lt;&lt; std::endl;&#125;&#x2F;&#x2F;键盘事件监听的回调函数&#x2F;**  key是按下或者松开的键盘按键。*  scancode是一个系统平台相关的键位扫描码信息,终点关注第一个参数即可*  action可以是GLFW_PRESS（按下键），GLFW_RELEASE（松开键），GLFW_REPEAT（连续输入模式）中的一个。*  mods对应着辅助键的设置，例如shift和ctrl是否同时被按下。(参数值) ctrl&#x3D;2,shift&#x3D;1,shift+ctrl&#x3D;3,一个都没按&#x3D;0*&#x2F;void keyCallBack(GLFWwindow* window, int key, int scancode, int action, int mods)&#123;    std::cout &lt;&lt; key &lt;&lt; &quot; &quot; &lt;&lt; scancode&lt;&lt; &quot; &quot; &lt;&lt; action&lt;&lt; &quot; &quot; &lt;&lt; mods &lt;&lt; std::endl;&#125;int main()&#123;    &#x2F;&#x2F;初始化    glfwInit();    &#x2F;&#x2F;设置主版本号、次版本号 用的是4.6版本，所以是4和6    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);    &#x2F;&#x2F;设置OpenGL启用核心模式    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);    &#x2F;&#x2F;创建窗体对象    GLFWwindow* window &#x3D; glfwCreateWindow(800, 600, &quot;OpenGL&quot;, NULL, NULL);    &#x2F;&#x2F;设置OpenGL绘制的窗口    glfwMakeContextCurrent(window);    &#x2F;&#x2F;设置监听窗口尺寸改变事件，并指定回调函数    glfwSetFramebufferSizeCallback(window, frameBufferSizeCallBack);    glfwSetKeyCallback(window, keyCallBack);    &#x2F;&#x2F;执行循环，窗口关闭时退出循环    while (!glfwWindowShouldClose(window))    &#123;        &#x2F;&#x2F;执行        glfwPollEvents();    &#125;    &#x2F;&#x2F;退出程序前的清理工作    glfwTerminate();    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为事件会有很多，所以只列举开发中常用的事件：窗口大小改变事件，键盘事件，鼠标事件等。</p><h3 id="窗口尺寸改变事件"><a href="#窗口尺寸改变事件" class="headerlink" title="窗口尺寸改变事件"></a>窗口尺寸改变事件</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;定义一个窗口大小改变时的回调函数，与window窗口绑定&#x2F;*width参数是新窗口的宽度height参数是新窗口的高度*&#x2F;void frameBufferSizeCallBack(GLFWwindow* window, int width, int height)&#123;    std::cout &lt;&lt; width &lt;&lt; &quot; &quot; &lt;&lt; height &lt;&lt; std::endl;&#125;&#x2F;&#x2F;事件绑定glfwSetFramebufferSizeCallback(window, frameBufferSizeCallBack);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;键盘事件监听的回调函数&#x2F;**  key是按下或者松开的键盘按键。*  scancode是一个系统平台相关的键位扫描码信息,不需要特别关注这个参数*  action可以是当前的动作GLFW_PRESS（按下键），GLFW_RELEASE（松开键），GLFW_REPEAT（连续输入模式）。*  mods对应着辅助键的设置，例如shift和ctrl是否同时被按下。(参数值) ctrl&#x3D;2,shift&#x3D;1,shift+ctrl&#x3D;3,一个都没按&#x3D;0*&#x2F;void keyCallBack(GLFWwindow* window, int key, int scancode, int action, int mods)&#123;    if(key&#x3D;&#x3D;GLFW_KEY_W)std::cout&lt;&lt;&quot;触发了W键&quot;;    if(action&#x3D;&#x3D;GLFW_PRESS)std::cout&lt;&lt;&quot;按下了某个键&quot;;    if(action&#x3D;&#x3D;GLFW_MOD_SHIFT)std::cout&lt;&lt;&quot;按下了shift键&quot;;    std::cout &lt;&lt; key &lt;&lt; &quot; &quot; &lt;&lt; scancode&lt;&lt; &quot; &quot; &lt;&lt; action&lt;&lt; &quot; &quot; &lt;&lt; mods &lt;&lt; std::endl;&#125;glfwSetKeyCallback(window, keyCallBack);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在OpenGL中，用<strong>GLFW_KEY_XX</strong>格式的常量定义好了各种按键的值，各种模式、触发类型都有对应的常量表示，判断时直接使用即可。</p><h3 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;--------------------------------------鼠标按键事件&#x2F;**  button是按下或者松开的键盘按键。GLFW_MOUSE_BUTTON_LEFT（鼠标左键），GLFW_MOUSE_BUTTON_RIGHT(鼠标右键)。*  action可以是当前的动作GLFW_PRESS（按下键），GLFW_RELEASE（松开键）。*  mods对应着辅助键的设置，例如shift和ctrl是否同时被按下。(参数值) ctrl&#x3D;2,shift&#x3D;1,shift+ctrl&#x3D;3,一个都没按为0*&#x2F;void MouseButtonCallback(GLFWwindow* window, int button, int action, int mods)&#123;     if (action &#x3D;&#x3D; GLFW_PRESS)    &#123;        if (button &#x3D;&#x3D; GLFW_MOUSE_BUTTON_LEFT)std::cout &lt;&lt; &quot;鼠标左键&quot; &lt;&lt; std::endl;        std::cout &lt;&lt; mods &lt;&lt; std::endl;    &#125;&#125;&#x2F;&#x2F;--------------------------------------鼠标滚轮事件&#x2F;**  xoffset是滚轮水平滚动的值，但是大部分鼠标只有垂直滚动，因此该值大部分情况为0*  yoffset是滚轮垂直滚动的值，向上(远离用户方向)滚动值为1，向下(靠近用户方向)滚动值为-1*&#x2F;void MouseScrollCallback(GLFWwindow* window, double xoffset, double yoffset)&#123;    std::cout &lt;&lt; xOffset &lt;&lt; &quot; &quot; &lt;&lt; yOffset &lt;&lt; std::endl;&#125;glfwSetMouseButtonCallback(window, MouseButtonCallback);glfwSetScrollCallback(window, MouseScrollCallback);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="GLAD-1"><a href="#GLAD-1" class="headerlink" title="GLAD"></a>GLAD</h1><p>我们下载的GLFW文件中只有<strong>glfw.h</strong>头文件和<strong>lib</strong>静态链接库文件供我们使用。但是OpenGL也只是一种规范，具体的实现由显卡厂商决定，所以我们必须要拿到驱动程序中厂家实现好的OpenGL的函数。glad可以帮助我们更好的<strong>从驱动程序加载这些函数</strong>，供我们使用。成功引入glad后，我们可以用以下代码加载函数。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include &lt;glad&#x2F;glad.h&gt;&#x2F;&#x2F;这个头文件引用要在glfw头文件引用上方#include &lt;GLFW&#x2F;glfw3.h&gt;&#x2F;&#x2F;定义一个窗口大小改变时的回调函数，与window窗口绑定void frameBufferSizeCallBack(GLFWwindow* window, int width, int height)&#123;    std::cout &lt;&lt; width &lt;&lt; &quot; &quot; &lt;&lt; height &lt;&lt; std::endl;    &#x2F;&#x2F;改变窗口大小时同时改变视口大小    glViewport(0, 0, width, height);&#125;&#x2F;&#x2F;键盘事件监听的回调函数void keyCallBack(GLFWwindow* window, int key, int scancode, int action, int mods)&#123;    std::cout &lt;&lt; key &lt;&lt; &quot; &quot; &lt;&lt; scancode &lt;&lt; &quot; &quot; &lt;&lt; action &lt;&lt; &quot; &quot; &lt;&lt; mods &lt;&lt; std::endl;&#125;int main()&#123;    &#x2F;&#x2F;初始化    glfwInit();    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);    GLFWwindow* window &#x3D; glfwCreateWindow(800, 600, &quot;OpenGL&quot;, NULL, NULL);    glfwMakeContextCurrent(window);    glfwSetFramebufferSizeCallback(window, frameBufferSizeCallBack);    glfwSetKeyCallback(window, keyCallBack);    &#x2F;&#x2F;用glad加载显卡中具体实现的OpenGL的函数    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123;        &#x2F;&#x2F;如果加载出错        std::cout &lt;&lt; &quot;加载出错&quot; &lt;&lt; std::endl;        return -1;    &#125;    &#x2F;&#x2F;如果加载成功就可以正常使用这些函数    &#x2F;&#x2F;设置视口位置和大小    glViewport(0, 0, 800, 600);    &#x2F;&#x2F;设置窗口清理画布使用的颜色    glClearColor(0.8f, 0.81f, 0.83f, 0.8f);    &#x2F;&#x2F;执行循环，窗口关闭时退出循环    while (!glfwWindowShouldClose(window))    &#123;        &#x2F;&#x2F;执行一系列事件操作,不写的话无法处理各种事件        glfwPollEvents();        &#x2F;&#x2F;清理画布(清理上一帧的画面，开始绘制下一帧)        glClear(GL_COLOR_BUFFER_BIT);        &#x2F;&#x2F;渲染工作                &#x2F;&#x2F;切换双缓存(shi&#39;jue)        glfwSwapBuffers(window);    &#125;    &#x2F;&#x2F;退出程序前的清理工作    glfwTerminate();    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="stb-image"><a href="#stb-image" class="headerlink" title="stb_image"></a>stb_image</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>为了在后面的学习中使用纹理，我们首先需要能够读取各种格式的图片。而stb_image就是一个提供各种格式图片数据读取的第三方库，我们只需要下载后引入对应的头文件，简单配置一下就能开始使用。</p><h2 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h2><p>下载源文件后，可以发现每个功能都是一个单独的.h文件，所以我们只需要#include引入对应功能的.h文件即可。阅读文档可知我们读取图片需要引入stb_image.h头文件，并且要在引入前定义一个宏<strong>STB_IMAGE_IMPLEMENTATION</strong>才能正常使用。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define STB_IMAGE_IMPLEMENTATION#include &lt;stb_image&#x2F;stb_image.h&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>**注意：<strong>图片的原点是左上角，但是在opengl中原点为左下角，所以在读取图片前需要翻转图片的y轴。在stb_image中，只需要在读取图片前使用</strong>stbi_set_flip_vertically_on_load(true)**即可实现y轴翻转。</p><h2 id="读取图片"><a href="#读取图片" class="headerlink" title="读取图片"></a>读取图片</h2><p>读取图片只需调用该函数即可，其中返回值为<strong>stbi_uc</strong>*，其实就是stb_image封装的**unsigned char ***数据类型。</p><p>其中最后一个参数是我们期待的拿到的图片通道格式，比如我们的图片只有rgb三个通道，但是实际需要rgba四个通道的数据，那么stbimage就可以完成格式之间的转化，共有四个选项可以选择。</p><p>STBI_grey ，STBI_grey_alpha，STBI_rgb，STBI_rgb_alpha。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250704224424533.png" alt="image-20250704224424533" style="zoom:50%;" /><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int width, height, channel;&#x2F;&#x2F;读取图片&#x2F;&#x2F;翻转y轴，使图片原点和opengl原点一致stbi_set_flip_vertically_on_load(true);&#x2F;&#x2F;读取纹理图片的数据到内存unsigned char* data &#x3D; stbi_load(&quot;Assets&#x2F;Textures&#x2F;a.png&quot;, &amp;width, &amp;height, &amp;channel, STBI_rgb_alpha);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="GLM"><a href="#GLM" class="headerlink" title="GLM"></a>GLM</h1><h2 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h2><p>GLM（OpenGL Mathematics）是基于OpenGL着色语言（GLSL）规范的图形软件的头文件C ++数学库。</p><p> GLM提供的类和函数使用与GLSL相同的命名约定和功能设计和实现，因此了解GLSL就可以C ++中使用GLM。</p><p>OpenGL没有内建矩阵运算方法，经常使用第三方库GLM来进行矩阵运算。GLM作为一个header only库，只要包括了相应的头文件就可以使用它提供的类和函数。</p><h2 id="常用数据类型"><a href="#常用数据类型" class="headerlink" title="常用数据类型"></a>常用数据类型</h2><ul><li>vec2 二维向量</li><li>vec3 三维向量</li><li>vec4 四维向量</li><li>quat 单精度四元数</li><li>dquat 双精度四元数</li><li>mat2 二阶矩阵(2x2方阵)</li><li>mat3 三阶矩阵(3x3方阵)</li><li>mat4 四阶方阵(4x4方阵)</li></ul><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><p>GLM对于矩阵数据类型的定义位于glm&#x2F;glm.hpp头文件中。</p><p>生成变换矩阵的函数位于glm&#x2F;gtc&#x2F;matrix_transform.hpp头文件中。</p><p>将数组转换成矩阵的函数位于头文件glm&#x2F;gtc&#x2F;type_ptr.hpp中（glm::value_ptr函数在里面）。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;正常情况下只需要引入这些头文件即可正常使用#include &lt;glm&#x2F;glm.hpp&gt;#include &lt;glm&#x2F;gtc&#x2F;matrix_transform.hpp&gt;#include &lt;glm&#x2F;gtc&#x2F;type_ptr.hpp&gt;&#x2F;&#x2F;这个头文件重载了 &lt;&lt; 符号，可以用cout直接输出向量或者矩阵变量#define GLM_ENABLE_EXPERIMENTAL&#x2F;&#x2F;不加这个宏无法使用io.hpp头文件#include &lt;glm&#x2F;gtx&#x2F;io.hpp&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><ol><li>默认构造函数(没有初始化的向量或矩阵无法正常使用)</li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;glm1.0.0版本后必须显示初始化矩阵或向量glm::mat4 m;&#x2F;&#x2F;旧版本会默认创建全0矩阵，新版本则不会，必须显示初始化&#x2F;&#x2F;创建一个主对角线元素全为1的4阶方阵(单位矩阵)glm::mat4 m4(1.0f);&#x2F;&#x2F;创建元素全为零的零矩阵glm::mat4 m4(0.0f);&#x2F;&#x2F;使用数值赋值形式创建矩阵glm::mat4 m &#x3D; &#123;    1.0, 1.0, 1.0, 1.0,&#x2F;&#x2F;第一列    2.0, 2.0, 2.0, 2.0,&#x2F;&#x2F;第二列    3.0, 3.0, 3.0, 3.0,&#x2F;&#x2F;第三列    4.0, 4.0, 4.0, 4.0&#x2F;&#x2F;第四列&#125;;&#x2F;&#x2F;可以用访问二维数值的形式m[i][j]对矩阵元素进行修改和访问&#x2F;&#x2F;注意，glm中m[i][j]表示第i列，第j行m[1][1] &#x3D; 10&#x2F;&#x2F;创建一个元素全为1的2维向量glm::vec2(1.0f);&#x2F;&#x2F;使用数值赋值形式创建向量glm::vec4 m &#x3D; &#123;    1.0, 2.0, 3.0, 4.0&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>向量运算</li></ol><table><thead><tr><th>函数&#x2F;操作符</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code></td><td>分量加减乘除</td><td><code>vec3 a = b + c;</code></td></tr><tr><td><code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code></td><td>分量赋值运算</td><td><code>a += b;</code></td></tr><tr><td><code>==</code>, <code>!=</code></td><td>向量相等比较</td><td><code>if (a == b) { ... }</code></td></tr><tr><td><code>glm::dot(a, b)</code></td><td>点积</td><td><code>float d = dot(a, b);</code></td></tr><tr><td><code>glm::cross(a, b)</code></td><td>叉积（仅 <code>vec3</code>）</td><td><code>vec3 c = cross(a, b);</code></td></tr><tr><td><code>glm::length(v)</code></td><td>向量长度</td><td><code>float len = length(v);</code></td></tr><tr><td><code>glm::distance(a, b)</code></td><td>两点间距离</td><td><code>float d = distance(a, b);</code></td></tr><tr><td><code>glm::normalize(v)</code></td><td>单位化向量</td><td><code>vec3 norm = normalize(v);</code></td></tr><tr><td><code>glm::reflect(I, N)</code></td><td>反射向量</td><td><code>vec3 R = reflect(I, N);</code></td></tr><tr><td><code>glm::refract(I, N, eta)</code></td><td>折射向量</td><td><code>vec3 T = refract(I, N, eta);</code></td></tr><tr><td><code>glm::abs(v)</code></td><td>各分量取绝对值</td><td><code>vec3 a = abs(v);</code></td></tr><tr><td><code>glm::floor(v)</code>, <code>glm::ceil(v)</code>, <code>glm::round(v)</code></td><td>分量取整</td><td><code>vec3 f = floor(v);</code></td></tr><tr><td><code>glm::clamp(v, min, max)</code></td><td>分量限制范围</td><td><code>vec3 c = clamp(v, 0.0f, 1.0f);</code></td></tr><tr><td><code>glm::mix(a, b, t)</code></td><td>线性插值（<code>t ∈ [0,1]</code>）</td><td><code>vec3 m = mix(a, b, 0.5f);</code></td></tr><tr><td><code>glm::max(a, b)</code>, <code>glm::min(a, b)</code></td><td>分量最大值&#x2F;最小值</td><td><code>vec3 mx = max(a, b);</code></td></tr><tr><td>3. 矩阵运算</td><td></td><td></td></tr></tbody></table><table><thead><tr><th>函数&#x2F;操作符</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>+</code>, <code>-</code>, <code>*</code></td><td>矩阵加减乘</td><td><code>mat4 A = B + C;</code></td></tr><tr><td><code>*</code> (矩阵×向量)</td><td>矩阵与向量乘法</td><td><code>vec4 v = M * vec4(pos, 1.0f);</code></td></tr><tr><td><code>glm::transpose(M)</code></td><td>转置矩阵</td><td><code>mat4 T = transpose(M);</code></td></tr><tr><td><code>glm::inverse(M)</code></td><td>逆矩阵（需可逆）</td><td><code>mat4 invM = inverse(M);</code></td></tr><tr><td><code>glm::determinant(M)</code></td><td>行列式</td><td><code>float det = determinant(M);</code></td></tr><tr><td><code>glm::outerProduct(a, b)</code></td><td>外积（生成矩阵）</td><td><code>mat3 M = outerProduct(a, b);</code></td></tr><tr><td><code>glm::identity&lt;mat4&gt;()</code></td><td>单位矩阵</td><td><code>mat4 I = identity&lt;mat4&gt;();</code></td></tr><tr><td><code>glm::diagonalMatrix(v)</code></td><td>对角矩阵</td><td><code>mat4 D = diagonalMatrix(vec4(1.0f));</code></td></tr><tr><td><code>glm::translate(M, offset)</code></td><td>平移矩阵</td><td><code>mat4 T = translate(M, vec3(1.0f, 0.0f, 0.0f));</code></td></tr><tr><td><code>glm::rotate(M, angle, axis)</code></td><td>旋转矩阵</td><td><code>mat4 R = rotate(M, radians(45.0f), vec3(0.0f, 0.0f, 1.0f));</code></td></tr><tr><td><code>glm::scale(M, factors)</code></td><td>缩放矩阵</td><td><code>mat4 S = scale(M, vec3(2.0f));</code></td></tr><tr><td><code>glm::ortho(left, right, bottom, top, near, far)</code></td><td>正交投影矩阵</td><td><code>mat4 P = ortho(-1.0f, 1.0f, -1.0f, 1.0f, 0.1f, 100.0f);</code></td></tr><tr><td><code>glm::perspective(fov, aspect, near, far)</code></td><td>透视投影矩阵</td><td><code>mat4 P = perspective(radians(60.0f), 16.0f/9.0f, 0.1f, 100.0f);</code></td></tr><tr><td><code>glm::lookAt(eye, center, up)</code></td><td>视图矩阵（摄像机）</td><td><code>mat4 V = lookAt(eye, target, vec3(0.0f, 1.0f, 0.0f));</code></td></tr><tr><td>4. 矩阵变换</td><td></td><td></td></tr></tbody></table><table><thead><tr><th>函数</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>glm::translate(M, offset)</code></td><td>创建平移矩阵</td><td><code>mat4 T = translate(M, vec3(1.0f, 0.0f, 0.0f));</code></td></tr><tr><td><code>glm::rotate(M, angle, axis)</code></td><td>创建旋转矩阵</td><td><code>mat4 R = rotate(M, radians(45.0f), vec3(0.0f, 0.0f, 1.0f));</code></td></tr><tr><td><code>glm::scale(M, factors)</code></td><td>创建缩放矩阵</td><td><code>mat4 S = scale(M, vec3(2.0f));</code></td></tr><tr><td><code>glm::ortho(left, right, bottom, top, near, far)</code></td><td>创建正交投影矩阵</td><td><code>mat4 P = ortho(-1.0f, 1.0f, -1.0f, 1.0f, 0.1f, 100.0f);</code></td></tr><tr><td><code>glm::perspective(fov, aspect, near, far)</code></td><td>创建透视投影矩阵</td><td><code>mat4 P = perspective(radians(60.0f), 16.0f/9.0f, 0.1f, 100.0f);</code></td></tr><tr><td><code>glm::lookAt(eye, center, up)</code></td><td>创建视图矩阵（摄像机）</td><td><code>mat4 V = lookAt(eye, target, vec3(0.0f, 1.0f, 0.0f));</code></td></tr></tbody></table><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;创建一个单位矩阵glm::mat4 m4(1.0f);&#x2F;&#x2F;平移向量，沿x轴平移1个单位距离，沿y轴平移2个单位距离，沿z轴平移3个单位距离glm::vec3 offset(1.0f, 2.0f, 3.0f);&#x2F;&#x2F;平移矩阵。将这个平移矩阵传到shader中和每个顶点相乘，就会实现将图形平移的效果glm::mat4 model &#x3D; glm::translate(m4, offset);&#x2F;&#x2F;旋转轴(三维图形绕这个轴旋转),绕y轴旋转glm::vec3 axis(0.0f, 1.0f, 0.0f);&#x2F;&#x2F;旋转矩阵。实现将图形绕y轴逆时针旋转45度的效果(rotate函数里接收的是弧度)glm::mat4 model &#x3D; glm::rotate(m4, glm::raidans(45.0f), axis);&#x2F;&#x2F;图形在各个坐标轴的缩放系数glm::vec3 multi(2.0);&#x2F;&#x2F;缩放矩阵。每个轴都放大两倍glm::mat4 model &#x3D; glm::scale(m4, multi);&#x2F;&#x2F;正交投影矩阵。前四个参数分别是视口的左、右、上、下坐标。第五和第六个参数则定义了近平面和远平面的距离。glm::ortho(float left, float right, float bottom, float top, float zNear, float zFar);&#x2F;&#x2F;透视投影矩阵。第一个参数为视锥上下面之间的夹角，第二个参数为视口宽高比，第三、四个参数分别为近平面和远平面的深度。glm::perspective(float fovy, float aspect, float zNear, float zFar);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li>常用</li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;将角度值转为弧度值。传入角度，输出弧度，&#x2F;&#x2F;rotate函数中需要输入弧度值float paiAngle &#x3D; glm::radians(45.0f);&#x2F;&#x2F;获取矩阵或者向量的指针，搭配glUniformMatrix4fv可以将矩阵的值传递到shader中float* val &#x3D; glm::value_ptr(m);&#x2F;&#x2F;第一个参数表示uniform变量的位置，第二个参数表示传递几个矩阵数据，第三个参数表示传入的矩阵是否需要转置，第四个参数就是获取到的矩阵的指针&#x2F;&#x2F;由于glm和glsl中矩阵都是列优先存储的，所以我们无需进行转置操作glUniformMatrix4fv(location, 1, GL_FALSE, val);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="ImGUI"><a href="#ImGUI" class="headerlink" title="ImGUI"></a>ImGUI</h1><h2 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h2><p>ImGUI（Immediate Mode GUI）是一种 <strong>即时模式</strong> 的图形用户界面设计方法，与传统的 <strong>保留模式 GUI</strong>（如 Qt、WinForms）不同。它的核心特点是：</p><ul><li><strong>无持久化状态</strong>：每一帧都重新绘制整个 UI，而不是维护控件状态。</li><li><strong>轻量级</strong>：适合嵌入式、游戏、工具开发。</li><li><strong>快速原型设计</strong>：适合调试界面、编辑器插件等。</li></ul><p>ImGUI非常适合简单场景中绘制轻量级UI空间，如果是较为复杂的场景或者大型软件，还要使用QT进行开发。</p><h2 id="配置-3"><a href="#配置-3" class="headerlink" title="配置"></a>配置</h2><p>imgui是一个开源的库，可以直接从网上下载源码，加入到自己的项目中直接引用即可。</p><p>除了需要引入根目录下这些<strong>必须的文件</strong>，还需要根据项目所使用的库引入不同的<strong>兼容性文件</strong>，这部分文件是imgui为了兼容其他第三方库而实现的。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250717171621962.png" alt="image-20250717171621962" style="zoom:60%;" /><p>一个简单的方法就是可以进入examples文件夹查看示例工程，将示例示例工程中引入的文件引入自己项目中。这里我们用的是glfw+opengl新版本，就选择对应的文件夹打开里面的项目文件。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250717172008182.png" alt="image-20250717172008182" style="zoom:60%;" /><p>然后按照示例项目里面的引入文件引入到自己的项目即可。（示例项目里面的文件都引入之后，也有可能运行报错，这时候只需要根据报错信息引入对应的文件即可）</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250717172125492.png" alt="image-20250717172125492" style="zoom:67%;" /><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p>在使用时，一共可分为三个步骤：</p><ol><li><strong>初始化</strong>imgui</li><li><strong>渲染</strong>imgui的ui</li><li><strong>退出程序前清理</strong>imgui</li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;imgui&#x2F;imgui.h&quot;#include &quot;imgui&#x2F;imgui_impl_glfw.h&quot;#include &quot;imgui&#x2F;imgui_impl_opengl3.h&quot;&#x2F;&#x2F;初始化void initIMGUI()&#123;    ImGui::CreateContext();&#x2F;&#x2F;创建imgui上下文    ImGui::StyleColorsDark();&#x2F;&#x2F;设置ui界面的主题    &#x2F;&#x2F;ImGui::StyleColorsLight();    &#x2F;&#x2F;将imgui与glfw的窗口和对应版本的opengl进行绑定    ImGui_ImplGlfw_InitForOpenGL(app.getWindow(), true);    ImGui_ImplOpenGL3_Init(&quot;#version 460&quot;);&#125;&#x2F;&#x2F;渲染void renderIMGUI()&#123;    &#x2F;&#x2F;开启一帧的渲染    ImGui_ImplOpenGL3_NewFrame();    ImGui_ImplGlfw_NewFrame();    ImGui::NewFrame();    &#x2F;&#x2F;设置控件    ImGui::Begin(&quot;hello world&quot;);    ImGui::End();    ImGui::Begin(&quot;hello c++&quot;);    ImGui::End();    &#x2F;&#x2F;执行渲染    ImGui::Render();    int display_w, display_h;    glfwGetFramebufferSize(app.getWindow(), &amp;display_w, &amp;display_h);    glViewport(0, 0, display_w, display_h);    ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());&#125;&#x2F;&#x2F;推出前清理ImGui_ImplOpenGL3_Shutdown();ImGui_ImplGlfw_Shutdown();ImGui::DestroyContext();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="各种控件"><a href="#各种控件" class="headerlink" title="各种控件"></a>各种控件</h2><h3 id="窗体区域"><a href="#窗体区域" class="headerlink" title="窗体区域"></a>窗体区域</h3><p><strong>Begin</strong>函数会在屏幕上创建一块窗体区域，里面的参数是该窗体的名称。任何在Begin和End之间的控件都会在同一个窗体区域内，并且里面的<strong>控件</strong>都会<strong>随着窗体一起移动</strong>。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ImGui::Begin(&quot;hello world&quot;);ImGui::Button(&quot;world&quot;, ImVec2(60, 40));ImGui::End();ImGui::Begin(&quot;hello c++&quot;);ImGui::Button(&quot;c++&quot;, ImVec2(40, 40));ImGui::End();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到调用了两次Begin和End函数且两个窗体<strong>名称不同</strong>，创建了两个不同的窗体，并且各自里面的组件也都在各自的窗体里。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250717172954002.png" alt="image-20250717172954002" style="zoom:60%;" /><p>imgui区分窗体的<strong>标识</strong>为<strong>创建的名称</strong>，也就是Begin函数传入的参数。如果两个窗体的<strong>名称一样</strong>，那么就会被认作是<strong>一个窗体</strong>。如下的代码所示，两段代码的运行结果是一样的，都是两个按钮一起出现在了”hello world”窗体里。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;下面两段代码运行结果一样&#x2F;&#x2F;两个窗体名称一样ImGui::Begin(&quot;hello world&quot;);ImGui::Button(&quot;world&quot;, ImVec2(60, 40));ImGui::End();ImGui::Begin(&quot;hello world&quot;);ImGui::Button(&quot;c++&quot;, ImVec2(40, 40));ImGui::End();&#x2F;&#x2F;一个单独窗体ImGui::Begin(&quot;hello world&quot;);ImGui::Button(&quot;world&quot;, ImVec2(60, 40));ImGui::Button(&quot;c++&quot;, ImVec2(40, 40));ImGui::End();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250717173401824.png" alt="image-20250717173401824" style="zoom:67%;" /><h1 id="Assimp"><a href="#Assimp" class="headerlink" title="Assimp"></a>Assimp</h1><h2 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h2><p><strong>Assimp</strong>（<strong>Open Asset Import Library</strong>）是一个开源的 <strong>3D 模型导入库</strong>，用于加载和处理多种 3D 文件格式。它广泛应用于游戏开发、计算机图形学、3D 建模工具等领域，能够解析模型数据（如网格、材质、动画等），并转换为统一的内部数据结构，方便在程序中使用。</p><p>Assimp 可以读取多种常见的 3D 模型文件格式，包括：</p><ul><li><strong>静态模型格式</strong>：OBJ, STL, PLY, FBX, DAE (Collada), 3DS, Blender (.blend)</li><li><strong>动画模型格式</strong>：FBX, DAE, GLTF&#x2F;GLB, X (DirectX)</li><li><strong>游戏引擎格式</strong>：Unreal Engine (.ase), Quake (.mdl, .md2, .md3)</li></ul><p>Assimp 解析 3D 文件后，可以提取以下数据：</p><ul><li><strong>网格（Mesh）</strong>：顶点、法线、UV 坐标、三角形面片</li><li><strong>材质（Material）</strong>：漫反射&#x2F;镜面反射&#x2F;环境光颜色、纹理路径（漫反射贴图、法线贴图等）</li><li><strong>骨骼动画（Bone Animation）</strong>：骨骼层次结构、关键帧动画</li><li><strong>场景结构（Scene Graph）</strong>：节点层次结构（如父子关系）</li></ul><p>具体使用流程如下：我们使用Assimp库导入一个3D模型文件，Assimp会解析文件数据并将其转换为Assimp规定的数据结构，我们拿到Assimp的数据结构后要根据自己的需求转换为自己可以使用的数据结构。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250717221457130.png" alt="image-20250717221457130" style="zoom:50%;" /><h2 id="Assimp数据结构"><a href="#Assimp数据结构" class="headerlink" title="Assimp数据结构"></a>Assimp数据结构</h2><p>当使用Assimp导入一个模型的时候，它通常会将整个模型加载进一个<strong>场景</strong>(Scene)对象，它会包含导入的模型&#x2F;场景中的所有数据。Assimp会将场景载入为一系列的节点(Node)，每个节点包含了场景对象中所储存数据的索引，每个节点都可以有任意数量的子节点。Assimp数据结构的（简化）模型如下：</p><img src="https://learnopengl-cn.github.io/img/03/01/assimp_structure.png" alt="img" style="zoom: 80%;" /><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250717222711536.png" alt="image-20250717222711536" style="zoom:50%;" /><ul><li><p>aiScene中包含了该模型文件中的所有物体。</p></li><li><p>aiScene.mMeshes数组包含了该场景中所有mesh的信息。</p></li><li><p>aiMesh是存放mesh信息的，包含顶点信息(mVertices)、法线信息(mNormals)、uv坐标(mTextureCoords)、顶点索引(mFaces)、材质索引(mMaterialIndex)。其中材质可以根据材质索引去aiScene.mMaterials中获得指定的material。</p></li><li><p>aiMesh.aiFace表示Mesh中一个三角形面元，aiFace.mIndices存放的是该三角形的顶点索引。</p></li><li><p>aiScene.mMaterials数组包含了场景中所有material的信息。</p></li><li><p>RootNode是场景的根节点，可以把每个Node当做一个空的Object（空Object当中父物体挂载其他mesh）。Node.mMeshes数组表示挂载在当前Node的物体的mesh，里面存放的是索引值，可以使用这个索引值去aiScene.mMeshes数组中获得指定的mesh；Node.mChildren表示挂载在当前Node的子Node。</p></li></ul><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250717223840702.png" alt="image-20250717223840702" style="zoom:50%;" /><h2 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;assimp&#x2F;Importer.hpp&gt;#include &lt;assimp&#x2F;scene.h&gt;#include &lt;assimp&#x2F;postprocess.h&gt;&#x2F;&#x2F;1.读取模型必须要使用Assimp提供的导入器importerAssimp::Importer importer;&#x2F;&#x2F;2.调用导入器的ReadFile函数即可获取到Assimp读取模型文件的aiSceneconst aiScene* scene &#x3D; importer.ReadFile(path, aiProcess_GenNormals | aiProcess_Triangulate);&#x2F;&#x2F;3.检查是否读取成功if (!scene || scene-&gt;mFlags &amp; AI_SCENE_FLAGS_INCOMPLETE || !scene-&gt;mRootNode)&#123;    cout &lt;&lt; &quot;ERROR::ASSIMP::&quot; &lt;&lt; import.GetErrorString() &lt;&lt; endl;    return;&#125;&#x2F;&#x2F;4.如果正确读取模型文件，则可以用拿到的aiScene获取里面的数据&#x2F;&#x2F;...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em><em>importer.ReadFile(const char</em> path,  unsigned int flags)</em>*</p><p>第一个参数<strong>path</strong>，是模型的读取路径；</p><p>第二个参数<strong>flags</strong>，是读取模型的一些设置。<strong>aiProcess_Triangulate</strong>设置如果模型不是（全部）由三角形组成，它需要将模型所有的图元形状变换为三角形；<strong>aiProcess_GenNormals</strong>设置如果模型不包含法向量的话，就为每个顶点创建法线。</p><h1 id="OpenGL初级"><a href="#OpenGL初级" class="headerlink" title="OpenGL初级"></a>OpenGL初级</h1><h2 id="初始程序"><a href="#初始程序" class="headerlink" title="初始程序"></a>初始程序</h2><p>使用glfw创建窗口并使用glad加载函数成功后，我们先使用OpenGL API编写一个最基础程序。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;glad&#x2F;glad.h&gt;#include &lt;GLFW&#x2F;glfw3.h&gt;void init()&#123;    &#x2F;&#x2F;初始化glfwInit();&#x2F;&#x2F;配置glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);    &#x2F;&#x2F;创建窗体对象    GLFWwindow* window &#x3D; glfwCreateWindow(800, 600, &quot;OpenGLStudy&quot;, NULL, NULL);    &#x2F;&#x2F;设置OpenGL绘制的窗口    glfwMakeContextCurrent(window);    &#x2F;&#x2F;加载当前所有版本的opengl的函数实现    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))    &#123;        std::cout &lt;&lt; &quot;加载函数失败&quot; &lt;&lt; std::endl;        return -1;    &#125;&#125;int main()&#123;    &#x2F;&#x2F;初始化操作init();    &#x2F;&#x2F;设置视口大小    glViewport(0, 0, 800, 600);    &#x2F;&#x2F;设置画布清理颜色(背景颜色)    glClearColor(0.5f, 0.5f, 0.5f, 1.0f);    &#x2F;&#x2F;执行循环，窗口关闭时退出循环    while (!glfwWindowShouldClose(window))    &#123;        &#x2F;&#x2F;处理事件队列        glfwPollEvents();        &#x2F;&#x2F;每一帧清理上一帧画布的内容        glClear(GL_COLOR_BUFFER_BIT);        &#x2F;&#x2F;绘制其他内容(渲染内容)        &#x2F;&#x2F;...        &#x2F;&#x2F;切换双缓存        glfwSwapBuffers(window);    &#125;    &#x2F;&#x2F;退出程序前的清理工作    glfwTerminate();    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="OpenGL函数错误处理"><a href="#OpenGL函数错误处理" class="headerlink" title="OpenGL函数错误处理"></a>OpenGL函数错误处理</h2><p>OpenGL是一个相对稳定的状态机，不会因为我们给函数传入错误的参数而随便崩溃，这也就导致了我们在开发中更难观察到代码中的错误。</p><p>以下面的代码为例：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;glad&#x2F;glad.h&gt;#include &lt;GLFW&#x2F;glfw3.h&gt;int main()&#123;    &#x2F;&#x2F;假设所有初始化操作都在这个函数里    init();    &#x2F;&#x2F;设置视口大小    glViewport(0, 0, 800, 600);    &#x2F;&#x2F;设置画布清理颜色(背景颜色)    glClearColor(0.5f, 0.5f, 0.5f, 1.0f);    &#x2F;&#x2F;执行循环，窗口关闭时退出循环    while (!glfwWindowShouldClose(window))    &#123;        &#x2F;&#x2F;处理事件        glfwPollEvents();        &#x2F;&#x2F;每一帧清理上一帧画布的内容        &#x2F;&#x2F;正确写法是 glClear(GL_COLOR_BUFFER_BIT);        glClear(-1);        &#x2F;&#x2F;绘制其他内容                &#x2F;&#x2F;切换双缓存        glfwSwapBuffers(window);    &#125;    &#x2F;&#x2F;退出程序前的清理工作    glfwTerminate();    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250415191049509.png" alt="image-20250415191049509" style="zoom: 50%;" /><p>可以看到代码中的glCLear(-1)明显传入了一个错误的参数，但是我们的程序还是能正常运行，没有什么报错信息。而且前面设置的清除颜色是灰色的，运行时确实黑色。对于一个大型项目来说，出现这样一个错误是非常难维护的，所有我们在开发时就必须处理好程序的报错问题。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;glGetError()可以获得离自己最近的一个报错情况的错误代码&#x2F;&#x2F;GLenum是glad定义的枚举类型，本质就是intGLenum errCode &#x3D; glGetError();&#x2F;&#x2F;1glClear(-1);&#x2F;&#x2F;2glClear(GL_COLOR_BUFFER_BIT);&#x2F;&#x2F;3glClear(-1);&#x2F;&#x2F;因为只会获得距离自己最近的错误情况，所以会得到第3句的错误代码GLenum errCode &#x3D; glGetError();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250415194926089.png" alt="image-20250415194926089" style="zoom: 80%;" /><p>如上图所示，每一个错误代码都有一个与之对应的宏，获得错误代码后可以比较这些宏从而找到错误原因。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250415200448883.png" alt="image-20250415200448883" style="zoom:67%;" /><p>如上图所示，在项目中新建一个wrapper文件夹，用来存放我们自己写的包装好的工具，创建一个CMakeLists.txt文件，配置方法和CMake的多文件夹编译一节一样。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;------------------------------------------------------checkError.h文件#pragma once&#x2F;&#x2F;该宏只在DEBUG模式下起检查错误的作用#ifdef DEBUG&#x2F;&#x2F;定义GL_CALL宏，简化代码操作#define GL_CALL(func) func;checkError();#else#define GL_CALL(func) func;#endifvoid checkError();&#x2F;&#x2F;------------------------------------------------------checkError.cpp文件#include &quot;checkError.h&quot;#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;assert.h&gt;#include &lt;glad&#x2F;glad.h&gt;void checkError()&#123;GLenum errCode &#x3D; glGetError();std::string errStr &#x3D; &quot;&quot;;if (errCode)&#123;switch (errCode)&#123;case GL_INVALID_ENUM:errStr &#x3D; &quot;INVALID_ENUM&quot;; break;case GL_INVALID_VALUE:errStr &#x3D; &quot;INVALID_VALUE&quot;; break;case GL_INVALID_OPERATION:errStr &#x3D; &quot;INVALID_OPERATION&quot;; break;case GL_OUT_OF_MEMORY:errStr &#x3D; &quot;OUT_OF_MEMORY&quot;; break;default:errStr &#x3D; &quot;UNKNOWN_ERROR&quot;; break;&#125;&#x2F;&#x2F;出现错误就输出错误原因并终止运行std::cout &lt;&lt; errStr &lt;&lt; std::endl;assert(false);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于每次调用checkError()函数都会消耗计算资源，每一行代码都调用一次会大大影响性能，所以使用条件编译的方式只在开发中使用（CMake中使用add_definitions(-DDEBUG)指令定义该宏表面开发模式）。我们的宏和检错函数定义好之后，在其他源文件引入之后，可以直接使用。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;每一条语句被GL_CALL包裹后会先只执行里面的语句，随后就执行我们的checkError函数，可以随时检查出错误所在GL_CALL(glClear(GL_COLOR_BUFFER_BIT));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="NDC-Normalized-Device-Coordinates"><a href="#NDC-Normalized-Device-Coordinates" class="headerlink" title="NDC(Normalized Device Coordinates)"></a>NDC(Normalized Device Coordinates)</h2><p>把屏幕坐标划分为[-1,1]的范围，0表示中点位置，-1是左边界或下边界，1是右边界或上边界。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240204164555512.png" alt="image-20240204164555512" style="zoom: 50%;" /><p>使用这种坐标的好出是在屏幕中显示的图像会随着屏幕的大小进行相应比例的缩放，最终我们在OpenGL中给出的坐标也都是NDC中的坐标。</p><h2 id="VBO-Vertex-Buffer-Objects"><a href="#VBO-Vertex-Buffer-Objects" class="headerlink" title="VBO(Vertex Buffer Objects)"></a>VBO(Vertex Buffer Objects)</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240204165607889.png" alt="image-20240204165607889" style="zoom:67%;" /><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240204165839066.png" alt="image-20240204165839066" style="zoom:67%;" /><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">   &#x2F;&#x2F;在此过程中并未开辟显存&#x2F;&#x2F;创建1个VBO   GLuint n &#x3D; 1;   GLuint vbo1&#x3D;0;&#x2F;&#x2F;创建1个vbo时(传入这个变量的地址)   glGenBuffers(n, &amp;vbo1);   &#x2F;&#x2F;删除1个VBO   glDeleteBuffers(n, &amp;vbo1);   &#x2F;&#x2F;创建多个VBO   n &#x3D; 3;   GLuint vbo2[] &#x3D; &#123;0,0,0&#125;;   glGenBuffers(n, vbo2);   &#x2F;&#x2F;删除多个VBO   glDeleteBuffers(n, vbo2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="绑定和数据填入"><a href="#绑定和数据填入" class="headerlink" title="绑定和数据填入"></a>绑定和数据填入</h3><p>使用glGenBuffers函数创建vbo时并不会开辟显存空间，<strong>填入数据</strong>时会真正的<strong>开辟显存空间</strong>。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250417172543086.png" alt="image-20250417172543086" style="zoom:33%;" /><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240204173148411.png" alt="image-20240204173148411" style="zoom: 50%;" /><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;准备数据float vertices[] &#x3D; &#123;    0.5f,0.3f,0,    -0.5f,-0.3f,0,    0.1f,0.1f,0,&#125;;&#x2F;&#x2F;创建VBOGLuint vbo;glGenBuffers(1, &amp;vbo);&#x2F;&#x2F;将创建的vbo绑定到OpenGL状态机的当前vbo插槽位置&#x2F;&#x2F;GL_ARRAY_BUFFER:表示OpenGL中当前vbo的插槽glBindBuffer(GL_ARRAY_BUFFER, vbo);&#x2F;&#x2F;传输数据(第二个参数是指传入数据的字节大小)，将数据填入到当前绑定的vbo中glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);glDeleteBuffers(1, &amp;vbo);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="存储多属性数据"><a href="#存储多属性数据" class="headerlink" title="存储多属性数据"></a>存储多属性数据</h3><p>对于一个三角形来说，其包含的数据不止有三个顶点的坐标信息，还有类似颜色、深度等的其他信息，也就是说明一个点是多属性数据，下面介绍两种vbo中存储多属性的策略。</p><h4 id="single-buffer"><a href="#single-buffer" class="headerlink" title="single buffer"></a>single buffer</h4><p>该策略是为每一个属性分配一个vbo对象存储，即创建多个vbo对象，每个vbo对象只负责记录所有点的某一个属性的信息。如下图所示，我们可以创建两个vbo对象，分别存储点的坐标信息和颜色信息。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240204174550438.png" alt="image-20240204174550438" style="zoom: 50%;" /><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void prepaerSingleBuffer() &#123;    float pos[] &#x3D; &#123;    0.5f,0.3f,0,    -0.5f,-0.3f,0,    0.1f,0.1f,0,    &#125;;    float colors[] &#x3D; &#123;    1.0f,1.0f,1.0f,    1.0f,1.0f,1.0f,    1.0f,1.0f,1.0f,    &#125;;    &#x2F;&#x2F;创建两个vbo，分别存储顶点的坐标信息和顶点的颜色信息    GLuint posVbo &#x3D; 0, colorVbo &#x3D; 0;    &#x2F;&#x2F;创建    glGenBuffers(1, &amp;posVbo);    &#x2F;&#x2F;绑定    glBindBuffer(GL_ARRAY_BUFFER, posVbo);    &#x2F;&#x2F;传输数据    glBufferData(GL_ARRAY_BUFFER, sizeof(pos), pos, GL_STATIC_DRAW);    &#x2F;&#x2F;创建    glGenBuffers(1, &amp;colorVbo);    &#x2F;&#x2F;绑定    glBindBuffer(GL_ARRAY_BUFFER, colorVbo);    &#x2F;&#x2F;传输数据    glBufferData(GL_ARRAY_BUFFER, sizeof(colors), colors, GL_STATIC_DRAW);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="interleaved-buffer"><a href="#interleaved-buffer" class="headerlink" title="interleaved buffer"></a>interleaved buffer</h4><p>该策略是将所有的信息放到一个数组里，只创建一个vbo对象存储。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240204192206098.png" alt="image-20240204192206098" style="zoom:67%;" /><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void prepaerInterleavedBuffer() &#123;    float vertices[] &#x3D; &#123;        0.5f,0.3f,0,1.0f,1.0f,1.0f,        -0.5f,0.2f,0,1.0f,1.0f,1.0f,        -0.3f,0.2f,0,1.0f,1.0f,1.0f,    &#125;;    GLuint vbo &#x3D; 0;    glGenBuffers(1, &amp;vbo);    glBindBuffer(GL_ARRAY_BUFFER, vbo);    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="VAO-Vertex-Array-Object"><a href="#VAO-Vertex-Array-Object" class="headerlink" title="VAO(Vertex Array Object)"></a>VAO(Vertex Array Object)</h2><p>VAO（Vertex Array Object）：顶点数组对象，用于存储一个Mesh网格所有的<strong>顶点属性描述信息</strong>。</p><p>我们可以通过把信息存储在VBO中，然后VBO再传送到显存中，显卡得到了这些数据后只是一堆数据，并不知道如何操作。而VAO就是用来<strong>描述</strong>VBO中数据的存放的，比如数据的类型，几个数据为一组之类的信息，让显卡可以根据我们的定义存取数据。</p><p>在OpenGL程序中，<strong>VBO</strong>可能会有多个，但<strong>VAO</strong>只有一个。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">   &#x2F;&#x2F;左边三列是坐标信息，右边三列是颜色信息float vertices[] &#x3D; &#123;        0.5f,0.3f,0,   1.0f,1.0f,1.0f,       -0.5f,0.2f,0,   1.0f,1.0f,1.0f,       -0.3f,0.2f,0,   1.0f,1.0f,1.0f   &#125;;&#x2F;&#x2F;显卡接收到的数据就是一堆展开的数字，需要使用VAO描述这些数据&#x2F;&#x2F;几个数字为一组，数据是什么类型，存储在几号VBO中等等0.5f,0.3f,0,1.0f,1.0f,1.0f,  -0.5f,0.2f,0,1.0f,1.0f,1.0f,   -0.3f,0.2f,0,1.0f,1.0f,1.0f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240204194640180.png" alt="image-20240204194640180" style="zoom:67%;" /><p>下面就具体说明如何使用代码绑定VAO。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240204194816949.png" alt="image-20240204194816949" style="zoom: 50%;" /><p>当前OpenGL中绑定的是哪一个VBO，调用这个函数设置的VAO就是对哪一个VBO的信息的描述。要想设置特定的VBO的信息描述前，一定要记得先绑定对应的VBO。</p><p>对于<strong>stride</strong>属性，是说明一个顶点的所有属性数据有多长。例如vbo中存储了3个顶点的坐标信息(float类型)，那么stride&#x3D;3* sizeof(float)&#x3D;<strong>12字节</strong>；vbo中存储了3个顶点的坐标信息和颜色信息(float类型)，那么stride&#x3D;6*sizeof(float)&#x3D;<strong>24字节</strong>。</p><p>对于<strong>pointer</strong>属性，是说明该属性数据在顶点所有属性数据内的偏移量。例如vbo中存储了3个顶点的坐标信息和颜色信息(float类型)，对于坐标信息，偏移量为0；但是对于颜色信息，由于每个顶点的数据中，颜色信息在坐标信息之后，所以会有一个偏移量，即pointer &#x3D; 3*sizeof(float) &#x3D; 12字节的便宜。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240204195042028.png" alt="image-20240204195042028" style="zoom:50%;" /><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void prepaerVAO() &#123;    &#x2F;&#x2F;准备数据    &#x2F;&#x2F;对应这样的数据假设每一个顶点有6个数据，分别是坐标信息和颜色信息，所以stride的值为6*sizeof(float)&#x3D;24字节    float vertices[] &#x3D; &#123;    0.5f,0.3f,0,1.0f,1.0f,1.0f,    -0.5f,0.2f,0,1.0f,1.0f,1.0f,    -0.3f,0.2f,0,1.0f,1.0f,1.0f,    &#125;;    &#x2F;&#x2F;创建一个VBO并绑定    GLuint vbo &#x3D; 0;    glGenBuffers(1, &amp;vbo);    glBindBuffer(GL_ARRAY_BUFFER, vbo);    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);    &#x2F;&#x2F;创建一个VAO    GLuint vao &#x3D; 0;    glGenVertexArrays(1, &amp;vao);    &#x2F;&#x2F;绑定VAO    glBindVertexArray(vao);    &#x2F;&#x2F;设置VAO中的坐标属性    glEnableVertexAttribArray(0);&#x2F;&#x2F;选择要设置在VAO中哪个位置，每个属性放在VAO中的不同位置    &#x2F;&#x2F;            VAO中的位置，该属性数据个数，数据类型，是否归一化，步长，偏移量    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * (sizeof(float)), (void*)0);    &#x2F;&#x2F;设置VAO中的颜色属性,为了能正确找到颜色数据，需要设置偏移量    glEnableVertexAttribArray(1);    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3 * sizeof(float)));    &#x2F;&#x2F;解绑VAO    glBindVertexArray(0);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面是具体的练习题：</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240204203237223.png" alt="image-20240204203237223" style="zoom:67%;" /><h2 id="EBO-Element-Buffer-Object"><a href="#EBO-Element-Buffer-Object" class="headerlink" title="EBO(Element Buffer Object)"></a>EBO(Element Buffer Object)</h2><p>之前我们用VBO存储数据进行绘制多个点时，如果有两个三角形共用了一个或两个点，我们只能按顺序写6个点才能绘制成功，我们可以发现VBO的方式这些点<strong>不能复用</strong>，这就造成了<strong>空间的浪费</strong>。我们可以把用到的点的信息还是都放在VBO中，但是通过索引值获取到要绘制的点，在点的数量很多的情况下可以大大的减少空间的浪费，于是便有了EBO。</p><p><strong>EBO：用于存储顶点绘制顺序索引号的GPU显存区域。</strong></p><p>我们通过将EBO与VAO绑定，在绘制点的时候根据EBO中的索引序号再向VBO中获取到点。EBO的创建与VBO的也类似，只是模式参数不同。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250511210537587.png" alt="image-20250511210537587" style="zoom: 67%;" /><pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl">   <span class="token comment">//创建VBO</span>   GLuint vbo<span class="token punctuation">;</span>   <span class="token function">glGenBuffers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>vbo<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> vbo<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">glBufferData</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>vertices<span class="token punctuation">)</span><span class="token punctuation">,</span> vertices<span class="token punctuation">,</span> GL_STATIC_DRAW<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//创建EBO</span>   GLuint ebo<span class="token punctuation">;</span>   <span class="token function">glGenBuffers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ebo<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ELEMENT_ARRAY_BUFFER<span class="token punctuation">,</span> ebo<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//只有第一个参数与VBO创建时不同</span>   <span class="token function">glBufferData</span><span class="token punctuation">(</span>GL_ELEMENT_ARRAY_BUFFER<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>idxs<span class="token punctuation">)</span><span class="token punctuation">,</span> idxs<span class="token punctuation">,</span> GL_STATIC_DRAW<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//只有第一个参数与VBO创建时不同</span>   <span class="token comment">//使用EBO实现绘制</span>   <span class="token comment">//选择绘制程序</span>   <span class="token function">glUseProgram</span><span class="token punctuation">(</span>program<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//绑定vao</span>   <span class="token function">glBindVertexArray</span><span class="token punctuation">(</span>vao<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//使用ebo时用这个方法绘制，参数依次：绘制图形，绘制图形的点数，索引数据类型，偏移量（一般写0）</span>   <span class="token function">glDrawElements</span><span class="token punctuation">(</span>GL_TRIANGLES<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> GL_UNSIGNED_INT<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面就是完整的使用EBO进行绘制的代码</p><p>使用EBO参与绘制后，绘制命令就不能再使用<strong>glDrawArrays</strong>了，要使用<strong>glDrawElements</strong>才可以。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250511211731635.png" alt="image-20250511211731635" style="zoom: 50%;" /><pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token comment">//声明全局变量</span>GLuint vao<span class="token punctuation">,</span> program<span class="token punctuation">;</span><span class="token comment">//准备工作</span><span class="token keyword">void</span> <span class="token function">prepaerEBO</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">float</span> vertices<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>        <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span><span class="token number">0.0f</span><span class="token punctuation">,</span>         <span class="token number">0.5f</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span><span class="token number">0.0f</span><span class="token punctuation">,</span>         <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.5f</span><span class="token punctuation">,</span><span class="token number">0.0f</span><span class="token punctuation">,</span>         <span class="token number">1.0f</span><span class="token punctuation">,</span><span class="token number">1.0f</span><span class="token punctuation">,</span><span class="token number">0.0f</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> idxs<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>        <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span>        <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">//创建VBO</span>    GLuint vbo<span class="token punctuation">;</span>    <span class="token function">glGenBuffers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>vbo<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> vbo<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glBufferData</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>vertices<span class="token punctuation">)</span><span class="token punctuation">,</span> vertices<span class="token punctuation">,</span> GL_STATIC_DRAW<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//创建EBO</span>    GLuint ebo<span class="token punctuation">;</span>    <span class="token function">glGenBuffers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ebo<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ELEMENT_ARRAY_BUFFER<span class="token punctuation">,</span> ebo<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glBufferData</span><span class="token punctuation">(</span>GL_ELEMENT_ARRAY_BUFFER<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>idxs<span class="token punctuation">)</span><span class="token punctuation">,</span> idxs<span class="token punctuation">,</span> GL_STATIC_DRAW<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//创建VAO</span>    <span class="token function">glGenVertexArrays</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>vao<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glBindVertexArray</span><span class="token punctuation">(</span>vao<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//绑定属性信息</span>    <span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> vbo<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glEnableVertexAttribArray</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glVertexAttribPointer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">,</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//绑定ebo到vao中(先绑定vao后再执行绑定ebo的代码即可完成绑定)</span>    <span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ELEMENT_ARRAY_BUFFER<span class="token punctuation">,</span> ebo<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//解绑vao</span>    <span class="token function">glBindVertexArray</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token comment">//-------------------------------------------渲染操作----------------------------------</span><span class="token keyword">void</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//清理画布</span>    <span class="token function">glClear</span><span class="token punctuation">(</span>GL_COLOR_BUFFER_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//绘制</span>    <span class="token comment">//选择绘制程序</span>    <span class="token function">glUseProgram</span><span class="token punctuation">(</span>program<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//绑定vao</span>    <span class="token function">glBindVertexArray</span><span class="token punctuation">(</span>vao<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//使用ebo时用这个方法绘制，参数依次：绘制图形，绘制索引数组中几个点，索引的数据类型，偏移量（一般写0）</span>    <span class="token function">glDrawElements</span><span class="token punctuation">(</span>GL_TRIANGLES<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> GL_UNSIGNED_INT<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//解除绑定</span>    <span class="token function">glBindVertexArray</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="shader-着色器程序-入门"><a href="#shader-着色器程序-入门" class="headerlink" title="shader(着色器程序)入门"></a>shader(着色器程序)入门</h2><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240205161612785.png" alt="image-20240205161612785" style="zoom:67%;" /><h3 id="GLSL-Graphic-Library-Shader-Language"><a href="#GLSL-Graphic-Library-Shader-Language" class="headerlink" title="GLSL(Graphic Library Shader Language)"></a>GLSL(Graphic Library Shader Language)</h3><p>着色器的编写要使用专门的语言来完成，这里使用的是GLSL，这是一种类C语言写成的，包含一些对向量和矩阵的操作的有用的特性。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240205161939253.png" alt="image-20240205161939253" style="zoom:67%;" /><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250704180609917.png" alt="image-20250704180609917" style="zoom: 50%;" /><h4 id="简单数据类型"><a href="#简单数据类型" class="headerlink" title="简单数据类型"></a>简单数据类型</h4><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240206145951400.png" alt="image-20240206145951400" style="zoom: 50%;" /><p>在三维向量中，前三个数字可用xyz或者rgb分别表示。</p><p>在四维向量中，前四个数字可用xyzw或者rgba分别表示。</p><pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token keyword">vec3</span> color<span class="token operator">=</span><span class="token keyword">vec3</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">,</span><span class="token number">1.0</span><span class="token punctuation">,</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//每一个分量可以单独拿出来</span>color<span class="token punctuation">.</span>x <span class="token operator">==</span> color<span class="token punctuation">.</span>r<span class="token punctuation">;</span>color<span class="token punctuation">.</span>y <span class="token operator">==</span> color<span class="token punctuation">.</span>g<span class="token punctuation">;</span>color<span class="token punctuation">.</span>z <span class="token operator">==</span> color<span class="token punctuation">.</span>b<span class="token punctuation">;</span><span class="token comment">//也可以直接取多个指定分量</span><span class="token keyword">vec3</span> temp1<span class="token operator">=</span>color<span class="token punctuation">.</span>xxx<span class="token punctuation">;</span><span class="token keyword">vec3</span> temp2<span class="token operator">=</span>color<span class="token punctuation">.</span>xyz<span class="token punctuation">;</span><span class="token keyword">vec3</span> temp3<span class="token operator">=</span>temp1<span class="token punctuation">.</span>xxx <span class="token operator">+</span> temp2<span class="token punctuation">.</span>yyy<span class="token punctuation">;</span><span class="token comment">//可以用这种方式直接计算再赋值</span><span class="token comment">//四维向量操作方法同上</span><span class="token comment">//也可以只取一部分分量，对应变量的个数会被取出来，可用于初始化向量</span><span class="token keyword">vec4</span> v1<span class="token operator">=</span><span class="token keyword">vec4</span><span class="token punctuation">(</span>temp1<span class="token punctuation">,</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">vec4</span> v2<span class="token operator">=</span><span class="token keyword">vec4</span><span class="token punctuation">(</span>temp1<span class="token punctuation">.</span>xyz<span class="token punctuation">,</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">vec4</span> v3<span class="token operator">=</span><span class="token keyword">vec4</span><span class="token punctuation">(</span>temp1<span class="token punctuation">.</span>xy<span class="token punctuation">,</span><span class="token number">1.0</span><span class="token punctuation">,</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Uniform"><a href="#Uniform" class="headerlink" title="Uniform"></a>Uniform</h4><p>Uniform变量可以被当前Shader运行的所有运算单元<strong>共享</strong>的变量，Uniform变量是<strong>全局</strong>的，因此每一个变量必须<strong>唯一</strong>。Uniform变量可以被着色器程序的任意着色器在任意阶段访问，无论把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。</p><p>由于uniform是全局变量，我们可以在任何着色器中定义它们，定义后可以在任何着色器中使用它们。</p><p>下面的代码就是利用<strong>Uniform</strong>根据时间用正弦函数设置三角形的颜色周期性变化。</p><pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token comment">//在vs中定义一个uniform变量表示颜色,并将该值交给color变量输出到fs中</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">460</span> core</span></span><span class="token keyword">layout</span><span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token keyword">vec3</span> aPosition<span class="token punctuation">;</span><span class="token keyword">layout</span><span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token keyword">vec3</span> aColor<span class="token punctuation">;</span><span class="token comment">//最终输出的颜色向量</span><span class="token keyword">out</span> <span class="token keyword">vec3</span> color<span class="token punctuation">;</span><span class="token comment">//外部通过代码设置uniform变量的值</span><span class="token keyword">uniform</span> <span class="token keyword">vec3</span> uColor<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>gl_Position <span class="token operator">=</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span>aPosition<span class="token punctuation">.</span>x<span class="token punctuation">,</span> aPosition<span class="token punctuation">.</span>y<span class="token punctuation">,</span> aPosition<span class="token punctuation">.</span>z<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>color<span class="token operator">=</span>uColor<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">//在fs中获取到颜色并输出颜色</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">460</span> </span></span><span class="token keyword">out</span> <span class="token keyword">vec4</span> fColor<span class="token punctuation">;</span><span class="token keyword">in</span> <span class="token keyword">vec3</span> color<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>fColor <span class="token operator">=</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span>color<span class="token punctuation">,</span><span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先要使用<strong>glGetUniformLocation(program, name)<strong>方法获取着色器程序中指定名称的Uniform变量的位置（是一个无符号整型，可以理解为每个Uniform变量的唯一id值）。获取到的变量位置</strong>location</strong>的取值范围为<strong>0</strong>到<strong>GL_MAX_UNIFORM_LOCATIONS - 1</strong>。</p><p>然后再使用glUniform3f(location, x, y, z)设置对应Uniform变量的值。其中函数名最后两个字符中的<strong>3表示3维向量</strong>、<strong>f表示float类型的数据</strong>，类似的glUniform4i就表示设置4维int类型的Uniform变量的数值，第一个参数表示Uniform变量的位置编号，后面的数据就是按照顺序设置该变量的分量值。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;在Shader类中新增函数修改uniform变量的值void Shader::setUniform3Float(const char* name, float x, float y, float z) &#123;    &#x2F;&#x2F;在当前program中查找名字为name的uniform变量的位置    GLint vertexColorLocation &#x3D; glGetUniformLocation(mProgram, name);    &#x2F;&#x2F;调用方法修改对应位置的uniform变量的值    glUniform3f(vertexColorLocation, x, y, z);&#125;&#x2F;&#x2F;------------------------------------------&#x2F;&#x2F;在渲染的循环了调用GLfloat timeValue &#x3D; glfwGetTime();&#x2F;&#x2F;获取时间GLfloat greenValue &#x3D; (sin(timeValue)+1)&#x2F;2;&#x2F;&#x2F;根据实际的正弦值计算颜色shader-&gt;setUniform3Float(&quot;uColor&quot;, 0.0f, greenValue, 0.0f);&#x2F;&#x2F;设置uniform变量的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到三角形的颜色会随时间进行周期性的变化。</p><p>​                        <img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240206161838490.png" alt="image-20240206161838490" style="zoom:50%;" /><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240206161857442.png" alt="image-20240206161857442" style="zoom:50%;" /></p><h3 id="Vertex-Shader"><a href="#Vertex-Shader" class="headerlink" title="Vertex Shader"></a>Vertex Shader</h3><p>顶点着色器(Vertex Shader)是几个可编程着色器中的一个。如果我们打算做渲染的话，现代OpenGL需要我们至少设置一个顶点和一个片段着色器。着色器的编写需要用到上面的GLSL来实现，下面是一个简单的实现。顶点着色器是将三维世界的左边转化成NDC坐标的，这里我们默认输入的数据就是NDC坐标，所以不用做任何处理，就实现了一个最简单的顶点着色器。</p><pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token comment">//opengl版本为4.6核心模式</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">460</span> core</span></span><span class="token comment">//layout(location=0)表明的是想接收的属性数据的描述信息所在VAO中的位置 在VAO中对应0号位置</span><span class="token comment">//in表示该数据是接收外部的输入数据(就是我们代码中vbo中指向的那些数据)</span><span class="token keyword">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token keyword">vec3</span> position<span class="token punctuation">;</span><span class="token comment">//如果我们的vbo中还存储了颜色属性，该属性描述信息绑定在了VAO的1号位置，就要写location = 1</span><span class="token keyword">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token keyword">vec3</span> color<span class="token punctuation">;</span><span class="token comment">//out表示该shader向后输出的变量</span><span class="token keyword">out</span> <span class="token keyword">vec3</span> mColor<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//gl_Position是GLSL内置变量，是每个顶点的最终位置(变量名只能是这个)，我们可以将各个点处理后再赋值给这个变量，该变量向后续阶段传递坐标信息，以此可以实现图形的变换操作</span>    <span class="token comment">//gl_Position的坐标为NDC坐标，因为我们代码中使用的就是NDC坐标，所以可以直接赋值</span>    gl_Position <span class="token operator">=</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span>position<span class="token punctuation">.</span>x<span class="token punctuation">,</span> position<span class="token punctuation">.</span>y<span class="token punctuation">,</span> position<span class="token punctuation">.</span>z<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//输出变量赋值后向后传递</span>    mColor <span class="token operator">=</span> color<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Fragment-Shader"><a href="#Fragment-Shader" class="headerlink" title="Fragment Shader"></a>Fragment Shader</h3><p>片段着色器(Fragment Shader)是第二个也是最后一个我们打算创建的用于渲染三角形的着色器。片段着色器计算每个像素最后的<strong>颜色输出</strong>。</p><p>GLSL老版本中的FS有内置变量gl_FragColor表示输出，但在新版已经被废弃。</p><p><strong>gl_FragCoord</strong>是 OpenGL <strong>片段着色器（Fragment Shader）</strong> 的内置变量，只能在FragmentShader中使用。</p><p><code>gl_FragCoord</code> 是一个 <code>vec4</code> 类型的变量，表示当前片段的 <strong>窗口空间坐标</strong>，包含以下信息：</p><ul><li><strong><code>gl_FragCoord.x</code></strong>：当前片段的 x 坐标（像素位置，范围 <code>[0, viewportWidth]</code>）</li><li><strong><code>gl_FragCoord.y</code></strong>：当前片段的 y 坐标（像素位置，范围 <code>[0, viewportHeight]</code>）</li><li><strong><code>gl_FragCoord.z</code></strong>：当前片段的深度值（范围 <code>[0, 1]</code>，可用于深度测试）</li><li><strong><code>gl_FragCoord.w</code></strong>：<code>1 / gl_Position.w</code>（透视校正插值用）</li></ul><pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">460</span> core</span></span><span class="token comment">//颜色用四维向量表示，分别是r,g,b,a的值， 表示每个像素最后的颜色输出</span><span class="token comment">//out表示该shader输出的变量</span><span class="token keyword">out</span> <span class="token keyword">vec4</span> color<span class="token punctuation">;</span><span class="token comment">//接收Vertex Shader中out的输出变量mColor(变量名要和vs中out的变量名一样)</span><span class="token keyword">in</span> <span class="token keyword">vec3</span> mColor<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//vec4表示的是rgba，在shader中颜色三个通道的值范围都是[0,1]</span>    color <span class="token operator">=</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span>mColor<span class="token punctuation">.</span>x<span class="token punctuation">,</span> mColor<span class="token punctuation">.</span>y<span class="token punctuation">,</span> mColor<span class="token punctuation">.</span>z<span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250704155644324.png" alt="image-20250704155644324" style="zoom:50%;" /><h3 id="shader的编译"><a href="#shader的编译" class="headerlink" title="shader的编译"></a>shader的编译</h3><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240205164023977.png" alt="image-20240205164023977" style="zoom:67%;" /><p>因为shader的编写是使用一门语言完成的，我们需要在OpenGL中手动编译和链接。</p><pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token keyword">void</span> <span class="token function">prepaerShader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//shader源代码</span>    <span class="token keyword">const</span> char<span class="token operator">*</span> vertexShaderSource <span class="token operator">=</span>        <span class="token string">"#version 460 core\n"</span>        <span class="token string">"layout(location = 0) in vec3 position;\n"</span>        <span class="token string">"void main()\n"</span>        <span class="token string">"&#123;\n"</span>        <span class="token string">"gl_Position = vec4(position.x, position.y, position.z, 1.0);\n"</span>        <span class="token string">"&#125;\n\0"</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> char<span class="token operator">*</span> fragmentShaderSource <span class="token operator">=</span>        <span class="token string">"#version 460 core\n"</span>        <span class="token string">"out vec4 color;\n"</span>        <span class="token string">"void main()\n"</span>        <span class="token string">"&#123;\n"</span>        <span class="token string">"color = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n"</span>        <span class="token string">"&#125;\n\0"</span><span class="token punctuation">;</span>    <span class="token comment">// 1. 创建一个对应的shader，并返回对应编号</span>    GLuint vertexShader<span class="token punctuation">,</span>fragmentShader<span class="token punctuation">;</span>    vertexShader <span class="token operator">=</span> <span class="token function">glCreateShader</span><span class="token punctuation">(</span>GL_VERTEX_SHADER<span class="token punctuation">)</span><span class="token punctuation">;</span>    fragmentShader <span class="token operator">=</span><span class="token function">glCreateShader</span><span class="token punctuation">(</span>GL_FRAGMENT_SHADER<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2. 给对应的shader注入源代码</span>    <span class="token comment">//参数分别为:对应shader编号，源码字符串的个数，存储字符串的二维数组，存储每一个字符串长度的数组</span>    <span class="token function">glShaderSource</span><span class="token punctuation">(</span>vertexShader<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>vertexShaderSource<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glShaderSource</span><span class="token punctuation">(</span>fragmentShader<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>fragmentShaderSource<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 3. 编译shader</span>    <span class="token function">glCompileShader</span><span class="token punctuation">(</span>vertexShader<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//检查shader的编译是否出错</span>    GLint success<span class="token punctuation">;</span>    GLchar infoLog<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">glGetShaderiv</span><span class="token punctuation">(</span>vertexShader<span class="token punctuation">,</span> GL_COMPILE_STATUS<span class="token punctuation">,</span> <span class="token operator">&amp;</span>success<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>success<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//获取shader的错误信息</span>        <span class="token function">glGetShaderInfoLog</span><span class="token punctuation">(</span>vertexShader<span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> infoLog<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取错误信息</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"vertexShader Complie Error\n"</span> <span class="token operator">&lt;&lt;</span> infoLog <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token comment">//编译shader</span>    <span class="token function">glCompileShader</span><span class="token punctuation">(</span>fragmentShader<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//检查shader的编译是否出错</span>    <span class="token function">glGetShaderiv</span><span class="token punctuation">(</span>fragmentShader<span class="token punctuation">,</span> GL_COMPILE_STATUS<span class="token punctuation">,</span> <span class="token operator">&amp;</span>success<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>success<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//获取shader的错误信息</span>        <span class="token function">glGetShaderInfoLog</span><span class="token punctuation">(</span>fragmentShader<span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> infoLog<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取错误信息</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"fragmentShader Complie Error\n"</span> <span class="token operator">&lt;&lt;</span> infoLog <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="shader的链接"><a href="#shader的链接" class="headerlink" title="shader的链接"></a>shader的链接</h3><p>编译完成后，我们需要创建一个Program(程序)，将编译生成的中间文件链接在一起，生成一个可执行的shader程序。</p><pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token keyword">void</span> <span class="token function">prepaerShader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//shader源代码</span>    <span class="token keyword">const</span> char<span class="token operator">*</span> vertexShaderSource <span class="token operator">=</span>        <span class="token string">"#version 460 core\n"</span>        <span class="token string">"layout(location = 0) in vec3 position;\n"</span>        <span class="token string">"void main()\n"</span>        <span class="token string">"&#123;\n"</span>        <span class="token string">"gl_Position = vec4(position.x, position.y, position.z, 1.0);\n"</span>        <span class="token string">"&#125;\n\0"</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> char<span class="token operator">*</span> fragmentShaderSource <span class="token operator">=</span>        <span class="token string">"#version 460 core\n"</span>        <span class="token string">"out vec4 color;\n"</span>        <span class="token string">"void main()\n"</span>        <span class="token string">"&#123;\n"</span>        <span class="token string">"color = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n"</span>        <span class="token string">"&#125;\n\0"</span><span class="token punctuation">;</span>    GLuint vertexShader<span class="token punctuation">,</span>fragmentShader<span class="token punctuation">;</span>    <span class="token comment">//创建一个vertex shader，并返回对应编号</span>    vertexShader <span class="token operator">=</span> <span class="token function">glCreateShader</span><span class="token punctuation">(</span>GL_VERTEX_SHADER<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//创建一个fragment shader，并返回对应编号</span>    fragmentShader <span class="token operator">=</span><span class="token function">glCreateShader</span><span class="token punctuation">(</span>GL_FRAGMENT_SHADER<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//给对应的shader注入源代码</span>    <span class="token comment">//参数分别为:对应shader编号，源码字符串的个数，存储字符串的二维数组，存储每一个字符串长度的数组</span>    <span class="token function">glShaderSource</span><span class="token punctuation">(</span>vertexShader<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>vertexShaderSource<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glShaderSource</span><span class="token punctuation">(</span>fragmentShader<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>fragmentShaderSource<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//编译shader</span>    <span class="token function">glCompileShader</span><span class="token punctuation">(</span>vertexShader<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//检查shader的编译是否出错</span>    GLint success<span class="token punctuation">;</span>    GLchar infoLog<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">glGetShaderiv</span><span class="token punctuation">(</span>vertexShader<span class="token punctuation">,</span> GL_COMPILE_STATUS<span class="token punctuation">,</span> <span class="token operator">&amp;</span>success<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>success<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">glGetShaderInfoLog</span><span class="token punctuation">(</span>vertexShader<span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> infoLog<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取错误信息</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"VertexShader Complie Error\n"</span> <span class="token operator">&lt;&lt;</span> infoLog <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">glCompileShader</span><span class="token punctuation">(</span>fragmentShader<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glGetShaderiv</span><span class="token punctuation">(</span>fragmentShader<span class="token punctuation">,</span> GL_COMPILE_STATUS<span class="token punctuation">,</span> <span class="token operator">&amp;</span>success<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>success<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">glGetShaderInfoLog</span><span class="token punctuation">(</span>fragmentShader<span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> infoLog<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取错误信息</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"FragmentShader Complie Error\n"</span> <span class="token operator">&lt;&lt;</span> infoLog <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>            <span class="token comment">//-------------------------------------------链接工作----------------------------------</span>    <span class="token comment">//创建一个program</span>    GLuint program<span class="token punctuation">;</span>    program<span class="token operator">=</span><span class="token function">glCreateProgram</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//将上面编译好的结果与program相关联</span>    <span class="token function">glAttachShader</span><span class="token punctuation">(</span>program<span class="token punctuation">,</span> vertexShader<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glAttachShader</span><span class="token punctuation">(</span>program<span class="token punctuation">,</span> fragmentShader<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//开始链接</span>    <span class="token function">glLinkProgram</span><span class="token punctuation">(</span>program<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//检查是否有链接错误</span>    <span class="token function">glGetProgramiv</span><span class="token punctuation">(</span>program<span class="token punctuation">,</span> GL_LINK_STATUS<span class="token punctuation">,</span> <span class="token operator">&amp;</span>success<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>success<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">glGetProgramInfoLog</span><span class="token punctuation">(</span>program<span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> infoLog<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取错误信息</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Link Error\n"</span> <span class="token operator">&lt;&lt;</span> infoLog <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//链接完成后创建的shader就不需要了，释放资源</span>    <span class="token function">glDeleteShader</span><span class="token punctuation">(</span>vertexShader<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glDeleteShader</span><span class="token punctuation">(</span>fragmentShader<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>shader经过编译和链接后就会形成一个程序(program)，可以有多个shader，使用函数glUseProgram(int programId)就可以选择我们绘制时所使用的shander了。</p><h3 id="Shader类的封装"><a href="#Shader类的封装" class="headerlink" title="Shader类的封装"></a>Shader类的封装</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;-------------------------------------------------shader.h文件#pragma once#include &quot;core.h&quot;#include &lt;string&gt;class Shader&#123;private:GLuint mProgram&#123; 0 &#125;;GLuint mVs&#123; 0 &#125;;GLuint mFs&#123; 0 &#125;;private:void checkShaderErrors(GLuint id, const std::string&amp; type);public:Shader(const char* vsPath, const char* fsPath);~Shader();void begin();void end();public:void setUniform1f(const char* name, float x);void setUniform1i(const char* name, int x);void setUniformMatrix4(const char* name, const float* val);&#125;;&#x2F;&#x2F;-------------------------------------------------shader.cpp文件#include &quot;shader.h&quot;#include&lt;iostream&gt;#include&lt;sstream&gt;#include&lt;fstream&gt;void Shader::checkShaderErrors(GLuint id, const std::string&amp; type)&#123;int success &#x3D; 0;char infoLog[512];if (type &#x3D;&#x3D; &quot;PROGRAM&quot;)&#123;&#x2F;&#x2F;检查链接阶段是否有错误GL_CALL(glGetProgramiv(mProgram, GL_LINK_STATUS, &amp;success));if (!success)&#123;GL_CALL(glGetProgramInfoLog(mProgram, 512, NULL, infoLog));std::cout &lt;&lt; &quot;链接错误:&quot; &lt;&lt; infoLog &lt;&lt; std::endl;&#125;&#125;else if (type &#x3D;&#x3D; &quot;VS&quot;)&#123;&#x2F;&#x2F;检查编译是否出错GL_CALL(glCompileShader(id));&#x2F;&#x2F;获取报错信息GL_CALL(glGetShaderiv(id, GL_COMPILE_STATUS, &amp;success));if (!success)&#123;&#x2F;&#x2F;如果出错输出报错信息GL_CALL(glGetShaderInfoLog(id, 512, NULL, infoLog));std::cout &lt;&lt; &quot;VS编译错误:&quot; &lt;&lt; infoLog &lt;&lt; std::endl;&#125;&#125;else&#123;&#x2F;&#x2F;检查编译是否出错GL_CALL(glCompileShader(id));&#x2F;&#x2F;获取报错信息GL_CALL(glGetShaderiv(id, GL_COMPILE_STATUS, &amp;success));if (!success)&#123;&#x2F;&#x2F;如果出错输出报错信息GL_CALL(glGetShaderInfoLog(id, 512, NULL, infoLog));std::cout &lt;&lt; &quot;FS编译错误:&quot; &lt;&lt; infoLog &lt;&lt; std::endl;&#125;&#125;&#125;Shader::Shader(const char* vertexShaderPath, const char* fragmentShaderPath)&#123;&#x2F;&#x2F;存储代码的字符串std::string vertexShaderCode;std::string fragmentShaderCode;&#x2F;&#x2F;读取文件的流std::ifstream vertexShaderFileStream(vertexShaderPath);std::ifstream fragmentShaderFileStream(fragmentShaderPath);&#x2F;&#x2F;检查文件是否成功打开if (!vertexShaderFileStream.is_open() || !fragmentShaderFileStream.is_open()) &#123;std::cout &lt;&lt; &quot;Failed to open shader file: &quot; &lt;&lt; std::endl;&#125;&#x2F;&#x2F;将文件流转为字符串的中转站std::stringstream vertexShaderStringStream;vertexShaderStringStream &lt;&lt; vertexShaderFileStream.rdbuf();vertexShaderFileStream.close();std::stringstream fragmentShaderStringStream;fragmentShaderStringStream &lt;&lt; fragmentShaderFileStream.rdbuf();fragmentShaderFileStream.close();vertexShaderCode &#x3D; vertexShaderStringStream.str();fragmentShaderCode &#x3D; fragmentShaderStringStream.str();&#x2F;&#x2F;将string类型的源码转为我们需要的const char*类型const char* vertexShaderSource &#x3D; vertexShaderCode.c_str();const char* fragmentShaderSource &#x3D; fragmentShaderCode.c_str();&#x2F;&#x2F;创建shader和programmVs &#x3D; GL_CALL(glCreateShader(GL_VERTEX_SHADER));mFs &#x3D; GL_CALL(glCreateShader(GL_FRAGMENT_SHADER));mProgram &#x3D; GL_CALL(glCreateProgram());&#x2F;&#x2F;为shader注入源码GL_CALL(glShaderSource(mVs, 1, &amp;vertexShaderSource, NULL));GL_CALL(glShaderSource(mFs, 1, &amp;fragmentShaderSource, NULL));&#x2F;&#x2F;检查VS编译是否出错checkShaderErrors(mVs, &quot;VERTEX_SHADER&quot;);&#x2F;&#x2F;检查FS编译是否出错checkShaderErrors(mFs, &quot;FRAGMENT_SHADER&quot;);&#x2F;&#x2F;将shader装入progroam准备链接GL_CALL(glAttachShader(mProgram, mVs));GL_CALL(glAttachShader(mProgram, mFs));&#x2F;&#x2F;链接程序GL_CALL(glLinkProgram(mProgram));&#x2F;&#x2F;检查链接阶段是否有错误checkShaderErrors(mProgram, &quot;PROGRAM&quot;);&#x2F;&#x2F;连接成功后，创建的shader不再需要了，应删除释放资源GL_CALL(glDeleteShader(mVs));GL_CALL(glDeleteShader(mFs));&#125;Shader::~Shader()&#123;GL_CALL(glDeleteShader(mVs));GL_CALL(glDeleteShader(mFs));GL_CALL(glDeleteProgram(mProgram));&#125;void Shader::begin()&#123;GL_CALL(glUseProgram(mProgram));&#125;void Shader::end()&#123;GL_CALL(glUseProgram(0));&#125;void Shader::setUniform1f(const char* name, float x)&#123;GLint location &#x3D; GL_CALL(glGetUniformLocation(mProgram, name));GL_CALL(glUniform1f(location, x));&#125;void Shader::setUniform1i(const char* name, int x)&#123;GLint location &#x3D; GL_CALL(glGetUniformLocation(mProgram, name));GL_CALL(glUniform1i(location, x));&#125;void Shader::setUniformMatrix4(const char* name, const float* val)&#123;GLint location &#x3D; GL_CALL(glGetUniformLocation(mProgram, name));GL_CALL(glUniformMatrix4fv(location, 1, GL_FALSE, val));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="绘制简单的三角形"><a href="#绘制简单的三角形" class="headerlink" title="绘制简单的三角形"></a>绘制简单的三角形</h2><p>我们链接成功后就获得了shader程序的可执行文件，就告诉显卡我们要怎么绘制点了，下面我们就用OpenGL里的绘制命令<strong>glDrawArrays</strong>绘制一个简单的三角形。</p><p>当我们的顶点数据（VBO和VAO）和材质数据（VS和FS），都准备好之后我们需要告诉GPU开始绘制。</p><p>绘制前需要先用<strong>glUseProgram和glBindVertexArray</strong>指令指定绘制使用哪一个已经<strong>编译链接好</strong>的shader程序和哪一个VAO，然后调用<strong>glDrawArrays</strong>指令告诉GPU绘制的详细内容。</p><pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token comment">//渲染操作</span><span class="token keyword">void</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//清理画布</span>    <span class="token function">glClear</span><span class="token punctuation">(</span>GL_COLOR_BUFFER_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//绘制</span>    <span class="token comment">//选择绘制程序</span>    <span class="token function">glUseProgram</span><span class="token punctuation">(</span>program<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//绑定vao</span>    <span class="token function">glBindVertexArray</span><span class="token punctuation">(</span>vao<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//函数参数依次为：绘制模式，绘制的起始顶点，参与绘制顶点的个数</span>    <span class="token comment">//这俩我们绘制的是三角形，从0号顶点开始选择，共选择3个顶点</span>    <span class="token function">glDrawArrays</span><span class="token punctuation">(</span>GL_TRIANGLES<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//解除VAO绑定</span>    <span class="token function">glBindVertexArray</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在三角形的绘制模式中，因为一个三角形有3个点，所以当点的个数是3的倍数的时候，屏幕中会绘制出对应倍数个三角形。当点的个数<strong>不足三个</strong>时，会因为无法构成三角形而被<strong>忽略不绘制</strong>。</p><p>举个例子：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;假设有6个顶点,从0号顶点开始glDrawArrays(GL_TRIANGLES, 0, 6);&#x2F;&#x2F;最终会绘制出两个三角形&#x2F;&#x2F;假设有5个顶点，从0号顶点开始绘制glDrawArrays(GL_TRIANGLES, 0, 5);&#x2F;&#x2F;最终会绘制出一个三角形，因为在三角形绘制模式下最后两个顶点无法构成三角形<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面列举出<strong>glDrawArrays</strong>中一些绘制模式，不同的绘制模式连接顶点的方式不一样：</p><p><strong>绘制三角形：</strong></p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250424211839314.png" alt="image-20250424211839314" style="zoom: 50%;" /><p><strong>绘制直线：</strong></p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250424211915083.png" alt="image-20250424211915083" style="zoom:67%;" /><h2 id="绘制一个彩色的三角形"><a href="#绘制一个彩色的三角形" class="headerlink" title="绘制一个彩色的三角形"></a>绘制一个彩色的三角形</h2><p>当我们三个点的颜色各不相同时，内部已经实现的渲染管线会把三角形内部的点按照用插值算法进行计算，使得三个顶点之间的颜色1有一个平滑的过渡，就绘制出了彩色的三角形。下面是具体代码：</p><pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token comment">//声明全局变量</span>GLuint vao<span class="token punctuation">,</span> program<span class="token punctuation">;</span><span class="token comment">//准备VAO、program和VBO</span><span class="token keyword">void</span> <span class="token function">prepaerEBO</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">float</span> pos<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>        <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span><span class="token number">0.0f</span><span class="token punctuation">,</span>         <span class="token number">0.5f</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span><span class="token number">0.0f</span><span class="token punctuation">,</span>         <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.5f</span><span class="token punctuation">,</span><span class="token number">0.0f</span><span class="token punctuation">,</span>         <span class="token number">1.0f</span><span class="token punctuation">,</span><span class="token number">1.0f</span><span class="token punctuation">,</span><span class="token number">0.0f</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> colors<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>        <span class="token number">1.0f</span><span class="token punctuation">,</span><span class="token number">0.0f</span><span class="token punctuation">,</span><span class="token number">0.0f</span><span class="token punctuation">,</span>        <span class="token number">0.0f</span><span class="token punctuation">,</span><span class="token number">1.0f</span><span class="token punctuation">,</span><span class="token number">0.0f</span><span class="token punctuation">,</span>        <span class="token number">0.0f</span><span class="token punctuation">,</span><span class="token number">0.0f</span><span class="token punctuation">,</span><span class="token number">1.0f</span><span class="token punctuation">,</span>        <span class="token number">0.5f</span><span class="token punctuation">,</span><span class="token number">0.5f</span><span class="token punctuation">,</span><span class="token number">0.5f</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> idxs<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>        <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span>        <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">//创建VBO</span>    GLuint posVbo<span class="token punctuation">,</span>colorVbo<span class="token punctuation">;</span>        <span class="token comment">//位置VBO</span>    <span class="token function">glGenBuffers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>posVbo<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> posVbo<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glBufferData</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">,</span> pos<span class="token punctuation">,</span> GL_STATIC_DRAW<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//颜色VBO</span>    <span class="token function">glGenBuffers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>colorVbo<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> colorVbo<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glBufferData</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>colors<span class="token punctuation">)</span><span class="token punctuation">,</span> colors<span class="token punctuation">,</span> GL_STATIC_DRAW<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//创建EBO</span>    GLuint ebo<span class="token punctuation">;</span>    <span class="token function">glGenBuffers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ebo<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ELEMENT_ARRAY_BUFFER<span class="token punctuation">,</span> ebo<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glBufferData</span><span class="token punctuation">(</span>GL_ELEMENT_ARRAY_BUFFER<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>idxs<span class="token punctuation">)</span><span class="token punctuation">,</span> idxs<span class="token punctuation">,</span> GL_STATIC_DRAW<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//创建VAO</span>    <span class="token function">glGenVertexArrays</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>vao<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glBindVertexArray</span><span class="token punctuation">(</span>vao<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//绑定位置描述信息</span>    <span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> posVbo<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glEnableVertexAttribArray</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glVertexAttribPointer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">,</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//绑定颜色描述信息</span>    <span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> colorVbo<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glEnableVertexAttribArray</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glVertexAttribPointer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">,</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//绑定ebo到vao</span>    <span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ELEMENT_ARRAY_BUFFER<span class="token punctuation">,</span> ebo<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glBindVertexArray</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token comment">//-------------------------------------------shader的编译与链接----------------------------------</span><span class="token keyword">void</span> <span class="token function">prepaerShader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//shader源代码</span>    <span class="token keyword">const</span> char<span class="token operator">*</span> vertexShaderSource <span class="token operator">=</span>        <span class="token string">"#version 460 core\n"</span>        <span class="token string">"layout(location = 0) in vec3 aPosition;\n"</span>        <span class="token string">"layout(location = 1) in vec3 aColor;\n"</span>        <span class="token string">"out vec3 color;\n"</span>        <span class="token string">"void main()\n"</span>        <span class="token string">"&#123;\n"</span>        <span class="token string">"gl_Position = vec4(aPosition.x, aPosition.y, aPosition.z, 1.0);\n"</span>        <span class="token string">"color=aColor;\n"</span>        <span class="token string">"&#125;\n\0"</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> char<span class="token operator">*</span> fragmentShaderSource <span class="token operator">=</span>        <span class="token string">"#version 460 core\n"</span>        <span class="token string">"out vec4 fColor;\n"</span>        <span class="token string">"in vec3 color;\n"</span>        <span class="token string">"void main()\n"</span>         <span class="token string">"&#123;\n"</span>        <span class="token string">"fColor = vec4(color,1.0f);\n"</span>        <span class="token string">"&#125;\n\0"</span><span class="token punctuation">;</span>    GLuint vertexShader<span class="token punctuation">,</span>fragmentShader<span class="token punctuation">;</span>    <span class="token comment">//创建一个vertex shader，并返回对应编号</span>    vertexShader <span class="token operator">=</span> <span class="token function">glCreateShader</span><span class="token punctuation">(</span>GL_VERTEX_SHADER<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//创建一个fragment shader，并返回对应编号</span>    fragmentShader <span class="token operator">=</span><span class="token function">glCreateShader</span><span class="token punctuation">(</span>GL_FRAGMENT_SHADER<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//给对应的shader注入源代码</span>    <span class="token comment">//参数分别为:对应shader编号，源码字符串的个数，存储字符串的二维数组，存储每一个字符串长度的数组</span>    <span class="token function">glShaderSource</span><span class="token punctuation">(</span>vertexShader<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>vertexShaderSource<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glShaderSource</span><span class="token punctuation">(</span>fragmentShader<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>fragmentShaderSource<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//编译shader</span>    <span class="token function">glCompileShader</span><span class="token punctuation">(</span>vertexShader<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//检查shader的编译是否出错</span>    <span class="token keyword">int</span> success<span class="token punctuation">;</span>    GLchar infoLog<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">glGetShaderiv</span><span class="token punctuation">(</span>vertexShader<span class="token punctuation">,</span> GL_COMPILE_STATUS<span class="token punctuation">,</span> <span class="token operator">&amp;</span>success<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>success<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">glGetShaderInfoLog</span><span class="token punctuation">(</span>vertexShader<span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> infoLog<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取错误信息</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"VertexShader Complie Error\n"</span> <span class="token operator">&lt;&lt;</span> infoLog <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">glCompileShader</span><span class="token punctuation">(</span>fragmentShader<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glGetShaderiv</span><span class="token punctuation">(</span>fragmentShader<span class="token punctuation">,</span> GL_COMPILE_STATUS<span class="token punctuation">,</span> <span class="token operator">&amp;</span>success<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>success<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">glGetShaderInfoLog</span><span class="token punctuation">(</span>fragmentShader<span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> infoLog<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取错误信息</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"FragmentShader Complie Error\n"</span> <span class="token operator">&lt;&lt;</span> infoLog <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    program<span class="token operator">=</span><span class="token function">glCreateProgram</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//将上面编译好的结果与program相关联</span>    <span class="token function">glAttachShader</span><span class="token punctuation">(</span>program<span class="token punctuation">,</span> vertexShader<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glAttachShader</span><span class="token punctuation">(</span>program<span class="token punctuation">,</span> fragmentShader<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//开始链接</span>    <span class="token function">glLinkProgram</span><span class="token punctuation">(</span>program<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//检查是否有链接错误</span>    <span class="token function">glGetProgramiv</span><span class="token punctuation">(</span>program<span class="token punctuation">,</span> GL_LINK_STATUS<span class="token punctuation">,</span> <span class="token operator">&amp;</span>success<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>success<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">glGetProgramInfoLog</span><span class="token punctuation">(</span>program<span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> infoLog<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取错误信息</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Link Error\n"</span> <span class="token operator">&lt;&lt;</span> infoLog <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//链接完成后创建的shader就不需要了，释放资源</span>    <span class="token function">glDeleteShader</span><span class="token punctuation">(</span>vertexShader<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">glDeleteShader</span><span class="token punctuation">(</span>fragmentShader<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token comment">//-------------------------------------------渲染操作----------------------------------</span><span class="token comment">//渲染操作</span><span class="token keyword">void</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//清理画布</span>    <span class="token function">glClear</span><span class="token punctuation">(</span>GL_COLOR_BUFFER_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//绘制</span>    <span class="token comment">//选择绘制程序</span>    <span class="token function">glUseProgram</span><span class="token punctuation">(</span>program<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//绑定vao</span>    <span class="token function">glBindVertexArray</span><span class="token punctuation">(</span>vao<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//开始绘制，参数依次为：绘制的图形，起始点，点的个数</span>    <span class="token comment">//这俩我们绘制的是三角形，从0号开始选择，共选择3个顶点</span>    <span class="token comment">//glDrawArrays(GL_LINES, 0, 2);</span>        <span class="token comment">//使用ebo时用这个方法绘制，参数依次：绘制模式，绘制图形的点数，索引数据类型，偏移量（一般写0）</span>    <span class="token function">glDrawElements</span><span class="token punctuation">(</span>GL_TRIANGLES<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> GL_UNSIGNED_INT<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//接触绑定</span>    <span class="token function">glBindVertexArray</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在glsl中，我们可以使用<strong>in</strong>或者<strong>out</strong>关键字控制程序接收的输入和输出，并且在<strong>Vexter Shander中out输出</strong>的变量最终在<strong>Fragment Shader</strong>可以用<strong>in</strong>关键字声明<strong>同名的变量</strong>接收到。</p><pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token comment">//Vexter Shader</span><span class="token comment">//用VAO 0号位置的描述性信息从VBO中取坐标数据输入</span><span class="token keyword">layout</span><span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token keyword">vec3</span> aPosition<span class="token punctuation">;</span><span class="token comment">//用VAO 1号位置的描述性信息从VBO中取颜色数据输入</span><span class="token keyword">layout</span><span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token keyword">vec3</span> aColor<span class="token punctuation">;</span><span class="token comment">//输出一个三维向量 color</span><span class="token keyword">out</span> <span class="token keyword">vec3</span> color<span class="token punctuation">;</span><span class="token comment">//给color赋值后Fragment Shader就能拿到数据</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//将我们的颜色信息交给Fragment Shader处理</span>    color<span class="token operator">=</span>aColor<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//Fragment Shader</span><span class="token comment">//输出最终的颜色</span><span class="token keyword">out</span> <span class="token keyword">vec4</span> fColor<span class="token punctuation">;</span><span class="token comment">//接收从Vexter Shader输出的color向量(变量名要一致)</span><span class="token keyword">in</span> <span class="token keyword">vec3</span> color<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//用从Vexter Shader接收到的颜色控制最终输出的颜色</span>    fColor <span class="token operator">=</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span>color<span class="token punctuation">,</span><span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面因为三个点的颜色不一致，所以会在内部自动进行三角形内每个点的插值运算，得到一个彩色的三角形，如下图所示：</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240206114956358.png" alt="image-20240206114956358" style="zoom:50%;" /><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250511214654845.png" alt="image-20250511214654845" style="zoom:67%;" /><h2 id="texture-纹理"><a href="#texture-纹理" class="headerlink" title="texture(纹理)"></a>texture(纹理)</h2><h3 id="UV坐标"><a href="#UV坐标" class="headerlink" title="UV坐标"></a>UV坐标</h3><p>在OpenGL中，<strong>左下角为坐标原点</strong>，图片的大都为左上角为坐标原点，因此在OpenGL中存储图片必须反转一下图片的Y轴。</p><p>在纹理中，我们使用的是UV坐标。通常U表示横向，V表示纵向，两个方向的取值都是<strong>0到1</strong>之间，用以表示当前像素对应图片上百分比位置。</p><p>以前的屏幕像素与纹理像素一一对应的方法不灵活且效果差，采用UV坐标后就改为了<strong>比例对应</strong>的方式。首先找到屏幕中某一像素所在位置的百分比，将横向和纵向的百分比分别乘以纹理图片的宽和高，就得到了与屏幕中该像素对应的纹理图片中的像素。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250704220905713.png" alt="image-20250704220905713" style="zoom:50%;" /><p>从上面可以得知，在为我们的图形贴上贴图时，需要知道每个顶点的UV坐标。也就是说，<strong>UV坐标需要作为每个顶点的属性存储在VBO中</strong>。知道了顶点的UV坐标后，光栅化后的每个像素块的UV坐标都会由插值算法计算出，这样就可以为图形贴上纹理了。</p><h3 id="纹理对象与采样"><a href="#纹理对象与采样" class="headerlink" title="纹理对象与采样"></a>纹理对象与采样</h3><p>纹理对象（Texture）是在GPU端按照<strong>一定的格式</strong>存储纹理图片的<strong>描述信息</strong>和<strong>数据信息</strong>的对象。（在cpu端，描述图片的格式有多种，例如jpg、png等。当我们读取到纹理图片到内存后需要发送到显存中，而在显存中用来描述纹理图片信息的对象就叫做纹理对象。）</p><p>在GPU端<strong>根据UV坐标</strong>按照<strong>一定的算法</strong>从<strong>纹理图片中获取颜色</strong>的过程称为采样，执行采样的对象叫做采样器（sampler）。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250704222728529.png" alt="image-20250704222728529" style="zoom:67%;" /><h3 id="Texture-Units-纹理单元"><a href="#Texture-Units-纹理单元" class="headerlink" title="Texture Units(纹理单元)"></a>Texture Units(纹理单元)</h3><p>纹理与单元绑定后，采样器可以选择使用哪一个单元并获取与之对应的纹理对象。</p><p>具体来说，纹理单元是采样器和纹理对象之间的桥梁。纹理对象绑定某个纹理单元后，采样器可以对这个单元所绑定的纹理对象进行采样。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240220104327355.png" alt="image-20240220104327355" style="zoom:50%;" /><p>使用下面的函数可以进行纹理对象的创建、纹理单元的激活以及纹理对象和纹理单元的绑定操作。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240220104357382.png" alt="image-20240220104357382" style="zoom:50%;" /><p>如果我们先执行纹理单元的激活操作，再执行<strong>glBindTexture</strong>函数，此时会将该<strong>纹理对象绑定到前面激活的纹理单元</strong>上。</p><p>glBindTexture函数不仅会将纹理对象绑定到纹理单元上，也会将纹理对象绑定到Opengl对应的插槽上，以便将图片数据发送到指定的纹理对象身上。</p><p>如果执行<strong>glBindTexture</strong>函数时没有激活任何纹理单元，则此时会<strong>默认激活0号纹理单元</strong>，该纹理对象绑定到0号单元。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240220104438107.png" alt="image-20240220104438107" style="zoom:50%;" /><p>执行glTexImage2D函数后，会向当前绑定在状态机中的纹理对象中发送图片数据。</p><p>其中<strong>type</strong>参数是指我们每一个通道的数据是什么格式的，因为每个通道取值都是0-255，所以8位的unsigned_byte类型足够了。</p><p><strong>pixels</strong>参数就是读取到的图片数据的指针，将读取到的数据直接传过去即可。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240220104946423.png" alt="image-20240220104946423" style="zoom:67%;" /><pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl">GLuint texture<span class="token punctuation">;</span><span class="token comment">//----------------------------------旧版（OpenGL 4.5之前）创建纹理方式</span><span class="token keyword">void</span> <span class="token function">prepaerTextures</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">int</span> width<span class="token punctuation">,</span> height<span class="token punctuation">,</span> channel<span class="token punctuation">;</span>    <span class="token comment">//读取图片</span>    <span class="token function">stbi_set_flip_vertically_on_load</span><span class="token punctuation">(</span><span class="token keyword">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> char<span class="token operator">*</span> data <span class="token operator">=</span> <span class="token function">stbi_load</span><span class="token punctuation">(</span><span class="token string">"Assets/Textures/a.png"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>width<span class="token punctuation">,</span> <span class="token operator">&amp;</span>height<span class="token punctuation">,</span> <span class="token operator">&amp;</span>channel<span class="token punctuation">,</span> STBI_rgb_alpha<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//生成纹理对象并绑定单元</span>    <span class="token function">glGenTextures</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>texture<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//激活纹理单元（必须要先激活指定的纹理单元再绑定纹理对象才能将纹理对象绑定到指定单元身上）</span>    <span class="token function">glActiveTexture</span><span class="token punctuation">(</span>GL_TEXTURE0<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//绑定纹理对象到OpenGL插槽中</span>    <span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> texture<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//开辟显存传输图片数据</span>    <span class="token function">glTexImage2D</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> GL_RGBA<span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> GL_RGBA<span class="token punctuation">,</span> GL_UNSIGNED_BYTE<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//释放内存中的图片数据</span>    <span class="token function">stbi_image_free</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//----------------------------------新版（OpenGL 4.5之后）创建纹理方式，函数参数都大同小异</span><span class="token keyword">void</span> <span class="token function">prepaerTextures</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> width<span class="token punctuation">,</span> height<span class="token punctuation">,</span> channels<span class="token punctuation">;</span>stbi_uc<span class="token operator">*</span> data <span class="token operator">=</span> <span class="token function">stbi_load</span><span class="token punctuation">(</span>filePath<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>width<span class="token punctuation">,</span> <span class="token operator">&amp;</span>height<span class="token punctuation">,</span> <span class="token operator">&amp;</span>channels<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//直接创建纹理对象并绑定到GL_TEXTURE_2D插槽</span><span class="token function">glCreateTextures</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>m_RendererId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//将纹理对象直接绑定到指定纹理单元(不用先激活纹理单元再绑定纹理对象了，可以一步到位)</span>    <span class="token function">glBindTextureUnit</span><span class="token punctuation">(</span>unit<span class="token punctuation">,</span> m_RendererId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//分配显存，设置纹理的存储格式，但不填充数据(使用glTextureSubImage2D填充或更新数据)</span><span class="token comment">//第二个参数levels设为1表示不启用mipmap</span><span class="token function">glTextureStorage2D</span><span class="token punctuation">(</span>m_RendererId<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> GL_RGB8<span class="token punctuation">,</span> m_Width<span class="token punctuation">,</span> m_Height<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将纹理数据传送到GPU</span><span class="token function">glTextureSubImage2D</span><span class="token punctuation">(</span>m_RendererId<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> m_Width<span class="token punctuation">,</span> m_Height<span class="token punctuation">,</span> GL_RGB<span class="token punctuation">,</span> GL_UNSIGNED_BYTE<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//设置纹理过滤方式(新旧方式一致)</span><span class="token function">glTextureParameteri</span><span class="token punctuation">(</span>m_RendererId<span class="token punctuation">,</span> GL_TEXTURE_MIN_FILTER<span class="token punctuation">,</span> GL_LINEAR<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">glTextureParameteri</span><span class="token punctuation">(</span>m_RendererId<span class="token punctuation">,</span> GL_TEXTURE_MAG_FILTER<span class="token punctuation">,</span> GL_LINEAR<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">stbi_image_free</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="纹理过滤"><a href="#纹理过滤" class="headerlink" title="纹理过滤"></a>纹理过滤</h3><p>这其实就是之前计算机图形学中纹理问题的内容，当图片大小确定，而展示区域比图片大或者比图片小时都会出现绘制的问题，而纹理过滤就是为了解决这样的问题。</p><p>总共有两种问题会出现：</p><ol><li>展示区域过大（屏幕像素&gt;图片像素），图片需要放大。一般会使用**双线性插值(Bilinear)**创造缺少的像素，这样会使图片放大后变得模糊，而不会出现明显的颗粒感。</li><li>展示区域过小（屏幕像素&lt;图片像素），图片需要缩小。一般使用**临近法(Nearest)**优先选择离屏幕像素更近的图片像素，使得小的区域能展示更多的图片信息。</li></ol><p>下面是在OpenGL中设置纹理过滤的方式，通过<strong>glTexParameteri</strong>函数进行设置。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240220113239049.png" alt="image-20240220113239049" style="zoom:67%;" /><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;设置纹理过滤方式&#x2F;&#x2F;展示区域 &lt; 图片大小  纹理图片需要缩小  线性插值glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);&#x2F;&#x2F;展示区域 &gt; 图片大小  纹理图片需要放大  就近glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="纹理包裹"><a href="#纹理包裹" class="headerlink" title="纹理包裹"></a>纹理包裹</h3><p>在前面的介绍中，opengl中的uv坐标是要在<code>[0, 1]</code> 范围内的，但是实际应用中uv坐标可能会出现大于1的情况。</p><p><strong>纹理包裹（Texture Wrapping）</strong> 定义了当纹理坐标（UV）超出默认范围 <code>[0, 1]</code> 时，如何采样纹理边缘的行为。它是控制纹理重复、拉伸或截断的关键参数。可以通过<strong>glTexParameteri</strong>函数进行设置，共有四种策略可供使用。</p><p>在设置时，主要分为 <strong>S（水平）</strong> 和 <strong>T（垂直）</strong> 两个方向，不难看出S和U同一个方向，T</p><table><thead><tr><th>模式</th><th>行为描述</th></tr></thead><tbody><tr><td><strong><code>GL_REPEAT</code></strong></td><td>重复纹理（默认模式）</td></tr><tr><td><strong><code>GL_MIRRORED_REPEAT</code></strong></td><td>镜像重复</td></tr><tr><td><strong><code>GL_CLAMP_TO_EDGE</code></strong></td><td>截取边缘颜色</td></tr><tr><td><strong><code>GL_CLAMP_TO_BORDER</code></strong></td><td>超出部分填充自定义边框色  需配合 <code>glTexParameterfv(GL_TEXTURE_BORDER_COLOR)</code></td></tr></tbody></table><p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250705165048770.png" alt="image-20250705165048770" style="zoom:50%;display:inline" /><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250705165210016.png" alt="image-20250705165210016" style="zoom:50%;display:inline" /></p><p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250705165428936.png" alt="image-20250705165428936" style="zoom:40%;display:inline" /><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250705165647969.png" alt="image-20250705165647969" style="zoom:40%;display:inline" /></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;设置纹理包裹方式glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);&#x2F;&#x2F;S -&gt; UglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);&#x2F;&#x2F;T -&gt; V<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="使用采样器"><a href="#使用采样器" class="headerlink" title="使用采样器"></a>使用采样器</h3><p>这部分就要在shader中使用采样器对纹理进行采样获取每个像素的颜色。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 1. 因为uv坐标每个顶点都是不一样的，所以要先在vbo中将uv坐标作为顶点属性传到显存中void prepare()&#123;    &#x2F;&#x2F;准备数据（坐标，颜色，uv坐标）    float data[] &#x3D; &#123;         -0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f,        0.5f, 0.5f, 0.0f,   0.0f, 1.0f, 0.0f, 1.0f, 1.0f,        -0.5f, 0.5f, 0.0f,  0.0f, 0.0f, 1.0f, 0.0f, 1.0f,        0.5f, -0.5f, 0.0f,  0.5f, 0.5f, 0.5f, 1.0f, 0.0f    &#125;;    unsigned int idxs[] &#x3D; &#123;        0,1,2,        1,0,3    &#125;;    &#x2F;&#x2F;创建vbo    GL_CALL(glGenBuffers(1, &amp;vbo));    &#x2F;&#x2F;绑定vbo    GL_CALL(glBindBuffer(GL_ARRAY_BUFFER, vbo));    &#x2F;&#x2F;传输数据    GL_CALL(glBufferData(GL_ARRAY_BUFFER, sizeof(data), data, GL_STATIC_DRAW));    &#x2F;&#x2F;创建vao    GL_CALL(glGenVertexArrays(1, &amp;vao));    &#x2F;&#x2F;绑定vao    GL_CALL(glBindVertexArray(vao));    &#x2F;&#x2F;设置坐标属性描述    GL_CALL(glEnableVertexAttribArray(0));    GL_CALL(glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0));    &#x2F;&#x2F;设置颜色属性描述    GL_CALL(glEnableVertexAttribArray(1));    GL_CALL(glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float))));    &#x2F;&#x2F;设置uv坐标描述    GL_CALL(glEnableVertexAttribArray(2));    GL_CALL(glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float))));        &#x2F;&#x2F;创建ebo    GL_CALL(glGenBuffers(1, &amp;ebo));    &#x2F;&#x2F;绑定ebo到vao上    GL_CALL(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo));    GL_CALL(glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(idxs), idxs, GL_STATIC_DRAW));    &#x2F;&#x2F;解绑vao    GL_CALL(glBindVertexArray(0));    &#x2F;&#x2F;准备shader    shader &#x3D; new Shader(&quot;assets&#x2F;shaders&#x2F;vertex.glsl&quot;, &quot;assets&#x2F;shaders&#x2F;fragment.glsl&quot;);&#125;&#x2F;&#x2F; 2. 准备纹理对象、绑定纹理单元等操作void prepareTexture()&#123;    &#x2F;&#x2F;读取图片    int height, width, channels;    stbi_set_flip_vertically_on_load(true);    unsigned char* imageData &#x3D; stbi_load(&quot;assets&#x2F;textures&#x2F;box.png&quot;, &amp;height, &amp;width, &amp;channels, STBI_rgb_alpha);    &#x2F;&#x2F;创建纹理对象    glGenTextures(1, &amp;texture);    &#x2F;&#x2F;激活0号纹理单元（如果不手动激活纹理单元，在绑定纹理对象时默认激活0号纹理单元）    glActiveTexture(GL_TEXTURE0);    &#x2F;&#x2F;绑定纹理对象    glBindTexture(GL_TEXTURE_2D, texture);    &#x2F;&#x2F;向纹理对象传递数据    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, imageData);    &#x2F;&#x2F;释放内存中读取的的图片数据（已经发送到显存了，CPU端没有必要再保存数据了）    stbi_image_free(imageData);        &#x2F;&#x2F;设置纹理过滤方式    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);    &#x2F;&#x2F;设置纹理包裹方式    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);&#x2F;&#x2F;S -&gt;U    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);&#x2F;&#x2F;T -&gt;V&#125;&#x2F;&#x2F; 3. 在vertexShader中接收uv坐标并传递到fragemntShader中#version 460 corelayout(location &#x3D; 0) in vec3 aPosition;layout(location &#x3D; 1) in vec3 aColor;layout(location &#x3D; 2) in vec2 aUv;out vec3 color;out vec2 uv;uniform float time;void main()&#123;color &#x3D; aColor;uv &#x3D; aUv;gl_Position &#x3D; vec4(aPosition.x, aPosition.y + sin(time) &#x2F; 2.0, aPosition.z, 1.0);&#125;&#x2F;&#x2F; 4. 在fragmentShader中增加一个sampler2D的uniform变量作为采样器对纹理进行采样#version 460 coreout vec4 FragColor;in vec3 color;in vec2 uv;uniform sampler2D sampler;void main()&#123;&#x2F;&#x2F;原始颜色设置&#x2F;&#x2F;FragColor &#x3D; vec4(color.x, color.y, color.z, 1.0f);&#x2F;&#x2F;使用texture函数选择一个采样器在指定uv坐标上采样，获取一个三维(rgb)或四维向量(rgba)FragColor &#x3D; texture(sampler, uv);&#125;&#x2F;&#x2F; 5. 外部设置采样器的值，将采样器与纹理单元进行绑定，以决定采样器要对哪个纹理单元采样shader-&gt;setUniform1i(&quot;sampler&quot;, 0);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们在代码中可以给sampler赋一个int类型的数值（纹理单元的编号），将采样器与纹理单元进行绑定，表示这个采样器要对哪个纹理单元进行采样。</p><p><strong>注意：</strong><code>glTexParameteri</code> 修改的是<strong>当前绑定的纹理对象</strong>的状态。因此必须先使用glBindTexture绑定纹理对象到opengl插槽后才能正确执行纹理过滤方式和纹理包裹方式的设置，如果还未绑定纹理对象就先设置，那么纹理则无法正常显示。</p><h3 id="MipMap（多级渐远纹理）"><a href="#MipMap（多级渐远纹理）" class="headerlink" title="MipMap（多级渐远纹理）"></a>MipMap（多级渐远纹理）</h3><p>当视线逐渐远离一个物体时，根据进大远小的原理，物体也必然会变得越来越小，那么该物体在屏幕中所占的像素也会越来越少。那么问题来了，一开始物体表面的原始贴图必然是清晰的，随着物体越来越小，可显示的像素块页越来越少，就会导致在一块小区域对一张大图片进行采样，不仅会导致画面出现毛刺和摩尔纹等问题，也会浪费内存和带宽。</p><p>如下图所示，将一张贴图向远处重复延伸，近处显示的很清晰，但是远处的画面看起来非常模糊不舒服，问题所在就是前面所描述的。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250705214311994.png" alt="image-20250705214311994" style="zoom: 33%;" /><p>为了解决这一问题，于是就有了MipMap。MipMap可以生成一系列的纹理图像，根据不同的距离为物体选择合适的纹理，即解决了远距离图像失真的情况，又节省了渲染资源。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250705214529896.png" alt="image-20250705214529896" style="zoom:50%;" /><p>如果要使用OpenGL中提供的MipMap生成策略，只需要两句代码即可。</p><p><strong>glGenerateMipmap</strong>函数会为当前绑定的纹理贴图生成一系列不同level的Mipmap纹理。</p><p><strong>glTexParameteri</strong>函数是设置选择不同Mipmap纹理的策略，由于只有当<strong>展示区域像素&lt;纹理像素</strong>时才会出现这种情况，所以只需要设置<strong>GL_TEXTURE_MIN_FILTER</strong>情况时的Mipmap选择策略即可。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250706154430595.png" alt="image-20250706154430595" style="zoom: 50%;" /><h3 id="Texture类的封装"><a href="#Texture类的封装" class="headerlink" title="Texture类的封装"></a>Texture类的封装</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;-------------------------------------------------texture.h文件#pragma once#include &quot;core.h&quot;class Texture&#123;private:GLuint mTexture&#123; 0 &#125;;int mWidth&#123; 0 &#125;;int mHeight&#123; 0 &#125;;GLuint mUnit&#123; 0 &#125;;public:Texture(const char* path, int unit);~Texture();public:&#x2F;&#x2F;将当前纹理对象绑定到opengl状态机上void bind();&#125;;&#x2F;&#x2F;-------------------------------------------------texture.cpp文件#define STB_IMAGE_IMPLEMENTATION#include &lt;stb_image&#x2F;stb_image.h&gt;#include &quot;texture.h&quot;Texture::Texture(const char* path, int unit)&#123;    mUnit &#x3D; unit;    &#x2F;&#x2F;读取图片    int channels;    stbi_set_flip_vertically_on_load(true);    unsigned char* imageData &#x3D; stbi_load(path, &amp;mWidth, &amp;mHeight, &amp;channels, STBI_rgb_alpha);    &#x2F;&#x2F;创建纹理对象    GL_CALL(glGenTextures(1, &amp;mTexture));    &#x2F;&#x2F;激活0号纹理单元（如果不手动激活纹理单元，在绑定纹理对象时默认激活0号纹理单元）    GL_CALL(glActiveTexture(GL_TEXTURE0 + mUnit));    &#x2F;&#x2F;绑定纹理对象    GL_CALL(glBindTexture(GL_TEXTURE_2D, mTexture));    &#x2F;&#x2F;向纹理对象传递数据    GL_CALL(glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, mWidth, mHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, imageData));    &#x2F;&#x2F;释放内存中读取的的图片数据（已经发送到显存了，CPU端没有必要再保存数据了）    stbi_image_free(imageData);    &#x2F;&#x2F;设置纹理过滤方式    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);    &#x2F;&#x2F;设置纹理包裹方式    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);&#x2F;&#x2F;S -&gt;U    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);&#x2F;&#x2F;T -&gt;V&#125;Texture::~Texture()&#123;    if (mTexture !&#x3D; 0)    &#123;        glDeleteTextures(1, &amp;mTexture);    &#125;&#125;void Texture::bind()&#123;    &#x2F;&#x2F;激活自己的纹理单元    GL_CALL(glActiveTexture(GL_TEXTURE0 + mUnit));    &#x2F;&#x2F;绑定纹理对象    GL_CALL(glBindTexture(GL_TEXTURE_2D, mTexture));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h2><h3 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h3><p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250706202159737.png" alt="image-20250706202159737"></p><p>世界坐标系是绝对的，永恒不变的。本地坐标系是物体身上附加的坐标系，用来表示物体的朝向等状态，当物体旋转或者移动时，其本地坐标系会随着物体改变。</p><h3 id="模型变换矩阵（ModelMatrix）"><a href="#模型变换矩阵（ModelMatrix）" class="headerlink" title="模型变换矩阵（ModelMatrix）"></a>模型变换矩阵（ModelMatrix）</h3><p>glm变换函数的第一个参数是一个矩阵，表明了当前物体前面的所有变换。如下代码所示，在第一次变换时，由于还未进行变换，所以要传入单位矩阵，表面是原始状态。在第二次变换时，传入的是第一次变换后得到的transform矩阵，这个矩阵已经记录了第一次将物体选择了45度的状态，然后在此状态下进行平移变换。且<strong>平移时是按照旋转后的本地坐标系移动</strong>的。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250706203639109.png" alt="image-20250706203639109" style="zoom: 50%;" /><p>旋转操作是围绕原点旋转的，<strong>glm中的旋转</strong>是以物体的<strong>本地坐标系原点</strong>为基准进行旋转的。一开始本地坐标系和世界坐标系重合，先将物体平移，再旋转45度，可以看到物体并没有绕着世界坐标系原点旋转，而是绕着本地坐标系原点旋转的。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250706204146727.png" alt="image-20250706204146727" style="zoom:50%;" /><p>glm的平移变换要根据缩放变换的程度而定，假设我们先将x方向缩放为原来的0.5倍，那么再将物体向x轴平移1个单位距离时，就会只平移0.5个单位距离。这是因为x轴已经被缩放过了，实际平移的距离 &#x3D; 输入平移的距离 * 对应轴缩放系数。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250706204420151.png" alt="image-20250706204420151" style="zoom:50%;" /><p>模型变换就是对物体进行平移、缩放、旋转等变换操作，这一步骤会将物体的顶点坐标由<strong>模型坐标系</strong>转为<strong>世界坐标系</strong>下的坐标。简单来说，模型变换就是将物体从初始状态摆放在世界中的其他位置。</p><h3 id="视图变换矩阵（MiewMatrix）"><a href="#视图变换矩阵（MiewMatrix）" class="headerlink" title="视图变换矩阵（MiewMatrix）"></a>视图变换矩阵（MiewMatrix）</h3><p>为了将物体投影出来，我们需要一个观察者来观察世界中的物体，这个观察者被称为<strong>摄像机</strong>(Camera)，这只是一个抽象的概念，并不实际存在。</p><p>对于一个摄像机来说，我们需要知道最基本的三个参数，即摄像机的<strong>位置</strong>、摄像机的<strong>朝向</strong>（看向哪个方向）和摄像机的<strong>穹顶方向</strong>（正上方的方向。因为当相机倒过来的时候看到的物体也会是倒的，我们需要知道摄像机是正的还是歪的）。</p><p>现在考虑最简单的情况：</p><ul><li>摄像机在<strong>世界坐标系的原点</strong></li><li>摄像机<strong>看向-Z方向</strong></li><li>穹顶方向维Y轴方向</li></ul><p>此时进行投影计算最为简单，因为所有的物体只需要<strong>沿z轴投影</strong>到摄像机的屏幕上即可。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250707163143623.png" alt="image-20250707163143623" style="zoom:50%;" /><p>假设此时摄像机进行了旋转和平移等变换操作：</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250707163802275.png" alt="image-20250707163802275" style="zoom:50%;" /><p>此时摄像机的朝向是一个较为复杂的方向，如果此时再将物体投影到摄像机的屏幕上，在数学计算上是一个非常麻烦的事情。在数学上，我们的的投影都喜欢沿着坐标轴投影，处理这样一个复杂方向的投影是比较困难的。</p><p>为了解决这一问题，可以将<strong>物体</strong>的顶点坐标由<strong>世界坐标系</strong>转为到<strong>摄像机坐标系</strong>（就是摄像机自己的本地坐标系）中。这样的好处是，在摄像机坐标系中摄像机所在的<strong>位置始终是原点</strong>，其<strong>朝向始终是-Z轴</strong>，物体可以直接在摄像机坐标系下沿Z轴进行投影。</p><p>所以我们只需要求出摄像机变换后，物体在摄像机坐标系下的坐标即可，即将<strong>物体顶点坐标</strong>从<strong>世界坐标系</strong>转到<strong>摄像机坐标系</strong>下。</p><p>相机的变换位置可由旋转变换和平移变换叠加而来。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250707165401188.png" alt="image-20250707165401188" style="zoom: 33%;" /><p>这里我们让物体的顶点和摄像机做相同的变换，经过推导可得物体顶点的世界坐标系坐标和摄像机坐标系坐标的关系。</p><p>即已知某点的<strong>摄像机坐标系坐标</strong>和<strong>摄像机变换矩阵</strong>可以求得<strong>该点的世界坐标系坐标</strong>；</p><p>反之，已知某点的<strong>世界坐标系坐标</strong>和<strong>摄像机变换矩阵</strong>也可以求出<strong>该点的摄像机坐标系坐标</strong>。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250707171022603.png" alt="image-20250707171022603" style="zoom: 50%;" /><p>这样以来，我们只需要知道了摄像机的变换矩阵，便可通过下面的公式求出顶点的<strong>摄像机坐标系坐标</strong>。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250707171758859.png" alt="image-20250707171758859" style="zoom:50%;" /><p>知道计算公式以后，我们还需要计算出摄像机变换矩阵中的<strong>旋转部分</strong>和<strong>平移部分</strong>，因为变换矩阵是由旋转矩阵和平移矩阵叠加而来的。</p><p>由旋转矩阵的几何意义可知：旋转矩阵的<strong>前三列</strong>是旋转后物体<strong>本地坐标的三个轴</strong>。<br>$$<br>单位矩阵可以视为物体不做旋转的旋转矩阵：\<br>R_{\text{初始}} &#x3D; I &#x3D; \begin{bmatrix}<br>1 &amp; 0 &amp; 0 \<br>0 &amp; 1 &amp; 0 \<br>0 &amp; 0 &amp; 1 \<br>\end{bmatrix}\<br>此时前三列分别为(1,0,0)，(0,1,0),(0,0,1)，分别是x,y,z轴方向\<br>\<br>假设物体绕Y轴旋转90°，得到旋转矩阵：\<br>R &#x3D; \begin{bmatrix}<br>0 &amp; 0 &amp; 1 \<br>0 &amp; 1 &amp; 0 \<br>-1 &amp; 0 &amp; 0 \<br>\end{bmatrix}\<br>物体新X轴方向（第一列）：(0,0,−1)→ 指向世界Z轴负方向\<br>物体新Y轴方向（第二列）：(0,1,0) → 仍与世界Y轴同向\<br>物体新Z轴方向（第三列）：(1,0,0) → 指向世界X轴正方\<br>可以发现旋转矩阵的前三列就是该物体旋转后的本地坐标系的三个轴<br>$$<br>所以我们只需要知道摄像机当前的<strong>右向量</strong>、<strong>上向量</strong>和<strong>朝向</strong>（分别表示本地坐标系的x，y，-z方向），即可求出<strong>旋转矩阵R</strong>。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250707174921598.png" alt="image-20250707174921598" style="zoom:50%;" /><p>因为是先在原点进行旋转，所以<strong>平移矩阵T</strong>直接将变换后的世界坐标和原点坐标相减即可求出。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250707175050664.png" alt="image-20250707175050664" style="zoom:50%;" /><p>于是我们就可以求出摄像机的变换矩阵及其逆矩阵：</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250707175228123.png" alt="image-20250707175228123" style="zoom:50%;" /><p>有了摄像机变换矩阵的逆矩阵，我们就可以根据<strong>物体顶点</strong>的<strong>世界坐标系坐标</strong>求出其摄像机坐标系坐标。知道了物体顶点在摄像机坐标系下的坐标后，那么就可以很方便的将物体沿摄像机坐标系的Z轴投影到摄像机屏幕上。</p><p>简单来说，<strong>视图变换矩阵</strong>就是将物体顶点坐标从<strong>世界坐标系</strong>转到<strong>摄像机坐标系</strong>下。</p><p>我们可以使用glm库的<strong>lookAt</strong>函数生成视图变换矩阵viewMatrix。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;第一个参数eye：当前摄像机所在位置&#x2F;&#x2F;第二个参数center：当前摄像机看向那个点&#x2F;&#x2F;第三个参数top：穹顶向量（定义摄像机的“向上”方向,正常摄像机为(0,1,0)，翻转摄像机为(0,-1,0)）&#x2F;&#x2F;因为我们的摄像机在本地坐标下总是看向-Z方向，所以一般会将摄像机放置到+Z位置mat4 viewMatrix &#x3D; lookAt(vec3 eye, vec3 center, vec3 top);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="投影变换矩阵（ProjectionMatrix）"><a href="#投影变换矩阵（ProjectionMatrix）" class="headerlink" title="投影变换矩阵（ProjectionMatrix）"></a>投影变换矩阵（ProjectionMatrix）</h3><p>投影这个概念在数学中也很常见，就是将三维的物体沿某一坐标轴投影到二维平面上。在三维场景中的物体，必须投影到一块幕布上，才能显示出来。例如打游戏的时候，显示器的屏幕就是一个二维的屏幕，却能显示出三维的游戏场景，就是将场景中的物体最终投影到幕布上才能在二维的显示器屏幕上显示出来。</p><p>投影又分为正交投影（Orthographic Projection）和透视投影（Perspective Projection）两种投影方式，两种投影方式都有各自的应用场景。</p><p><strong>一、正交投影：</strong></p><p>正交投影中不存在人眼的概念，发出的都是平行光，就好比是在一堆物体前用平行光照射到一堵墙上一样。类似数学中立体几何的正视图、俯视图、侧视图那样的效果，无法体现物体间进大远小那种立体感的效果。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250707182324681.png" alt="image-20250707182324681" style="zoom:50%;" /><p>在正交投影中，我们会定义一个投影盒（left，right，top，bottom，near，far），可以简单理解为物体能够显示的边界范围，oopengl只会显示在投影盒内的物体。</p><ul><li><p>如果物体<strong>全部顶点</strong>都在<strong>投影盒内</strong>，则完整显示物体；</p></li><li><p>如果物体<strong>全部顶点</strong>都在<strong>投影盒外</strong>，则不显示物体；</p></li><li><p>如果物体<strong>部分顶点</strong>在<strong>投影盒外</strong>，则opengl会求出物体与投影盒的交点，只显示投影盒内的部分，就好比物体用刀切去了一部分。</p></li></ul><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250707184523187.png" alt="image-20250707184523187" style="zoom:40%;" /><p>投影盒投影面的四个角和屏幕的四个角是一一对应的，但是投影盒的大小是我们自己设置的，而且屏幕中采用的是NDC坐标系，X，Y，Z轴的范围都是[-1, 1]，所以还需要将投影盒内的顶点坐标转为NDC坐标。</p><p>不难发现，<strong>投影矩阵</strong>的作用就是将顶点的<strong>摄像机坐标系坐标</strong>转为屏幕上对应的<strong>NDC坐标系坐标</strong>。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250707183541524.png" alt="image-20250707183541524" style="zoom:40%;" /><p>由于NDC坐标系的范围是[-1, 1]，为了使这些顶点坐标缩放到同样的范围：</p><ol><li>我们需要先将<strong>投影盒的中心</strong>平移到摄像机坐标系的<strong>原点</strong>，盒内的物体顶点也随着做同样的平移变换。</li><li>将投影盒的<strong>长宽高</strong>都缩放为<strong>长度为2</strong>的立方体，盒内的顶点也随着做同样的缩放变换。</li></ol><p>上面两个步骤<strong>盒内和盒外</strong>的顶点都会<strong>做一样的变换</strong>，只是<strong>盒外的顶点</strong>变换后<strong>仍然在盒外</strong>，会被去除不显示出来。</p><p>于是我们就将每个<strong>顶点坐标</strong>从<strong>摄像机坐标系</strong>坐标转换到了<strong>NDC坐标系坐标</strong>。</p><p><strong>注意：<strong>在缩放变换矩阵中，x和y方向的缩放因子都是正数，但是</strong>z轴</strong>的缩放因子是<strong>负数</strong>。这是因为opengl中使用的是<strong>右手</strong>坐标系，<strong>屏幕朝外</strong>是z轴正方向；但是NDC坐标系使用的是<strong>左手</strong>坐标系，<strong>屏幕朝内</strong>才是z轴正方向。两个坐标系的<strong>z轴相反</strong>，所以在转换为NDC坐标系时要翻转一下z轴方向。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250707212835860.png" alt="image-20250707212835860" style="zoom:45%;" /><p>执行完投影变换后就会将顶点继续送入后续管线阶段，后面的过程是opengl自动实现的。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250707213303648.png" alt="image-20250707213303648" style="zoom:50%;" /><p>在glm库中可以使用rotho函数生成我们的投影变换矩阵orthProjectionMatrix。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;函数的六个参数定义了投影盒的范围，盒内的顶点才会最终显示在屏幕上mat4 orthProjectionMatrix &#x3D; ortho(float left, float right, float bottom, float top, float zNear, float zFar);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>二、透视投影：</strong></p><p>透视投影是符合人眼的效果，前面介绍的摄像机就替代了人眼的功能，可以看到物体间进大远小的效果。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250707182839172.png" alt="image-20250707182839172" style="zoom: 50%;" /><p>与正交投影一样，透视投影也有一个包裹盒，为了<strong>模仿人眼透视</strong>的功能实现<strong>近大远小</strong>的特点，这个包裹盒是一个<strong>锥体</strong>，叫做<strong>视锥体</strong>。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250707221330591.png" alt="image-20250707221330591" style="zoom: 50%;" /><p>视锥体也由六个参数控制：</p><ul><li>可视范围：near，far（表示和摄像机坐标原点的<strong>距离</strong>，均为<strong>正数</strong>）</li><li>近平面范围：left，right，top，bottom（表示了近平面可视区域的坐标范围，<strong>可正可负</strong>）</li></ul><p>和正交投影一样，透视投影也是要将摄像机坐标系转为NDC坐标系，所以要将锥体包裹盒缩放为长度为2的立方体。由于距离摄像机原点越远，可视平面越大，当远平面也缩放到[-1, 1]范围时，远处的顶点坐标必然会缩放更多，也就造成了进大远小的效果。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250707221928121.png" alt="image-20250707221928121" style="zoom:50%;" /><p>投影是沿z轴投影到xy平面，正交投影在投影时，x，y和z的值都不会变化。但是透视投影的包裹盒是一个锥体，在投影时远平面的坐标投影在近平面时x，y和z的值都会发生变化，不能简单的直接使用，要计算出远平面投影到近平面后的新坐标。</p><p>在glm库中我们可以使用perspective函数来创建投影变换矩阵perspectiveProjectionMatrix。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;为了方便使用，将参数简化为了四个来定义视锥体&#x2F;&#x2F;fov 是y方向的视张角，模拟人眼睁开的角度,角度越大看到的东西越多&#x2F;&#x2F;aspect 是近平面的横&#x2F;纵百分比，一般使用窗口的width&#x2F;height即可&#x2F;&#x2F;zNear 是近平面距离摄像机坐标系原点的距离（正数）&#x2F;&#x2F;zFar 是远平面距离摄像机坐标系原点的距离（正数）mat4 perspectiveProjectionMatrix &#x3D; perspective(float fov, float aspect, float zNear, float zFar);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250707235241817.png" alt="image-20250707235241817" style="zoom:50%;" /><p>知道了上述三种变换后，我们最终在vertexShader输出的顶点坐标是经过了完整的模型变换、视图变换和投影变换后的顶点。</p><pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl">gl_Position <span class="token operator">=</span> projectionMatrix <span class="token operator">*</span> viewMatrix <span class="token operator">*</span> modelMatrix <span class="token operator">*</span> aPos<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="相机系统"><a href="#相机系统" class="headerlink" title="相机系统"></a>相机系统</h2><p>了解了各种变换的原理，我们就可以使用glm提供的生成各个变换矩阵的功能函数创建我们的相机系统了。</p><h3 id="系统结构"><a href="#系统结构" class="headerlink" title="系统结构"></a>系统结构</h3><p>Camera是控制画面的显示的，而CameraControl是控制Camera移动、旋转和缩放等功能的。</p><p>由于投影共有透视投影和正交投影两种，所以派生出了两个子类PerspectiveCamera和OrthographicCamera，分别用来展示透视投影画面（2D）和正交投影画面（3D）。</p><p>相机的运动轨迹可以分为<strong>轨迹球</strong>方式和<strong>游戏</strong>方式，前者常在三维设计软件中见到，后者就是游戏中使用的方式，分别对应TraclBallControl和GameControl。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250709181840293.png" alt="image-20250709181840293" style="zoom:50%;" /><p>相机类包含了定义一个相机所必须的<strong>参数</strong>，以及获取<strong>视图变化矩阵</strong>（viewMatrix）和<strong>投影变换矩阵</strong>（projectionMatrix）的方法。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;-------------------------------------------------Camera.h文件，Camera类是所有相机的父类#pragma once#include &quot;..&#x2F;..&#x2F;glframework&#x2F;core.h&quot;class Camera&#123;public:Camera();~Camera();    &#x2F;&#x2F;两种相机获取视图矩阵的方式一致glm::mat4 getViewMatrix();    &#x2F;&#x2F;两种相机获取投影矩阵的方式不同，需要子类自己重写virtual glm::mat4 getProjectionMatrix();    &#x2F;&#x2F;两种相机缩放的方式不同，无法在相机控制类中统一控制缩放，写在父类中让子类重写virtual void scale(float deltaScale);public:    &#x2F;&#x2F;定义一个相机所必须的参数&#x2F;&#x2F;摄像机位置glm::vec3 mPosition&#123; 0.0f, 0.0f, 1.0f &#125;;&#x2F;&#x2F;摄像机本地坐标系的上方向(y轴)glm::vec3 mUp&#123; 0.0f, 1.0f, 0.0f &#125;;&#x2F;&#x2F;摄像机的右向量(摄像机坐标系的x轴)glm::vec3 mRight&#123; 1.0f, 0.0f, 0.0f &#125;;&#125;;&#x2F;&#x2F;-------------------------------------------------Camera.cpp文件，各种函数的实现#include &quot;camera.h&quot;Camera::Camera()&#123;&#125;Camera::~Camera()&#123;&#125;glm::mat4 Camera::getViewMatrix()&#123;glm::vec3 front &#x3D; glm::cross(mUp, mRight);glm::vec3 center &#x3D; mPosition + front;return glm::lookAt(mPosition, center, mUp);&#125;&#x2F;&#x2F;如果子类不重写，就默认返回一个单位矩阵，防止出错glm::mat4 Camera::getProjectionMatrix()&#123;return glm::identity&lt;glm::mat4&gt;();&#125;void Camera::scale(float deltaScale)&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;-------------------------------------------------orthographicCamera.h文件#pragma once#include &quot;..&#x2F;..&#x2F;glframework&#x2F;core.h&quot;#include &quot;camera.h&quot;class OrthographicCamera :public Camera&#123;public:OrthographicCamera(float left, float right, float top, float bottom, float near, float far);~OrthographicCamera();&#x2F;&#x2F;重写父类的获取投影矩阵函数glm::mat4 getProjectionMatrix()override;&#x2F;&#x2F;重写父类的缩放函数void scale(float deltaScale) override;private:    &#x2F;&#x2F;投影盒定义所需参数float mLeft &#x3D; 0.0f;float mRight &#x3D; 0.0f;float mTop &#x3D; 0.0f;float mBottom &#x3D; 0.0f;float mNear &#x3D; 0.0f;float mFar &#x3D; 0.0f;&#x2F;&#x2F;由于正交摄像机的缩放是对包裹盒的长和高进行缩放，需要变量记录当前的缩放级别&#x2F;&#x2F; 透视摄像机的缩放是向前向后移动摄像机实现的，不需要这个参数&#x2F;&#x2F;缩放程度 &#x3D; 2^mScalefloat mScale &#x3D; 0.0f;&#125;;&#x2F;&#x2F;-------------------------------------------------orthographicCamera.cpp文件，各种函数的实现和父类函数的重写#include &quot;orthographicCamera.h&quot;OrthographicCamera::OrthographicCamera(float left, float right, float top, float bottom, float near, float far):mLeft(left), mRight(right), mTop(top), mBottom(bottom), mNear(near), mFar(far)&#123;&#125;OrthographicCamera::~OrthographicCamera()&#123;&#125;glm::mat4 OrthographicCamera::getProjectionMatrix()&#123;    &#x2F;&#x2F;正交相机的缩放方式是改变投影盒的长和高float x &#x3D; glm::pow(2.0f, mScale);return glm::ortho(mLeft * x, mRight * x, mBottom * x, mTop * x, mNear, mFar);&#125;void OrthographicCamera::scale(float deltaScale)&#123;&#x2F;&#x2F;随着滚轮的滚动，缩放程度不断累加或累减mScale -&#x3D; deltaScale;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;-------------------------------------------------perspectiveCamera.h文件#pragma once#include &quot;..&#x2F;..&#x2F;glframework&#x2F;core.h&quot;#include &quot;camera.h&quot;class PerspectiveCamera :public Camera&#123;public:PerspectiveCamera(float fov, float aspect, float near, float far);~PerspectiveCamera();glm::mat4 getProjectionMatrix()override;void scale(float deltaScale) override;private:float mFov &#x3D; 0.0f;float mAspect &#x3D; 0.0f;float mNear &#x3D; 0.0f;float mFar &#x3D; 0.0f;&#125;;&#x2F;&#x2F;-------------------------------------------------perspectiveCamera.cpp文件，各种函数的实现和父类函数的重写#include &quot;perspectiveCamera.h&quot;PerspectiveCamera::PerspectiveCamera(float fov, float aspect, float near, float far):mFov(fov), mAspect(aspect), mNear(near), mFar(far)&#123;&#125;PerspectiveCamera::~PerspectiveCamera()&#123;&#125;glm::mat4 PerspectiveCamera::getProjectionMatrix()&#123;&#x2F;&#x2F;glm函数使用的角度都是弧度，我们传进来的都是角度，要用radians转换一下return glm::perspective(glm::radians(mFov), mAspect, mNear, mFar);&#125;void PerspectiveCamera::scale(float deltaScale)&#123;    &#x2F;&#x2F;透视投影相机的缩放方式就是向前移动相机glm::vec3 front &#x3D; glm::cross(mUp, mRight);mPosition +&#x3D; deltaScale * front;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相机控制类负责<strong>控制相机的运动</strong>，<strong>响应键盘事件</strong>，每当某个事件触发时，该类会根据键鼠操作及时<strong>更新相机的参数</strong>，相机就会用最新的参数创建视图变换矩阵和投影变换矩阵。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;-------------------------------------------------cameraControl.h文件，定义各种事件响应函数来更新相机的参数#pragma once#include &quot;..&#x2F;..&#x2F;glframework&#x2F;core.h&quot;#include &quot;camera.h&quot;#include &lt;map&gt;class CameraControl&#123;public:CameraControl();~CameraControl();&#x2F;&#x2F;如果子类重写就用子类的，不重写就用父类默认统一的virtual void onKey(int key, int action, int mods);virtual void onMouse(int button, int action, double xPos, double yPos);virtual void onCursor(double xPos, double yPos);virtual void onScroll(double xOff, double yOff);void update();void setCamera(Camera* camera) &#123; mCamera &#x3D; camera; &#125;protected:&#x2F;&#x2F;控制的相机Camera* mCamera &#x3D; nullptr;&#x2F;&#x2F;鼠标按键状态(记录鼠标左键、右键和中键是否被按下)bool mMouseLeftDown &#x3D; false;bool mMouseRightDown &#x3D; false;bool mMouseMiddleDown &#x3D; false;&#x2F;&#x2F;鼠标光标当前位置float mCurrentX &#x3D; 0.0f, mCurrentY &#x3D; 0.0f;&#x2F;&#x2F;相机旋转灵敏度float mSensitivity &#x3D; 0.2f;&#x2F;&#x2F;相机平移速度float mMoveSpeed &#x3D; 0.005f;&#x2F;&#x2F;记录键盘相关按键状态std::map&lt;int, bool&gt; mKeyMap;&#125;;&#x2F;&#x2F;-------------------------------------------------cameraControl.cpp文件，实现各种函数#include &quot;cameraControl.h&quot;#include &lt;iostream&gt;CameraControl::CameraControl()&#123;&#125;CameraControl::~CameraControl()&#123;&#125;void CameraControl::onKey(int key, int action, int mods)&#123;&#x2F;&#x2F;只记录第一次按下键的时候，重复按时不考虑，直接退出if (action &#x3D;&#x3D; GLFW_REPEAT)return;&#x2F;&#x2F;记录当前按键是按下状态还是释放状态bool pressrd &#x3D; (action &#x3D;&#x3D; GLFW_PRESS);mKeyMap[key] &#x3D; pressrd;&#125;void CameraControl::onMouse(int button, int action, double xPos, double yPos)&#123;&#x2F;&#x2F;如果按下鼠标按键，记录此时的光标位置bool pressed &#x3D; (action &#x3D;&#x3D; GLFW_PRESS);if (pressed)&#123;mCurrentX &#x3D; xPos;mCurrentY &#x3D; yPos;&#125;&#x2F;&#x2F;更新鼠标按键状态switch (button)&#123;case GLFW_MOUSE_BUTTON_LEFT:mMouseLeftDown &#x3D; pressed;break;case GLFW_MOUSE_BUTTON_RIGHT:mMouseRightDown &#x3D; pressed;break;case GLFW_MOUSE_BUTTON_MIDDLE:mMouseMiddleDown &#x3D; pressed;break;&#125;&#125;void CameraControl::onCursor(double xPos, double yPos)&#123;&#125;void CameraControl::onScroll(double xOff, double yOff)&#123;&#125;void CameraControl::update()&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="TrackBallCameraController（轨迹球相机控制器）"><a href="#TrackBallCameraController（轨迹球相机控制器）" class="headerlink" title="TrackBallCameraController（轨迹球相机控制器）"></a>TrackBallCameraController（轨迹球相机控制器）</h3><p>用户通过鼠标拖拽（类似在虚拟球面上滑动）来控制相机的旋转，适合自由观察3D物体或场景，在建模软件中经常可以看到这样的移动方式。</p><p>这样的实现方式是将相机锁定在一个半径固定的球面上运动，相机始终看向某一个点（一般是原点）。当我们使用鼠标移动时，将鼠标移动的距离转化为相机在对应方向旋转的角度，创建出一个旋转矩阵，对相机的各个参数进行调整。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250709164225962.png" alt="image-20250709164225962" style="zoom:40%;" /><p>对于相机任意的移动，我们可以将其分解为左右沿纬线运动和上下沿经线运动。</p><p>绕着纬线<strong>左右运动</strong>是绕着<strong>世界坐标系的y轴</strong>旋转的，产生的角度叫做<strong>yaw</strong>角（类似人眼左右移动）。当相机绕着球面左右运动时，相机的<strong>position</strong>(位置)、<strong>up</strong>(相机本地坐标系的y轴)、<strong>right</strong>(相机本坐标系的x轴)参数都会<strong>发生变化</strong>，所以左右移动时需要更新这<strong>三</strong>个参数。</p><p>绕着经线<strong>上下运动</strong>是绕着<strong>摄像机本地坐标系的x轴</strong>旋转的，产生的角度叫做<strong>pitch</strong>角（类似人眼上下移动）。当相机绕着球面左右运动时，相机的<strong>position</strong>(位置)、<strong>up</strong>(相机本地坐标系的y轴)参数都会<strong>发生变化</strong>，所以上下移动时需要更新这<strong>两</strong>个参数。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250709165319540.png" alt="image-20250709165319540" style="zoom:50%;" /><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;-------------------------------------------------trackBallCameraControl.h文件#pragma once#include &quot;..&#x2F;..&#x2F;glframework&#x2F;core.h&quot;#include &quot;cameraControl.h&quot;class TrackBallCameraControl:public CameraControl&#123;public:TrackBallCameraControl();~TrackBallCameraControl();void onCursor(double xPos, double yPos) override;&#x2F;&#x2F;trackBall相机常用于设计软件中，需要滚轮缩放&#x2F;&#x2F;game相机一般用于游戏，不需要提供滚轮缩放功能void onScroll(double xOff, double yOff) override;private:void yaw(float angle);void pitch(float angle);private:&#x2F;&#x2F;相机缩放速度float mScaleSpeed &#x3D; 0.2f;&#125;;&#x2F;&#x2F;-------------------------------------------------trackBallCameraControl.cpp文件，实现各种函数#include &quot;trackBallCameraControl.h&quot;TrackBallCameraControl::TrackBallCameraControl()&#123;&#125;TrackBallCameraControl::~TrackBallCameraControl()&#123;&#125;void TrackBallCameraControl::onCursor(double xPos, double yPos)&#123;if (mMouseLeftDown)&#123;&#x2F;&#x2F;计算两个方向移动的旋转角度float deltaX &#x3D; (mCurrentX - xPos) * mSensitivity;float deltaY &#x3D; (mCurrentY - yPos) * mSensitivity;&#x2F;&#x2F;分别计算两个方向的旋转yaw(deltaX);pitch(deltaY);&#125;else if (mMouseMiddleDown)&#123;float deltaX &#x3D; (mCurrentX - xPos) * mMoveSpeed;float deltaY &#x3D; (mCurrentY - yPos) * mMoveSpeed;mCamera-&gt;mPosition +&#x3D; deltaX * mCamera-&gt;mRight;mCamera-&gt;mPosition +&#x3D; -deltaY * mCamera-&gt;mUp;&#125;mCurrentX &#x3D; xPos;mCurrentY &#x3D; yPos;&#125;void TrackBallCameraControl::onScroll(double xOff, double yOff)&#123;mCamera-&gt;scale(mScaleSpeed * yOff);&#125;&#x2F;&#x2F;因为每次旋转后新参数都保存到了相机里，所以这是一个增量式的改变&#x2F;&#x2F;更新左右移动时变化的参数void TrackBallCameraControl::yaw(float angle)&#123;&#x2F;&#x2F;根据旋转角度绕世界坐标系的y轴旋转，创造旋转矩阵glm::mat4 rotation &#x3D; glm::rotate(glm::identity&lt;glm::mat4&gt;(), (float)glm::radians(angle), glm::vec3(0.0f, 1.0f, 0.0f));&#x2F;&#x2F;更新参数(相机旋转时本地坐标轴和位置也做同等旋转)mCamera-&gt;mPosition &#x3D; rotation * glm::vec4(mCamera-&gt;mPosition, 1.0f);mCamera-&gt;mUp &#x3D; rotation * glm::vec4(mCamera-&gt;mUp, 0.0f);mCamera-&gt;mRight &#x3D; rotation * glm::vec4(mCamera-&gt;mRight, 0.0f);&#125;&#x2F;&#x2F;更新上下移动时变化的参数void TrackBallCameraControl::pitch(float angle)&#123;&#x2F;&#x2F;根据旋转角度绕本地坐标系的x轴旋转，创造旋转矩阵glm::mat4 rotation &#x3D; glm::rotate(glm::identity&lt;glm::mat4&gt;(), (float)glm::radians(angle), mCamera-&gt;mRight);&#x2F;&#x2F;更新参数(上下移动时产生的旋转，不改变本地坐标系的x轴，故不用更新right向量)mCamera-&gt;mPosition &#x3D; rotation * glm::vec4(mCamera-&gt;mPosition, 1.0f);mCamera-&gt;mUp &#x3D; rotation * glm::vec4(mCamera-&gt;mUp, 0.0f);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="GameCameraController（游戏相机控制器）"><a href="#GameCameraController（游戏相机控制器）" class="headerlink" title="GameCameraController（游戏相机控制器）"></a>GameCameraController（游戏相机控制器）</h3><p>游戏相机控制器可以类比第一人称游戏，可以使用WASD键进行前后左右移动，按下鼠标右键时可以转动视角。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250709214146965.png" alt="image-20250709214146965" style="zoom:50%;" /><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;-------------------------------------------------gameCameraControl.h文件#pragma once#include &quot;..&#x2F;..&#x2F;glframework&#x2F;core.h&quot;#include &quot;cameraControl.h&quot;class GameCameraControl:public CameraControl&#123;public:GameCameraControl();~GameCameraControl();void onKey(int key, int action, int mods) override;void onCursor(double xPos, double yPos) override;private:&#x2F;&#x2F;pitch是控制上下角度的，范围是[-90,90]float mPitch &#x3D; 0.0f;float mSpeed &#x3D; 0.02f;private:void pitch(float angle);void yaw(float angle);&#125;;&#x2F;&#x2F;-------------------------------------------------gameCameraControl.cpp文件#include &quot;gameCameraControl.h&quot;GameCameraControl::GameCameraControl()&#123;&#125;GameCameraControl::~GameCameraControl()&#123;&#125;&#x2F;&#x2F;控制移动void GameCameraControl::onKey(int key, int action, int mods)&#123;    &#x2F;&#x2F;因为重写了父类函数，需要先调用父类的函数获取按键状态CameraControl::onKey(key, action, mods);    &#x2F;&#x2F;考虑到会同时按下多个按键移动，使用direction作为最终的方向，按下哪个键就叠加对应的方向glm::vec3 direction(0.0f);glm::vec3 front &#x3D; glm::cross(mCamera-&gt;mUp, mCamera-&gt;mRight);glm::vec3 right &#x3D; mCamera-&gt;mRight;&#x2F;&#x2F;同时按下多键，叠加最终方向if (mKeyMap[GLFW_KEY_W])&#123;direction +&#x3D; front;&#125;if (mKeyMap[GLFW_KEY_S])&#123;direction -&#x3D; front;&#125;if (mKeyMap[GLFW_KEY_A])&#123;direction -&#x3D; right;&#125;if (mKeyMap[GLFW_KEY_D])&#123;direction +&#x3D; right;&#125;if (mKeyMap[GLFW_KEY_SPACE])&#123;direction +&#x3D; glm::vec3(0.0f, 1.0f, 0.0f);&#125;if (mKeyMap[GLFW_KEY_LEFT_SHIFT])&#123;direction -&#x3D; glm::vec3(0.0f, 1.0f, 0.0f);&#125;&#x2F;&#x2F;只有非零向量才可以归一化，否则会出错if (glm::length(direction) &#x3D;&#x3D; 0)return;&#x2F;&#x2F;单位向量叠加后的长度不为1，要归一化后再运算mCamera-&gt;mPosition +&#x3D; glm::normalize(direction) * mSpeed;&#125;&#x2F;&#x2F;控制旋转void GameCameraControl::onCursor(double xPos, double yPos)&#123;if (mMouseRightDown)&#123;float deltaX &#x3D; (mCurrentX - xPos) * mSensitivity;float deltaY &#x3D; (mCurrentY - yPos) * mSensitivity;mPitch +&#x3D; deltaY;&#x2F;&#x2F;控制pitch角度的范围（-90，90）if (mPitch &gt; 89.0f || mPitch &lt; -89.0f)&#123;&#x2F;&#x2F;加上此时的角度为不合法，此时需要再减去这个角度撤回累加mPitch -&#x3D; deltaY;pitch(0);&#125;elsepitch(deltaY);yaw(deltaX);&#125;mCurrentX &#x3D; xPos;mCurrentY &#x3D; yPos;&#125;void GameCameraControl::pitch(float angle)&#123;&#x2F;&#x2F;根据旋转角度绕世界坐标系的y轴旋转，创造旋转矩阵glm::mat4 rotation &#x3D; glm::rotate(glm::identity&lt;glm::mat4&gt;(), (float)glm::radians(angle), mCamera-&gt;mRight);&#x2F;&#x2F;更新参数(相机旋转时本地坐标轴和位置也做同等旋转)mCamera-&gt;mUp &#x3D; rotation * glm::vec4(mCamera-&gt;mUp, 0.0f);&#125;void GameCameraControl::yaw(float angle)&#123;&#x2F;&#x2F;根据旋转角度绕世界坐标系的y轴旋转，创造旋转矩阵glm::mat4 rotation &#x3D; glm::rotate(glm::identity&lt;glm::mat4&gt;(), (float)glm::radians(angle), glm::vec3(0.f, 1.0f, 0.0f));&#x2F;&#x2F;更新参数(相机旋转时本地坐标轴和位置也做同等旋转)mCamera-&gt;mRight &#x3D; rotation * glm::vec4(mCamera-&gt;mRight, 0.0f);mCamera-&gt;mUp &#x3D; rotation * glm::vec4(mCamera-&gt;mUp, 0.0f);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="深度检测"><a href="#深度检测" class="headerlink" title="深度检测"></a>深度检测</h2><p>opengl中默认使用的绘制算法是<strong>画家算法</strong>，就像画画一样，先绘制的会被后绘制的遮挡住。这里的遮挡关系只和物体的绘制顺序有关，和距离摄像机远近没有关系。</p><p>在3维世界中，同一个地点，必然是距离摄像机近的物体会遮盖住距离摄像机远的物体。</p><p>就像下图所示，右边的三角形Z值为-1，左边的三角形Z值为0，在两个三角形重叠部分，应该是距离我们更近的左侧三角形露出来，但是却被右边的三角形遮盖住了，这显然是不合理的。之所以会出现这样的情况，是我们使用的是opengl默认的画家算法，右侧三角形是后绘制的，所以才遮盖住了左侧的三角形。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250709222709081.png" alt="image-20250709222709081" style="zoom:50%;" /><h3 id="深度值"><a href="#深度值" class="headerlink" title="深度值"></a>深度值</h3><p>为了解决这个问题，我们需要知道每个点距离摄像机的远近，这个值在opengl中叫做<strong>深度值</strong>(Depth)：表示当前绘制的Fragment（片元）<strong>距离相机的远近程度</strong>。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250709224250490.png" alt="image-20250709224250490" style="zoom:50%;" /><h3 id="深度值插值"><a href="#深度值插值" class="headerlink" title="深度值插值"></a>深度值插值</h3><p>我们得到了每个顶点的深度值后，需要进行插值计算出所有片元的深度值。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250709224516084.png" alt="image-20250709224516084" style="zoom:50%;" /><h3 id="深度值检测"><a href="#深度值检测" class="headerlink" title="深度值检测"></a>深度值检测</h3><p>创建一块和屏幕大小一样的缓存，存储每个像素的深度值。如果当前像素的深度值比缓存中的大，那么用新的颜色填充这个像素，同时更新该像素块的最小深度值。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250709225020623.png" alt="image-20250709225020623" style="zoom:50%;" /><p>下面就是深度检测算法（Z-buffer算法）的伪代码：</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20240118132918032.png" alt="image-20240118132918032" style="zoom: 50%;" /><h3 id="在opengl中开启和配置深度检测"><a href="#在opengl中开启和配置深度检测" class="headerlink" title="在opengl中开启和配置深度检测"></a>在opengl中开启和配置深度检测</h3><p>glEnable和glDisable函数允许我们启用或禁用某个OpenGL功能。这个功能会一直保持启用&#x2F;禁用状态，直到另一个调用来禁用&#x2F;启用它。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;1. 使用glEnable函数开启opengl的深度测试功能glEnable(GL_DEPTH_TEST);&#x2F;&#x2F;2. 设置深度测试方法(满足什么要求的片元才算通过深度测试)&#x2F;&#x2F;策略有很多,GL_LESS就是上面介绍的深度值小的片元才能通过测试glDepthFunc(GL_LESS);&#x2F;&#x2F;3. 在每一帧清理画布颜色时也要清理深度缓存(默认将深度缓冲清理为1.0)glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);&#x2F;&#x2F;也可以使用这个函数指定清理深度缓冲时设置的值glCLearDepth(float val);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250709225839392.png" alt="image-20250709225839392" style="zoom:50%;" /><h3 id="控制深度值写入权限"><a href="#控制深度值写入权限" class="headerlink" title="控制深度值写入权限"></a>控制深度值写入权限</h3><p><strong>glDepthMask(GLboolean flag)</strong> 是 OpenGL 中用于控制深度缓冲区（Depth Buffer）写入状态的函数，它决定是否允许将片元（Fragment）的深度值写入深度缓冲区。</p><ul><li>当设置<strong>glDepthMask(GL_TRUE)<strong>时，此时是</strong>允许</strong>片元的深度值<strong>写入深度缓冲</strong>，是一般情况下的默认状态。</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;允许写入深度缓冲&#x2F;&#x2F;1.判断当前片元深度值是否小于此处深度缓冲区存入的深度值if (z &lt; z-buffer[x,y,z])&#123;    &#x2F;&#x2F;2.如果深度值更小，这个像素的颜色变为该片元的颜色    frameBuffer[x,y,z] &#x3D; rgb;    &#x2F;&#x2F;3.将该片元的更小的深度值存入深度缓冲区    z-buffer[x,y,z] &#x3D; z;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>当设置<strong>glDepthMask(GL_FALSE)<strong>时，此时是</strong>不允许</strong>片元的深度值<strong>写入深度缓冲</strong>。此时即使调用glClear( GL_DEPTH_BUFFER_BIT)函数也无法将深度缓冲区的值重置为1，因为当前深度缓存区已经禁止写入了。</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;不允许写入深度缓冲&#x2F;&#x2F;1.判断当前片元深度值是否小于此处深度缓冲区存入的深度值if (z &lt; z-buffer[x,y,z])&#123;    &#x2F;&#x2F;2.如果深度值更小，这个像素的颜色变为该片元的颜色    frameBuffer[x,y,z] &#x3D; rgb;    &#x2F;&#x2F;不允许写入深度缓冲区将不会有这一步    &#x2F;&#x2F;z-buffer[x,y,z] &#x3D; z;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下图左边是构建的测试场景，此时默认是允许写入深度缓冲区的，三个平面的遮盖关系可以正常显示。</p><p>下图右则是绘制<strong>box_specular</strong>时设置<strong>glDepthMask(GL_FALSE)</strong>，另外两个都是glDepthMask(GL_TRUE)，可以看到原先笑脸被遮盖住的部分全部都绘制出来了。这是因为在绘制box_specular时并没有写入深度缓存，所以二者重叠的部分深度缓存区的值仍然为1（或者其他表示无穷大的值）；当绘制笑脸时进行深度值比较时会直接和1比较，自然会显示出。（一般这种效果常常用来绘制透明物体）。</p><p>​                                      <img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250720202457242.png" alt="image-20250720202457242" style="zoom: 50%; display: inline;" /><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250720202704709.png" alt="image-20250720202704709" style="zoom:50%;display: inline;" /></p><h3 id="zFighting（深度冲突）"><a href="#zFighting（深度冲突）" class="headerlink" title="zFighting（深度冲突）"></a>zFighting（深度冲突）</h3><p>Z-Fighting（深度冲突）是计算机图形学中一种常见的渲染问题，表现为两个或多个表面在深度缓冲区（Z-Buffer）中具有<strong>非常接近或相同的深度值</strong>，导致GPU在深度测试时无法确定哪个表面应该被渲染，最终产生闪烁或交替覆盖的视觉瑕疵。</p><p>下图中两个平面之间的z轴距离仅为0.0000001个单位距离，当两个物体<strong>过于靠近</strong>时，由于计算机中浮点数<strong>精度有限</strong>，会导致深度缓存区对应两者深度值的比较出现问题，进而产生交替覆盖的现象。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250720204846469.png" alt="image-20250720204846469" style="zoom:50%;" /><p>为了解决这一问题，我们可以使用<strong>更高的精度来处理深度缓存区的数据</strong>或者将<strong>两个物体的深度值进行调整让他们靠的不那么近</strong>。前者显然治标不治本，后者就可以使用opengl提供的<strong>polygonOffset</strong>函数实现。</p><p>polygonOffset函数<strong>只调整物体的深度值</strong>，但是并<strong>不改变物体的位置</strong>。（zFighting问题的本质就是物体的深度值太过接近无法精准判断，将深度值拉开差距即可）。</p><p>和深度测试一样，需要先使用glEnable开启该功能，在调用polygonOffset函数具体调整。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250720205851884.png" alt="image-20250720205851884" style="zoom:50%;" /><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250720205820673.png" alt="image-20250720205820673" style="zoom:50%;" /><p>造成zFighting现象的会有两种情况：</p><ol><li>两个正常物体<strong>距离太过接近</strong>而产生zFighting现象</li><li>两个物体距离正常，但是会随着<strong>倾斜</strong>产生zFighting现象</li></ol><p>所以polygonOffset的第一个参数主要是为了解决倾斜问题的，第二个参数主要为了解决情况1的。</p><ul><li>当物体靠太近时，我们可以调整物体的深度值。但是当场景中的物体非常多时，对物体深度值的调整有可能会造成其他物体产生zFighting现象。所以对物体深度值的调整要尽可能的小，所以参数<strong>units要和数据最小值相乘，最小限度地调整深度值</strong>。</li><li>对于倾斜产生的zFighting现象，由深度值和z坐标的关系可知：距离镜头远的部分深度变换不明显，更容易产生zFighting现象，近处则不容易产生。所以可以将远处的部分多偏移一些，近处的部分少偏移一些就能解决这一问题。</li></ul><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250720211158975.png" alt="image-20250720211158975" style="zoom:50%;" /><p>对于两个像素而言，倾斜放倒后，两个像素之间的深度值变化率较大（初始在一个平面，放倒后产生较大的深度值差距，且像素间的距离由于进大远小而缩小），距离镜头近的部分像素间深度变化率较小，于是就能根据深度变化率判断像素距离摄像机远近。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250720211820440.png" alt="image-20250720211820440" style="zoom:50%;" /><h1 id="OpenGL中级"><a href="#OpenGL中级" class="headerlink" title="OpenGL中级"></a>OpenGL中级</h1><h2 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h2><h2 id="光照"><a href="#光照" class="headerlink" title="光照"></a>光照</h2><p>在介绍光照之前，先简单说明一下颜色。对应<strong>光</strong>来说，颜色表示红绿蓝三种<strong>光的强度</strong>，对于一个<strong>物体</strong>来说，颜色表示对红绿蓝三种光的<strong>反射百分比</strong>。</p><p>所以<strong>反射光的颜色 &#x3D; 光照颜色 * 物体颜色</strong>（因为人眼之所以能看到物体，就是靠反射光线进入人眼）。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250710210728390.png" alt="image-20250710210728390" style="zoom:50%;" /><h3 id="光照类型"><a href="#光照类型" class="headerlink" title="光照类型"></a>光照类型</h3><h4 id="漫反射光（diffuse）"><a href="#漫反射光（diffuse）" class="headerlink" title="漫反射光（diffuse）"></a>漫反射光（diffuse）</h4><p>漫反射是光从一定角度入射之后从入射点向四面八方反射，且每个不同方向反射的光的强度相等，而产生漫反射的原因是物体表面的粗糙，光线照射到粗糙表面后向<strong>各个方向均匀散射</strong>。从任何角度看亮度相同，与<strong>视线方向无关</strong>。</p><p>漫反射光是光线照射在物体身上后经过一次反射的光，漫反射光会使物体在光线下产生立体感。因为在计算漫反射光时，只需考虑光照方向和该点的法线方向即可，所以物体的不同区域由于跟光线角度不同，会出现明暗区域的平滑过渡，这种明亮变化就能是人看到立体感。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250710212933232.png" alt="image-20250710212933232" style="zoom:50%;" /><p>下面介绍一下漫反射光的计算：</p><p>光的反射可以理解为光照射在物体表面，物体表面吸收部分光能后释放出去的过程（物体颜色的本质就是物体吸收光能后释放出去的百分比）。为此我们需要计算出一束光照射在物体表面时，物体能吸收多少光。</p><p>物体吸收光的多少与其接收到光照的面积有关，当物体表面倾斜一定角度时，需要计算表面面积的投影。</p><p>如下图所示，对于一格像素来说，当表面与光线倾角为theat时，吸收的光为<strong>power &#x3D; light * cos(theta)</strong>。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250710215752130.png" alt="image-20250710215752130" style="zoom:40%;" /><p>计算出吸收的光后，根据颜色就是物体反射光的百分比这一结论可知，最终反射出去的光为<strong>out &#x3D; power * objectColor</strong>。</p><p>所以最终漫反射的反射光颜色为<strong>diffuseColor &#x3D; lightColor * cos(θ) * objectColor</strong>。</p><p>还有一个问题就是我们如何计算倾角theta？</p><p>只要知道了物体表面一点的<strong>法线向量</strong>（normal），我们就能根据法线向量和光线方向两个向量计算出夹角theta。法线向量需要作为每一个顶点的顶点属性给出，这样所有像素的法线向量都会经过插值算法自动计算出来。</p><p>当法线向量和光线方向向量都是归一化的向量后，就可以利用向量点乘公式直接计算出<strong>cos(theta) &#x3D; dot(-lightDir, normal)</strong>。</p><p>因为光线方向是从光源指向物体表面的，所以要正确计算出theta角，需要使用光线方向的反方向，如下图所示。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250710220204952.png" alt="image-20250710220204952" style="zoom:40%;" /><pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">460</span> core</span></span><span class="token keyword">out</span> <span class="token keyword">vec4</span> FragColor<span class="token punctuation">;</span><span class="token keyword">in</span> <span class="token keyword">vec2</span> uv<span class="token punctuation">;</span><span class="token comment">//接收法线向量</span><span class="token keyword">in</span> <span class="token keyword">vec3</span> normal<span class="token punctuation">;</span><span class="token keyword">uniform</span> <span class="token keyword">sampler2D</span> sampler<span class="token punctuation">;</span><span class="token comment">//使用代码设置平行光的参数</span><span class="token keyword">uniform</span> <span class="token keyword">vec3</span> lightDirection<span class="token punctuation">;</span><span class="token keyword">uniform</span> <span class="token keyword">vec3</span> lightColor<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//1. 对数据进行归一化</span><span class="token keyword">vec3</span> normalN <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>normal<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">vec3</span> lightDirectionN <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>lightDirection<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//2. 获取该点颜色(shader中不允许将四维向量赋值给三维向量)</span><span class="token keyword">vec3</span> objColor <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>sampler<span class="token punctuation">,</span> uv<span class="token punctuation">)</span><span class="token punctuation">.</span>xyz<span class="token punctuation">;</span><span class="token comment">//3. 计算光线和法向量之间的夹角余弦值(颜色不能出现负数，要使用clamp函数控制在0到1之间)</span><span class="token keyword">float</span> cosTheta <span class="token operator">=</span> <span class="token function">clamp</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span><span class="token operator">-</span>lightDirectionN<span class="token punctuation">,</span> normalN<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//4. 计算漫反射光颜色(lightColor * cosTheta)表示该点吸收了多少光，再乘以objColor表示反射了多少光，就是最终反射光的颜色</span><span class="token keyword">vec3</span> diffuse <span class="token operator">=</span> lightColor <span class="token operator">*</span> cosTheta <span class="token operator">*</span> objColor<span class="token punctuation">;</span><span class="token comment">//返回最终的颜色</span>FragColor <span class="token operator">=</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span>diffuse<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="镜面反射光（specular）"><a href="#镜面反射光（specular）" class="headerlink" title="镜面反射光（specular）"></a>镜面反射光（specular）</h4><p>对于一个表面光滑的物体来说，当<strong>反射光</strong>的光线和<strong>人眼</strong>观看方向接近时，会产生刺眼的<strong>高光斑点</strong>，叫做镜面反射光。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250710213413431.png" alt="image-20250710213413431" style="zoom:67%;" /><p>最终我们将三种光照叠加到一起，就模拟出了物体的光照情况。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250710213513238.png" alt="image-20250710213513238" style="zoom:50%;" /><p>当一束光照射在光滑物体表面时，由物理知识可知，光线会被反射回去，且入射角等于反射角。由于表面光滑，光线并不会像漫反射那样均匀地向四面八方反射，而是主要集中在反射方向上（因为不存在绝对光滑，所以不可能只向一个方向反射，所以在不同的方向观察都能或多或少看见高光）。</p><p>当人眼朝不同的方向朝该点看去，视线方向和反射方向之间会有一个夹角，夹角越小就说明反射光的方向越解决人眼，所以此时产生的高光也更强。于是我们可以使用<strong>视线方向</strong>和<strong>反射方向</strong>之间的<strong>夹角</strong>来作为<strong>衡量高光大小的标准</strong>。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250711162255618.png" alt="image-20250711162255618" style="zoom:50%;" /><p>为了计算镜面反射光，我们除了需要知道<strong>光照方向</strong>和<strong>法线</strong>，还需要知道此时的<strong>视线方向</strong>。</p><p>为了求出视线方向，我们需要知道每个<strong>像素的世界坐标位置</strong>和<strong>摄像机的世界坐标位置</strong>，前者在shader中就可以拿到，后者需要使用代码赋值到shader的uniform变量中。</p><pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token comment">//-------------------------------------------------------------vs</span><span class="token comment">//1. 为了获取每个像素的世界坐标位置，我们要把vertexShader拿到的坐标经过模型变换后传递给fragmentShader中</span><span class="token keyword">layout</span><span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token keyword">vec3</span> aPosition<span class="token punctuation">;</span><span class="token keyword">uniform</span> <span class="token keyword">mat4</span> model<span class="token punctuation">;</span><span class="token keyword">uniform</span> <span class="token keyword">mat4</span> view<span class="token punctuation">;</span><span class="token keyword">uniform</span> <span class="token keyword">mat4</span> projection<span class="token punctuation">;</span><span class="token keyword">out</span> <span class="token keyword">vec3</span> worldPosition<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">vec4</span> position <span class="token operator">=</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span>aPosition<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//计算当前顶点的世界坐标，并传递给fragmentShader</span>worldPosition <span class="token operator">=</span> <span class="token punctuation">(</span>model <span class="token operator">*</span> position<span class="token punctuation">)</span><span class="token punctuation">.</span>xyz<span class="token punctuation">;</span>gl_Position <span class="token operator">=</span> projection <span class="token operator">*</span> view <span class="token operator">*</span> model <span class="token operator">*</span> position<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//-------------------------------------------------------------fs</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">460</span> core</span></span><span class="token keyword">out</span> <span class="token keyword">vec4</span> FragColor<span class="token punctuation">;</span><span class="token keyword">in</span> <span class="token keyword">vec2</span> uv<span class="token punctuation">;</span><span class="token keyword">in</span> <span class="token keyword">vec3</span> normal<span class="token punctuation">;</span><span class="token comment">//2. 接收vertexShader中传来的像素世界坐标</span><span class="token keyword">in</span> <span class="token keyword">vec3</span> worldPosition<span class="token punctuation">;</span><span class="token keyword">uniform</span> <span class="token keyword">sampler2D</span> sampler<span class="token punctuation">;</span><span class="token keyword">uniform</span> <span class="token keyword">vec3</span> lightDirection<span class="token punctuation">;</span><span class="token keyword">uniform</span> <span class="token keyword">vec3</span> lightColor<span class="token punctuation">;</span><span class="token comment">//2. 为了获取摄像机的世界坐标系，需要在fragmentShader中设置uniform变量接收摄像机的坐标</span><span class="token keyword">uniform</span> <span class="token keyword">vec3</span> cameraPosition<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//归一化</span><span class="token keyword">vec3</span> normalN <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>normal<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">vec3</span> lightDirectionN <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>lightDirection<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//采样该点颜色(shader中不允许将四维向量赋值给三维向量)</span><span class="token keyword">vec3</span> objColor <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>sampler<span class="token punctuation">,</span> uv<span class="token punctuation">)</span><span class="token punctuation">.</span>xyz<span class="token punctuation">;</span><span class="token comment">//计算漫反射光</span><span class="token comment">//计算光线和法向量之间的夹角余弦值(颜色不能出现负数，要控制在0到1之间)</span><span class="token keyword">float</span> diffuse <span class="token operator">=</span> <span class="token function">clamp</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span><span class="token operator">-</span>lightDirectionN<span class="token punctuation">,</span> normalN<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//(lightColor * diffuse)表示该点吸收了多少光，再乘以objColor表示反射了多少光，就是最终反射光的颜色</span><span class="token keyword">vec3</span> diffuseColor <span class="token operator">=</span> lightColor <span class="token operator">*</span> diffuse <span class="token operator">*</span> objColor<span class="token punctuation">;</span><span class="token comment">//计算镜面反射光</span><span class="token comment">//3. 计算视线方向(像素坐标-相机坐标)</span><span class="token keyword">vec3</span> viewDirection <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>worldPosition <span class="token operator">-</span> cameraPosition<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//4. 计算反射光方向(reflect输入光照方向和法线方向会输出反射方向)</span><span class="token keyword">vec3</span> reflectDirection <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span><span class="token function">reflect</span><span class="token punctuation">(</span>lightDirectionN<span class="token punctuation">,</span> normalN<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//5. 计算镜面反射光颜色</span><span class="token keyword">float</span> specular <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span><span class="token operator">-</span>viewDirection<span class="token punctuation">,</span> reflectDirection<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">vec3</span> specularColor <span class="token operator">=</span> lightColor <span class="token operator">*</span> specular<span class="token punctuation">;</span><span class="token comment">//使用texture函数选择一个采样器在指定uv坐标上采样，获取一个四维向量(rgba)</span>FragColor <span class="token operator">=</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span>diffuseColor <span class="token operator">+</span> specularColor<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果直接使用上面的代码，会出现一个问题。上面代码的光照方向为斜45度照向左下角的平行光，所以立方体的左下角会因为照射不到光照而变成黑色，但是在移动过程中会发现黑色阴影处出现了反射高光，这显然是不合理的。</p><p>这是因为我们计算时并未判断光照方向是从物体正面照射来的还是反面照射来的，而是直接将光照方向和反射光方向进行计算，导致阴影处出现高光。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250711173252647.png" alt="image-20250711173252647" style="zoom:33%;" /><p>通过观察可以发现，如果光照方向是从背面照射到该点，那么光照方向的反方向和法线的夹角是一个钝角，可以利用这一点在shader中进行判断，从而提出背面的反射高光。</p><p>在shader中使用if else语句会损失性能，所以使用<strong>step</strong>函数实现判断功能。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250711172720468.png" alt="image-20250711172720468" style="zoom:50%;" /><pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token comment">//处理背面高光线性</span><span class="token keyword">float</span> flag <span class="token operator">=</span> <span class="token function">step</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token function">dot</span><span class="token punctuation">(</span><span class="token operator">-</span>lightDirectionN<span class="token punctuation">,</span> normalN<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用texture函数选择一个采样器在指定uv坐标上采样，获取一个四维向量(rgba)</span>FragColor <span class="token operator">=</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span>diffuse <span class="token operator">+</span> specular <span class="token operator">*</span> flag<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加代码后背面的高光就会被消除了。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250711173649961.png" alt="image-20250711173649961" style="zoom: 50%;" /><p>通过上面的演示图可以看到，我们的镜面反射光有时会将高光铺满整个立方体面，着显然是不太合理的，我们希望看到的是一小块区域更集中的高光光斑。</p><p>代码中控制高光的是<strong>max(dot(-viewDirection, reflectDirection), 0.0)</strong>，其大致函数曲线大致形状类似于<strong>cos</strong>函数曲线。在曲线中我们可以看到，随着<strong>夹角的增大</strong>虽然<strong>值会变小</strong>，但是值<strong>不为0</strong>还是会<strong>出现高光</strong>，这就导致我们的高光范围比较大，不集中。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250711174907035.png" alt="image-20250711174907035" style="zoom:50%;" /><p>如果我们为这个函数加上一个指数，变成y &#x3D; a^x形式，由于取值范围是0到1，所以函数图形会随着指数的增大而变得更瘦，这就会让我们的高光变得更近集中，只会在看向点的附近出现集中的高光。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250711175326221.png" alt="image-20250711175326221" style="zoom:50%;" /><p>将计算镜面反射光的代码按这样修改后就会形成区域集中的小范围光斑了。</p><pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token comment">//计算镜面反射光</span><span class="token comment">//计算视线方向</span><span class="token keyword">vec3</span> viewDirection <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>worldPosition <span class="token operator">-</span> cameraPosition<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//计算反射光方向</span><span class="token keyword">vec3</span> reflectDirection <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span><span class="token function">reflect</span><span class="token punctuation">(</span>lightDirectionN<span class="token punctuation">,</span> normalN<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//计算镜面反射光颜色</span><span class="token keyword">float</span> specular <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span><span class="token operator">-</span>viewDirection<span class="token punctuation">,</span> reflectDirection<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">vec3</span> specularColor <span class="token operator">=</span> lightColor <span class="token operator">*</span> <span class="token function">pow</span><span class="token punctuation">(</span>specular<span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//处理背面高光线性</span><span class="token keyword">float</span> flag <span class="token operator">=</span> <span class="token function">step</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token function">dot</span><span class="token punctuation">(</span><span class="token operator">-</span>lightDirectionN<span class="token punctuation">,</span> normalN<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250711175825796.png" alt="image-20250711175825796" style="zoom:50%;" /><p>对于这样一个箱子，中间部分都是木头材质的，显然不可能像上面那样出现高光。正常情况下只会在箱子边的一圈金属部分才会出现高光，中间的木头部分不应该出现高光。为了实现这种效果，可以使用**镜面高光贴图（高光蒙版）**进行采样。</p><p>下图就是这个盒子纹理贴图所对应的镜面高光贴图，可以看到这张贴图是一个黑和白两种颜色的<strong>灰度图</strong>（<strong>rgb三个通道值一样</strong>），不难发现，中心的木头部分三个通道均为0，外侧金属部分的通道值也都在(0,1)之间。于是，我们可以对镜面高光贴图在shader中采样，三个通道的任一通道的值都可以看做这一点的镜面反射高光的强度。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250715202030389.png" alt="image-20250715202030389" style="zoom:40%;" /><pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token comment">//在fragmentShader中新增采样器，专门采样镜面反射贴图</span><span class="token keyword">uniform</span> <span class="token keyword">sampler2D</span> specularSampler<span class="token punctuation">;</span><span class="token comment">//采样镜面反射贴图的颜色</span><span class="token keyword">vec3</span> specularMaskColor <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>specularSampler<span class="token punctuation">,</span> uv<span class="token punctuation">)</span><span class="token punctuation">.</span>xyz<span class="token punctuation">;</span><span class="token comment">//将最终的镜面反射光颜色乘以采样颜色的任一通道值</span>FragColor <span class="token operator">=</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span>diffuseColor <span class="token operator">+</span> specularColor <span class="token operator">*</span> flag <span class="token operator">*</span> specularMaskColor<span class="token punctuation">.</span>x <span class="token operator">+</span> ambientColor<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改代码后可以看到，高光只出现在了金属部分，木头部分的高光已经消失了。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250715202631908.png" alt="image-20250715202631908" style="zoom:33%;" /><h4 id="环境光（ambient）"><a href="#环境光（ambient）" class="headerlink" title="环境光（ambient）"></a>环境光（ambient）</h4><p>假设在一个场景中多个物体，那么对于一个物体来说，接收到的不止有阳光，还有经过其他物体多次反射的光，叫做环境光。环境光会将物体本身的轮廓或者颜色简单显示出来。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250710213212632.png" alt="image-20250710213212632" style="zoom:50%;" /><p>在上面的演示中，我们可以看到没有被光照到的部分是完全黑色的，在现实生活中显然是不合理的。这就需要引入我们的环境光，由于真实的环境光是其他由物体反射多次的光，真实计算起来比较麻烦，所以目前采用较为简单的方法模拟环境光。</p><p>我们只需要设置一个三维变量ambient模拟环境光，再将其和objectColor相乘即可。引入环境光可以让物体没有被光照到的地方也能隐约被我们看到，而不是全黑的。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;外部设置环境光强度uniform vec3 ambient;&#x2F;&#x2F;计算环境光反射的颜色vec3 ambientColor &#x3D; ambient * objColor;&#x2F;&#x2F;将三种光都加上去FragColor &#x3D; vec4(diffuseColor + specularColor * flag + ambient, 1.0);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>加入环境光之后，原本没被光照到的地方也能隐约看到，并不是之前的黑色，显得更加真实一点。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250711181725116.png" alt="image-20250711181725116" style="zoom: 67%;" /><h3 id="法线矩阵"><a href="#法线矩阵" class="headerlink" title="法线矩阵"></a>法线矩阵</h3><p>使用前面的代码，我们可以创建一个简单的光照，随着摄像机的移动，可以看到立方体的高光也在变化。但是当我们将盒子绕y轴随时间不停旋转时就会出现问题。</p><p>我们让摄像机保持不动，让盒子的两面都选择到摄像机的面前，可以看到初始状态面对摄像机的部分是被光线照亮的，但是当另一面转到摄像机面前时，可以发现摄像机面前的盒子居然是黑色的。盒子的明暗就像固定在盒子上一样随着盒子转到，并没有像现实情况那样出现明暗交替的情况。</p><p>出现这种情况的原因就是我们在旋转时没有让法线随着物体转到，当物体旋转30度之后，法线方向还是初始的方向没有变化，明暗情况也自然不会发生变化了。</p><p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250711211222316.png" alt="image-20250711211222316" style="zoom:50%;display:inline" /><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250711211251648.png" alt="image-20250711211251648" style="zoom:50%;display:inline" /></p><p>为了解决这一问题，我们就需要让每个顶点的法线随着顶点的变化而变化。</p><p>如果让法线随着顶点做<strong>同样的模型变换</strong>时，可以发现在进行<strong>旋转和平移</strong>时，都能<strong>正确</strong>的将变换应用到法线上；但是当我们对物体在某一个方向上进行<strong>缩放</strong>时，将缩放变换应用到法线上就会发生<strong>错误</strong>。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250711211914084.png" alt="image-20250711211914084" style="zoom:45%;" /><p>所以必须想办法找到一个新的变换矩阵，使法线在变换后到达正确的方向，这个矩阵称为<strong>NormalMatrix（法线矩阵）</strong>。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250711212532930.png" alt="image-20250711212532930" style="zoom:40%;" /><p>下图为法线矩阵的推导过程，由最终结果可知，法线矩阵的值为模型变换矩阵的逆矩阵再转置即可。这是经过严格推到出来的，不论经过上面变换，将法线乘以模型变换矩阵的逆转置矩阵，得到的新法线都会垂直于该点切面。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250711214237454.png" alt="image-20250711214237454" style="zoom:50%;" /><p>这样修改代码后即可实现法线的正确变换，但是由于求逆矩阵运算复杂。</p><p>当<strong>顶点数量非常多</strong>时，在<strong>shader</strong>中调用<strong>求逆矩阵</strong>的函数会大大<strong>降低性能</strong>，所以最好的做法就是在<strong>cpu端计算好</strong>法线矩阵后，通过<strong>uniform变量</strong>的形式将矩阵<strong>传递到shader</strong>中和法线进行运算，会大大节省算力。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;最终在vertexShader中将传递给fragmentShader的法线处理一下即可normal &#x3D; transpose(inverse(mat3(model))) * aNormal;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="光源类型"><a href="#光源类型" class="headerlink" title="光源类型"></a>光源类型</h3><h4 id="平行光"><a href="#平行光" class="headerlink" title="平行光"></a>平行光</h4><p>平行光是最简单的光源，每一根光线的方向都一样，常用来模拟太阳光。</p><p>假设空间中只有平行光，那么对于物体上能照射到平行光的点来说，<strong>光线方向都一样</strong>。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250710211241870.png" alt="image-20250710211241870" style="zoom:50%;" /><p>由于平行光模拟的是无限远处的光源所发出的光线，所以我们不需要知道光源的位置，只需要知道平行光照的<strong>光照强度</strong>和<strong>光线方向</strong>即可。所以在代码中我们只需要定义两个三维向量<strong>lightDirection</strong>和<strong>lightColor</strong>分别表示光照方向和光照强度即可。</p><h4 id="点光源-PointLight"><a href="#点光源-PointLight" class="headerlink" title="点光源(PointLight)"></a>点光源(PointLight)</h4><p>点光源比较好理解，就是场景中的一盏台灯或者一个电灯泡向四面八方发出的光。</p><p>由于点光源是向四面八方发出光的，所以对于物体的一个顶点来说，该顶点接收到的点光源的光线方向在点光源位置和顶点位置的连线上，也就是说<strong>不同位置的顶点</strong>接收到的点光源<strong>光线方向</strong>是<strong>不同</strong>的。而且，对于更真实的点光源来说，光照的强度也会随着距离的增大而衰减。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250715202936084.png" alt="image-20250715202936084" style="zoom:50%;" /><p>由于不同位置的顶点接收到的光线方向不一致，所以定义一个点光源，我们需要知道点光源的<strong>位置</strong>和其<strong>光照强度</strong>即可，根据点光源位置就能计算出点光源到某一个顶点的光照方向。</p><p>下面简单介绍一下点<strong>光源随距离而衰减</strong>的理论知识：</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250715204340070.png" alt="image-20250715204340070" style="zoom:40%;" /><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250715204400223.png" alt="image-20250715204400223" style="zoom:50%;" /><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250715204519254.png" alt="image-20250715204519254" style="zoom:40%;" /><pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token comment">//除了共有的光源颜色属性外，点光源还需要光源位置和衰减系数</span><span class="token comment">//光源位置</span><span class="token keyword">uniform</span> <span class="token keyword">vec3</span> lightPosition<span class="token punctuation">;</span><span class="token comment">//点光源衰减参数</span><span class="token keyword">uniform</span> <span class="token keyword">float</span> k1<span class="token punctuation">,</span> k2<span class="token punctuation">,</span> kc<span class="token punctuation">;</span><span class="token comment">//计算衰减系数</span><span class="token keyword">float</span> dis <span class="token operator">=</span> <span class="token function">length</span><span class="token punctuation">(</span>worldPosition <span class="token operator">-</span> lightPosition<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">float</span> multi <span class="token operator">=</span> <span class="token number">1.0</span><span class="token operator">/</span><span class="token punctuation">(</span>kc <span class="token operator">+</span> k1<span class="token operator">*</span>dis <span class="token operator">+</span> k2<span class="token operator">*</span>dis<span class="token operator">*</span>dis<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//计算出衰减系数后，将最终得到的点光源光照颜色乘以该系数模拟光照衰退的效果（近亮远暗）</span><span class="token keyword">vec3</span> final <span class="token operator">=</span> <span class="token punctuation">(</span>diffuseColor <span class="token operator">+</span> specularColor<span class="token operator">*</span>flag<span class="token operator">*</span>specularMaskColor<span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token operator">*</span> multi<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="聚光灯-SpotLight"><a href="#聚光灯-SpotLight" class="headerlink" title="聚光灯(SpotLight)"></a>聚光灯(SpotLight)</h4><p>聚光灯不是像点光源那样向四面八方发射光线，而是只会在一定的角度范围内发射光线。如果把点光源发出的光线形状看左一个球形，那么聚光灯发出的光线形状就是一个圆锥体，类似于手电筒的效果。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250716152715092.png" alt="image-20250716152715092" style="zoom:50%;" /><p>对于一个聚光灯，我们不仅需要知道<strong>光源位置</strong>，还要知道<strong>聚光灯的朝向</strong>和<strong>最大照射角度θ</strong>。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250716153455153.png" alt="image-20250716153455153" style="zoom:50%;" /><pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token comment">//聚光灯目标朝向方向</span><span class="token keyword">uniform</span> <span class="token keyword">vec3</span> lightTargetDirection<span class="token punctuation">;</span><span class="token comment">//聚光灯最大可视角度</span><span class="token keyword">uniform</span> <span class="token keyword">float</span> visibleAngle<span class="token punctuation">;</span><span class="token comment">//光源位置</span><span class="token keyword">uniform</span> <span class="token keyword">vec3</span> lightPosition<span class="token punctuation">;</span><span class="token comment">//计算该点是否在最大可视角内</span><span class="token comment">//方向归一化</span><span class="token keyword">vec3</span> targetDirectionN <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>lightTargetDirection<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//计算当前点和光源位置连线与看向方向的夹角cos值</span><span class="token keyword">float</span> cosTheta <span class="token operator">=</span> <span class="token function">dot</span><span class="token punctuation">(</span>lightDirectionN<span class="token punctuation">,</span> targetDirectionN<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//计算最大可见角的cos值，传入的是弧度</span><span class="token keyword">float</span> cosVisible <span class="token operator">=</span> <span class="token function">cos</span><span class="token punctuation">(</span>visibleAngle<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//如果在可视角内值为1，不可见则为0</span><span class="token keyword">float</span> isVisible <span class="token operator">=</span> <span class="token function">step</span><span class="token punctuation">(</span>cosVisible<span class="token punctuation">,</span> cosTheta<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将聚光灯下的漫反射和镜面反射结果都称以isVisible控制是否可见</span><span class="token keyword">vec3</span> final <span class="token operator">=</span> <span class="token punctuation">(</span>diffuseColor <span class="token operator">+</span> specularColor<span class="token operator">*</span>flag<span class="token operator">*</span>specularMaskColor<span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token operator">*</span> isVisible<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250716162447499.png" alt="image-20250716162447499" style="zoom:50%;" /><p>虽然成功地显示出来手电筒类的光照，但是明显看起来很别扭。因为光照的边缘明暗过渡太过于生硬了，在边缘内的明亮直接变成了黑的，不符合现实情况。为了解决这个问题，我们还需要顶定义一个<strong>过渡角β</strong>。</p><p>当某点角度γ&lt;θ时，光照正常；当θ&lt;γ&lt;β时，光照会一定程度上进行衰减；当β&lt;γ时，认为该点不能接收到聚光灯光照。</p><p>于是我们就可以有一个平滑的明暗过渡效果，最终衰减系数的计算公式如下。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250716165355944.png" alt="image-20250716165355944" style="zoom:50%;" /><pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token comment">//聚光灯目标朝向方向</span><span class="token keyword">uniform</span> <span class="token keyword">vec3</span> lightTargetDirection<span class="token punctuation">;</span><span class="token comment">//聚光灯可视范围的内边界和外边界</span><span class="token keyword">uniform</span> <span class="token keyword">float</span> innerLine<span class="token punctuation">;</span><span class="token comment">//cosθ</span><span class="token keyword">uniform</span> <span class="token keyword">float</span> outerLine<span class="token punctuation">;</span><span class="token comment">//cosβ</span><span class="token comment">//光源位置</span><span class="token keyword">uniform</span> <span class="token keyword">vec3</span> lightPosition<span class="token punctuation">;</span><span class="token comment">//根据角度计算衰减系数</span><span class="token comment">//方向归一化</span><span class="token keyword">vec3</span> targetDirectionN <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>lightTargetDirection<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//计算当前点和光源位置连线与看向方向的夹角cos值</span><span class="token keyword">float</span> cosGamma <span class="token operator">=</span> <span class="token function">dot</span><span class="token punctuation">(</span>lightDirectionN<span class="token punctuation">,</span> targetDirectionN<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//计算最大可见角的cos值，传入的是弧度</span><span class="token keyword">float</span> multi <span class="token operator">=</span> <span class="token function">clamp</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>cosGamma <span class="token operator">-</span> outerLine<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>innerLine <span class="token operator">-</span> outerLine<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将聚光灯下的漫反射和镜面反射结果都称以multi以控制光照衰减</span><span class="token keyword">vec3</span> final <span class="token operator">=</span> <span class="token punctuation">(</span>diffuseColor <span class="token operator">+</span> specularColor<span class="token operator">*</span>flag<span class="token operator">*</span>specularMaskColor<span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token operator">*</span> multi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改后的效果不再像之前那么生硬，边界有了明显的明暗过渡效果。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250716170040608.png" alt="image-20250716170040608" style="zoom:50%;" /><h2 id="模型读取"><a href="#模型读取" class="headerlink" title="模型读取"></a>模型读取</h2><h3 id="父子关系"><a href="#父子关系" class="headerlink" title="父子关系"></a>父子关系</h3><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250717181227698.png" alt="image-20250717181227698" style="zoom:40%;" /><h2 id="模板测试（StencilTest）"><a href="#模板测试（StencilTest）" class="headerlink" title="模板测试（StencilTest）"></a>模板测试（StencilTest）</h2><h3 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h3><p>当片段着色器处理完一个片段之后，模板测试(Stencil Test)会开始执行，和深度测试一样，它也可能会丢弃片段。接下来，被<strong>保留的片段会进入深度测试</strong>，它可能会丢弃更多的片段。模板测试是根据又一个缓冲来进行的，它叫做<strong>模板缓冲</strong>(Stencil Buffer)，我们可以在渲染的时候更新它来获得一些很有意思的效果。</p><p>模板缓冲在绘制物体时决定该位置缓冲区的值，借由缓冲区的值做一些效果。例如制作物体的<strong>描边特效</strong>，首先绘制一个物体，并将绘制出物体对应的缓冲区设为1，然后再绘制一个稍微放大的同样形状的物体，设置其只能在缓冲区不为1的区域绘制。这样发大的物体就只能绘制在物体的边界处，也就形成了物体描边的效果。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250721162950358.png" alt="image-20250721162950358" style="zoom:50%;" /><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>和深度测试一样，需要使用glEnable和glDisable函数来控制模板测试的开启和关闭。</p><p>当开启模板测试后，需要设置<strong>通过模板测试的条件（glStencilFunc）</strong>、<strong>模板缓冲区的更新策略（glStencilOp）</strong>、<strong>模板缓冲区的读写控制（glStencilMask）</strong>。大致都和深度测试的使用类似，只是多了模板缓冲区的更新策略（深度缓冲区的更新策略较为固定，只需通过深度测试的片元深度值替换缓冲区深度值即可），模板缓冲区的更新较为灵活，专门提供了设置更新策略的函数。</p><ul><li><strong>模板测试的开启和关闭</strong></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void glEnable(GL_STENCIL_TEST);&#x2F;&#x2F;开启模板测试void glDisable(GL_STENCIL_TEST);&#x2F;&#x2F;关闭模板测试&#x2F;&#x2F;由于存在缓冲区，所以每帧绘制前要调用glClear清理上一帧的模板缓存值glClear(GL_STENCIL_BUFFER_BIT);glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>设置模板测试的条件(满足条件的片元才能通过模板测试，继续进行深度测试)</strong></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;设置模板测试条件&#x2F;&#x2F;func：模板缓存中的数值与ref如何比较才算通过测试。&#x2F;&#x2F;ref：参考值，模板缓存值与其进行比较&#x2F;&#x2F;mask：缓存值和ref比较之前，都要和mask做一次与运算（一般情况下为全1的数值，即0XFF）void glStencilFunc(GLenum func, GLint ref, GLuint mask);&#x2F;&#x2F;该设置表示缓冲区数值和参考值1如果”相等“则通过模板测试（二者和0XFF与运算值不变）glStencilFunc(GL_EQUAL, 1, 0XFF);&#x2F;&#x2F;缓冲区数值小于5才通过模板测试glStencilFunc(GL_LESS, 5, 0XFF);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参数<strong>func</strong>的可选值如下：</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250721164453127.png" alt="image-20250721164453127" style="zoom:50%;" /><ul><li><strong>模板测试通过或失败后，如何更新模板缓冲区的值</strong></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;设置模板缓冲更新策略&#x2F;&#x2F;sfail：模板测试失败时对缓冲区执行什么操作&#x2F;&#x2F;zfail：模板测试通过但深度测试失败时对缓冲区执行什么操作&#x2F;&#x2F;zpass：模板测试通过且深度测试通过时对缓冲区执行什么操作void glStencilOp(GLenum sfail, GLenum zfail, GLenum zpass);&#x2F;&#x2F;该设置为不论什么情况都不改变缓冲区的值glStencilOp(GL_KEEP, GL_KEEP, GL_KEEP);&#x2F;&#x2F;该设置为只有模板测试和深度测试都通过时，就将缓冲区的值更新为ref（一般情况下使用的是该设置）glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这三个参数的值可在下面选项中任意使用：</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250721170417176.png" alt="image-20250721170417176" style="zoom:50%;" /><ul><li><strong>开启模板测试的情况下，设置模板缓存是否能写入</strong></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;模板缓冲区的写入控制&#x2F;&#x2F;mask：缓冲区值的更新是一位一位更新的，只有当mask中位是1的对应位置才会被改变void glStencilMask(GLuint mask);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如下图所示，当更新缓冲区时，缓冲区的值只有在mask的比特位为1的位置允许被写入，mask比特位为0的位置保持原样。</p><p>一般常用的mask值有两种：</p><p>0x00：任何比特位都<strong>不允许</strong>写入（禁止更新模板缓冲区的值）。</p><p>0xFF：任何比特位都<strong>允许</strong>写入。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250721174213217.png" alt="image-20250721174213217" style="zoom:50%;" /><h2 id="颜色混合（ColorBlending）"><a href="#颜色混合（ColorBlending）" class="headerlink" title="颜色混合（ColorBlending）"></a>颜色混合（ColorBlending）</h2><h3 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h3><p>OpenGL中，混合(Blending)通常是实现物体透明度(Transparency)的一种技术。透明就是说一个物体（或者其中的一部分）不是纯色(Solid Color)的，它的颜色是物体本身的颜色和它背后其它物体的颜色的不同强度结合。例如我们透过有色玻璃看向外面，我们看到的颜色就是外面的颜色和玻璃的颜色进行混合后的，就好像加了一层滤镜一样，所以透明度能让我们看穿物体。</p><img src="https://learnopengl-cn.github.io/img/04/03/blending_transparency.png" alt="img" style="zoom: 67%;" /><p>在各种软件中，透明程度会使用**opacity（不透明度）**表示，其取值范围是[0, 1]，0是完全透明，1是完全不透明。</p><p>图片中例如png格式的，其通道为rgba，最后一个通道<strong>alpha</strong>就表示了图片某个<strong>像素的透明度</strong>，其含义和opacity一样。</p><p>在opengl中，这种透明物体颜色叠加的效果叫做<strong>颜色混合（color blending）</strong>。</p><p>开启颜色混合后，会使用下图中的公式计算最终的混合颜色，其中：</p><ol><li><strong>源颜色(SrcColor)</strong>：当前片元着色器输出的颜色</li><li><strong>目标颜色(DestColor)</strong>：帧缓冲区中已经存在的颜色（颜色缓冲中的颜色）</li></ol><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250722173021366.png" alt="image-20250722173021366" style="zoom:50%;" /><h3 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h3><p>和深度测试一样，在opengl中要使用颜色混合，就要使用<strong>glEnable</strong>或者glDisanbe开启或关闭颜色混合功能。开启后再调用<strong>glBlendFunc</strong>函数设置最终混合颜色的计算公式。</p><ul><li><strong>开启或关闭</strong></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void glEnable(GL_BLEND);&#x2F;&#x2F;开启void glDisable(GL_BLEND);&#x2F;&#x2F;关闭<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><strong>设置混合颜色计算公式的参数</strong></li></ul><p>两个参数均可从下面选项中任意使用：</p><ul><li><code>GL_ZERO</code>：因子为0.0</li><li><code>GL_ONE</code>：因子为1.0</li><li><code>GL_SRC_COLOR</code>：因子等于源颜色</li><li><code>GL_ONE_MINUS_SRC_COLOR</code>：因子等于1-源颜色</li><li><code>GL_DST_COLOR</code>：因子等于目标颜色</li><li><code>GL_ONE_MINUS_DST_COLOR</code>：因子等于1-目标颜色</li><li><code>GL_SRC_ALPHA</code>：因子等于源颜色的alpha分量</li><li><code>GL_ONE_MINUS_SRC_ALPHA</code>：因子等于1-源颜色的alpha分量</li><li><code>GL_DST_ALPHA</code>：因子等于目标颜色的alpha分量</li><li><code>GL_ONE_MINUS_DST_ALPHA</code>：因子等于1-目标颜色的alpha分量</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;混合颜色计算公式：blend_color &#x3D; src_color * sfactor + dest_color * dfactor&#x2F;&#x2F;可用通过设置不同的参数，实现不同的混合效果&#x2F;&#x2F;上图中的公式设置的是一般较为常用的参数void glBlendFunc(GLenum sfactor, GLenum dfactor);&#x2F;&#x2F;该设置为常用设置，根据源颜色的alpha值控制混合颜色glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>设置混合颜色的运算</strong></li></ul><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250722174155951.png" alt="image-20250722174155951" style="zoom:50%;" /><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;这个参数可用设置两种颜色和自己的因子相乘后，二者之间用什么运算（默认是相加）void glBlendEquation(GLenum mode);&#x2F;&#x2F;默认情况：blend_color &#x3D; src_color * sfactor + dest_color * dfactorglBlendEquation(GL_FUNC_ADD);&#x2F;&#x2F;二者相减：blend_color &#x3D; src_color * sfactor - dest_color * dfactorglBlendEquation(GL_FUNC_SUBTRACT);&#x2F;&#x2F;反向相减：blend_color &#x3D; dest_color * dfactor - src_color * sfactorglBlendEquation(GL_FUNC_REVERSE_SUBTRACT);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="绘制顺序"><a href="#绘制顺序" class="headerlink" title="绘制顺序"></a>绘制顺序</h3><p>对于透明物体来说，不同的绘制顺序也会导致绘制结果的不同。</p><p>对于这样一个每个面都是透明有色玻璃的盒子来说，开启颜色混合后却出现了这样的问题。可用看到盒子明显只绘制出了三个面，另外三个面没有绘制出来，但是当摄像机移动到消失面的前面时，又能正确绘制出来。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250722174525969.png" alt="image-20250722174525969" style="zoom:50%;" /><p>这是由于对于一个复杂物体来说，包含多个三角形，我们的绘制顺序是不确定的，才导致这一情况。</p><p>假设我们有三个<strong>有色透明三角形</strong>重叠在一起，只有<strong>z坐标不同</strong>，A距离摄像机最近，C最远。</p><p>如果按照<strong>CBA</strong>的顺序进行绘制，在开启颜色混合的情况下。先绘制C，再绘制B时将B的颜色和颜色缓冲中C的颜色进行混合，再绘制A的适合再将混合后的颜色和A的颜色进行混合，会得到正确的混合颜色。</p><p>如果按照<strong>ABC</strong>的顺序进行绘制，在开启颜色混合的情况下。先绘制A，在绘制B的时候会由于<strong>B被A遮挡</strong>而<strong>无法通过深度测试</strong>自然也无法进行后面的颜色混合，绘制C时也同理，所以此时透过A看去，看不到B和C的混合颜色。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250722174931892.png" alt="image-20250722174931892" style="zoom:50%;" /><p>所以上面的透明玻璃盒子出现这一的原因就是因为透明物体之间的绘制顺序错误导致的。</p><p>为了解决这一问题，有两个方法：</p><ol><li>将<strong>透明物体的深度写入关闭</strong>，这样对于一个复杂物体来说即使先绘制前面的片元也<strong>不会更新深度缓冲区</strong>（但依然会将<strong>颜色混合后写入颜色缓冲区</strong>），<strong>后面的片元</strong>能够<strong>通过深度测试</strong>进行颜色混合。</li><li>调整绘制顺序，<strong>先绘制不透明物体</strong>，再按照距离摄像机的距离<strong>从远到近</strong>的顺序依次<strong>绘制透明物体</strong>。</li></ol><p>方法1是一种较为简单的解决方法，方法2调整顺序之后才是真正的透明效果。</p><p>方法1实现较为简单，只需要绘制该物体时关闭深度写入即可，所以在<strong>绘制透明物体</strong>时，应该<strong>关闭其深度写入</strong>。</p><p>方法2的实现则需要在导入模型时对所有的mesh按照摄像机坐标系下的z值进行排序，按顺序绘制。</p><h2 id="面剔除（FaceCulling）"><a href="#面剔除（FaceCulling）" class="headerlink" title="面剔除（FaceCulling）"></a>面剔除（FaceCulling）</h2><h3 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍"></a>介绍</h3><p>假设空间中有一个不透明的立方体盒子，不论我们从哪个角度看去，都不可能将六个面全部看到，事实上只能看到最多三个面。但是在绘制盒子的时候，我们确实是将六个面全部绘制出来了，没看到的部分只是由于深度关系被遮盖了，那部分的顶点仍然参与运算了。</p><p>如果将看不到的面直接不渲染，，将会节省一部分计算资源，提升程序的性能。</p><p>这正是**面剔除(Face Culling)<strong>所做的。OpenGL能够检查所有</strong>面向(Front Facing)<strong>观察者的面，并渲染它们，而</strong>丢弃那些背向(Back Facing)**的面，节省我们很多的片段着色器调用（它们的开销很大！）。但我们仍要告诉OpenGL哪些面是正向面(Front Face)，哪些面是背向面(Back Face)。OpenGL使用了一个很聪明的技巧，分析顶点数据的环绕顺序(Winding Order)。</p><p>当我们定义一个三角形时，会将三个顶点按照顺时针（Clockwise）或者逆时针（Counter-clockwise）的顺序给出。<strong>OpenGL</strong>在渲染图元的时候将使用这个信息来决定一个三角形是一个正向三角形还是背向三角形。<strong>默认</strong>情况下，<strong>逆时针顺序</strong>顶点所定义的三角形将会被处理为<strong>正向三角形</strong>。</p><p><img src="https://learnopengl-cn.github.io/img/04/04/faceculling_windingorder.png" alt="img"></p><p>当定义好正向之后，我们在正面看的时候为正向，当移动到背面时，顶点的旋转顺序就会逆过来，就变成了背向。在3D物体中，背向观察者的面是看不到的，所以可以将其剔除。</p><h3 id="API-2"><a href="#API-2" class="headerlink" title="API"></a>API</h3><p>opengl默认禁用面剔除，可用使用glEnable和glDisable函数开启和关闭。</p><ul><li><strong>开启和关闭</strong></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void glEnable(GL_CULL_FACE);&#x2F;&#x2F;开启void glDisable(GL_CULL_FACE);&#x2F;&#x2F;关闭<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><strong>设置正向面（三角形顶点顺序逆时针为正向面还是顺时针为正向面）</strong></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;GL_CW  顺时针的环绕顺序&#x2F;&#x2F;GL_CCW 逆时针的环绕顺序（默认）void glFrontFace(GL_CCW);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>设置剔除面（剔除正向面还是背向面）</strong></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; GL_BACK： 只剔除背向面。&#x2F;&#x2F; GL_FRONT：只剔除正向面。&#x2F;&#x2F; GL_FRONT_AND_BACK：剔除正向面和背向面。void glFrontFace(GL_BACK);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="帧缓冲（FrameBuffer）"><a href="#帧缓冲（FrameBuffer）" class="headerlink" title="帧缓冲（FrameBuffer）"></a>帧缓冲（FrameBuffer）</h2><h3 id="介绍-8"><a href="#介绍-8" class="headerlink" title="介绍"></a>介绍</h3><p>前面已经使用了很多屏幕缓冲了：用于写入颜色值的颜色缓冲、用于写入深度信息的深度缓冲和允许我们根据一些条件丢弃特定片段的模板缓冲。这些缓冲结合起来叫做帧缓冲(Framebuffer)，它被储存在GPU内存中的某处。</p><p>简单来说，帧缓冲就是一些屏幕缓冲（颜色缓冲、深度缓冲、模板缓冲等）的总和。</p><p>我们目前所做的所有操作都是在<strong>默认帧缓冲</strong>上进行的。默认的帧缓冲是在你创建窗口的时候生成和配置的（GLFW帮我们做了这些）。我们也创建我们自己的帧缓冲，实现一些酷炫的后期效果。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250727200339395.png" alt="image-20250727200339395" style="zoom:50%;" /><p>帧缓冲的这些附件，我们可用使用2D纹理图片进行存储，绘制时可用直接从纹理中采样进行使用。</p><p>实现帧缓冲，我们需要进行两次绘制：</p><ul><li>第一次绘制：创建自己的帧缓冲，将要绘制的画面渲染后添加到自己的帧缓冲附件上</li><li>第二次绘制：使用上述帧缓冲的颜色附件（ColorBuffer）作为纹理进行采样，对图像进行后期处理，绘制到屏幕上</li></ul><h3 id="API-3"><a href="#API-3" class="headerlink" title="API"></a>API</h3><ul><li><strong>创建帧缓冲</strong></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">unsigned int fbo;glGenFramebuffers(1, &amp;fbo);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><strong>绑定帧缓冲</strong></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">glBindFramebuffer(GL_FRAMEBUFFER, fbo);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>将颜色附件创建</strong></li></ul><p>首先要创建一个<strong>空的2D纹理</strong>作为帧缓冲的<strong>颜色附件</strong>，再将该颜色附件绑定到帧缓冲。当帧缓冲绑定后，最终的<strong>绘制结果</strong>会<strong>保存到该颜色附件</strong>中。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;创建一个普通的2D纹理作为颜色附件（纹理对象数据为空）glGenTextures(1, &amp;colorAttachment);&#x2F;&#x2F;激活0号纹理单元（如果不手动激活纹理单元，在绑定纹理对象时默认激活0号纹理单元）glActiveTexture(GL_TEXTURE0 + unit);&#x2F;&#x2F;绑定纹理对象glBindTexture(GL_TEXTURE_2D, colorAttachment);&#x2F;&#x2F;向纹理对象传递空数据(纹理大小要和绘制区域大小一样)glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);&#x2F;&#x2F;设置纹理过滤方式glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>将颜色附件添加到帧缓冲</strong></li></ul><p>调用<strong>glFramebufferTexture2D</strong>函数可用将指定缓冲的附件添加到当前绑定的帧缓冲上。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;将颜色附件添加到帧缓冲上&#x2F;&#x2F;第一个参数为固定值，表面向当前绑定的帧缓冲上添加缓冲附件&#x2F;&#x2F;第二个参数是缓冲附件类型，表面向当前绑定的帧缓冲添加什么类型的附件(此处为颜色附件，允许有多个，只用到第一个即可)&#x2F;&#x2F;第三个参数为固定值&#x2F;&#x2F;第四个参数是颜色缓冲的id值&#x2F;&#x2F;第五个参数是指把当前纹理哪个level的mipmap绑定进去（没有生成mipmap，使用0级的）glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, colorAttachment, 0);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>创建深度和模板附件</strong></li></ul><p>深度缓冲和模板缓冲一般情况下可以分配到<strong>同一个缓冲</strong>中，假设每个像素有32bit存储这些缓冲，前<strong>24bit深度缓冲</strong>使用，后<strong>8bit模板缓冲</strong>使用。由于两个缓冲共存在一个纹理中，所以调用<strong>glTexImage2D</strong>函数传输空数据时的<strong>数据格式</strong>也不同。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;创建一个普通的2D纹理作为颜色附件（纹理对象数据为空）glGenTextures(1, &amp;depthStencilAttachment);&#x2F;&#x2F;激活0号纹理单元（如果不手动激活纹理单元，在绑定纹理对象时默认激活0号纹理单元）glActiveTexture(GL_TEXTURE0 + unit);&#x2F;&#x2F;绑定纹理对象glBindTexture(GL_TEXTURE_2D, depthStencilAttachment);&#x2F;&#x2F;向纹理对象传递空数据(纹理大小要和绘制区域大小一样)glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH24_STENCIL8, width, height, 0, GL_DEPTH_STENCIL, GL_UNSIGNED_INT_24_8, NULL);&#x2F;&#x2F;设置纹理过滤方式glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>将深度模板附件添加到帧缓冲上</strong></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;将深度模板附件添加到帧缓冲上glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_TEXTURE_2D, depthStencilAttachment, 0);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><strong>检查fbo是否完整</strong></li></ul><p>创建fbo完成后，可用调用<strong>glCheckFramebufferStatus</strong>函数查看<strong>当前绑定</strong>的fbo<strong>是否创建完整</strong>。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;检查当前fbo是否完整if (glCheckFramebufferStatus(GL_FRAMEBUFFER) !&#x3D; GL_FRAMEBUFFER_COMPLETE)&#123;    std::cout &lt;&lt; &quot;当前fbo缺少附件&quot; &lt;&lt; std::endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="后期效果"><a href="#后期效果" class="headerlink" title="后期效果"></a>后期效果</h3><p>在最初的绘制中，我们如果想对最终的绘制结果进行后期处理（调高亮度、模糊处理、灰度图等），是很难实现的，因为在着色器中无法得知其他片元的颜色或者其他数据。</p><p>使用我们自己创建的帧缓冲后，可用将绘制的最终结果保存到帧缓冲的颜色缓冲中，这样我们就相当于拿到了最终绘制结果的纹理图片，在对这个纹理采样时做一些后期处理就变得很容易了。</p><ol><li>首先要创建一个完全遮挡住屏幕的矩形。</li><li>创建一个完整的FBO。</li><li>绑定创建的FBO，执行场景的绘制操作。第一次渲染操作，会将场景的渲染结果作为2D纹理保存到当前FBO的颜色缓冲中。</li><li>绑定默认的帧缓冲（FBO为0），渲染矩形屏幕，其采样的纹理为创建的FBO的颜色缓冲。第二次渲染操作，用一个完全盖住屏幕的屏幕，纹理为颜色缓冲。</li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;绑定创建的FBOglBindFramebuffer(GL_FRAMEBUFFER, fbo);&#x2F;&#x2F;执行第一次渲染，绘制正常场景draw();&#x2F;&#x2F;使用默认的帧缓冲glBindFramebuffer(GL_FRAMEBUFFER, 0);&#x2F;&#x2F;绘制盖住屏幕的屏幕，使用创建的FBO的颜色缓冲作为纹理采样，在shader采样时可做一些后期特效draw();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token comment">//------------------------------vertexShader</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">460</span> core</span></span><span class="token keyword">layout</span><span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token keyword">vec3</span> aPosition<span class="token punctuation">;</span><span class="token keyword">layout</span><span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token keyword">vec2</span> aUv<span class="token punctuation">;</span><span class="token keyword">out</span> <span class="token keyword">vec2</span> uv<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>uv <span class="token operator">=</span> aUv<span class="token punctuation">;</span><span class="token comment">//因为要完全盖住屏幕，外界传来的直接为NDC坐标，且顶点都在边界</span>gl_Position <span class="token operator">=</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span>aPosition<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//------------------------------fragmentShader</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">460</span> core</span></span><span class="token keyword">out</span> <span class="token keyword">vec4</span> FragColor<span class="token punctuation">;</span><span class="token keyword">in</span> <span class="token keyword">vec2</span> uv<span class="token punctuation">;</span><span class="token keyword">uniform</span> <span class="token keyword">sampler2D</span> screenSampler<span class="token punctuation">;</span><span class="token comment">//灰度图处理，输出颜色的rgb值都为原先颜色rgb值和的平均值</span><span class="token keyword">vec3</span> <span class="token function">gray</span><span class="token punctuation">(</span><span class="token keyword">vec3</span> color<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">float</span> ant <span class="token operator">=</span> <span class="token punctuation">(</span>color<span class="token punctuation">.</span>r <span class="token operator">+</span> color<span class="token punctuation">.</span>g <span class="token operator">+</span> color<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">3.0</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token keyword">vec3</span><span class="token punctuation">(</span>ant<span class="token punctuation">,</span> ant<span class="token punctuation">,</span> ant<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">vec3</span> color <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>screenSampler<span class="token punctuation">,</span> uv<span class="token punctuation">)</span><span class="token punctuation">.</span>rgb<span class="token punctuation">;</span>color <span class="token operator">=</span> <span class="token function">gray</span><span class="token punctuation">(</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span>FragColor <span class="token operator">=</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span>color<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​                     <img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250727205147193.png" alt="image-20250727205147193" style="zoom:50%;display=inline;" /><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250727205130194.png" alt="image-20250727205130194" style="zoom:50%;display=inline;" /></p><h2 id="立方体贴图（CuebMap）"><a href="#立方体贴图（CuebMap）" class="headerlink" title="立方体贴图（CuebMap）"></a>立方体贴图（CuebMap）</h2><h3 id="介绍-9"><a href="#介绍-9" class="headerlink" title="介绍"></a>介绍</h3><p>纹理贴图中除了2D纹理贴图，还有立方体贴图，就好像是把一个立方体盒子展开了一样，共有六张图片，分为上下左右前后六个方向。立方体贴图常常用来实现天空盒，就好像是把摄像机盖在了盒子里，盒子作为天空始终作为背景显示在最后。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250727205356023.png" alt="image-20250727205356023" style="zoom:50%;" /><p>假设我们有一个1x1x1的单位立方体，方向向量的原点位于它的中心。使用一个橘黄色的方向向量来从立方体贴图上采样一个纹理值会像是这样：</p><img src="https://learnopengl-cn.github.io/img/04/06/cubemaps_sampling.png" alt="img" style="zoom:67%;" /><p>方向向量的<strong>大小并不重要</strong>，只要<strong>提供了方向</strong>，OpenGL就会获取方向向量盒立方体贴图相交位置的颜色。这样子，只要立方体的<strong>中心位于原点</strong>（可用将盒子的<strong>中心位置</strong>始终<strong>跟随摄像机位置</strong>，就能保证盒子中心始终位于摄像机坐标系的原点中），我们就能使用立方体的<strong>实际位置向量</strong>来对立方体贴图进行<strong>采样</strong>了，这样一来，可用直接使用<strong>顶点坐标</strong>作为每个顶点<strong>uv坐标</strong>进行采样即可。</p><h3 id="创建立方体贴图"><a href="#创建立方体贴图" class="headerlink" title="创建立方体贴图"></a>创建立方体贴图</h3><ul><li><strong>创建纹理</strong></li></ul><p>与普通纹理一样，直接使用glGenTextures函数创建一个纹理即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">glGenTextures(1, &amp;cubeMap);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>绑定纹理到opengl对应插槽</strong></li></ul><p>绑定流程与普通纹理类似，但是<strong>glBindTexture</strong>函数中要<strong>绑定</strong>到<strong>GL_TEXTURE_CUBE_MAP</strong>而非GL_TEXTURE_TEXTURE_2D。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">glActiveTexture(GL_TEXTURE0 + unit);&#x2F;&#x2F;激活对应纹理单元glBindTexture(GL_TEXTURE_CUBE_MAP, cubeMap);&#x2F;&#x2F;绑定创建的立方体贴图到GL_TEXTURE_CUBE_MAP插槽<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><strong>向纹理贴图中传输图片数据</strong></li></ul><p>cubeMap贴图读取时<strong>不需要翻转y轴</strong>，而且因为立方体贴图有六个面，必须为六个面都传输数据。</p><p>传输数据和普通纹理图片类似，都是读取数据后调用<strong>glTexImage2D</strong>函数，只是立方体贴图有六个面，所以需要调用<strong>六次函数</strong>。每次将纹理目标(<strong>target</strong>)参数（第一个参数）设置为立方体贴图的一个<strong>特定的面</strong>。</p><table><thead><tr><th align="left">纹理目标（target参数）</th><th align="left">方位</th></tr></thead><tbody><tr><td align="left"><code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code></td><td align="left">右</td></tr><tr><td align="left"><code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code></td><td align="left">左</td></tr><tr><td align="left"><code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code></td><td align="left">上</td></tr><tr><td align="left"><code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code></td><td align="left">下</td></tr><tr><td align="left"><code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code></td><td align="left">后</td></tr><tr><td align="left"><code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code></td><td align="left">前</td></tr></tbody></table><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;cubeMap不需要翻转y轴stbi_set_flip_vertically_on_load(false);&#x2F;&#x2F;右左上下前后&#x2F;&#x2F;六个面的均为无符号整型定义，且数值连续，可用循环设置for (int i &#x3D; 0; i &lt; paths.size(); i++)&#123;    int channels;    &#x2F;&#x2F;根据路径读取图片数据    unsigned char* imageData &#x3D; stbi_load(paths[i].c_str(), &amp;width, &amp;height, &amp;channels, STBI_rgb_alpha);    if (imageData)    &#123;        &#x2F;&#x2F;按照右左上下前后，依次向各个面传输数据        glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, imageData);        &#x2F;&#x2F;释放数据        stbi_image_free(imageData);    &#125;    else    &#123;        std::cout &lt;&lt; &quot;无法读取CubeMap图片&quot; &lt;&lt; std::endl;    &#125;&#125;&#x2F;&#x2F;设置立方体贴图的纹理过滤方式和包裹方式glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="显示立方体贴图"><a href="#显示立方体贴图" class="headerlink" title="显示立方体贴图"></a>显示立方体贴图</h3><p>立方体贴图的绘制需要依附于一个立方体盒子，所以也需要一个shader，复杂绘制天空盒。</p><p>之前已经介绍过，可用直接使用立方体盒子<strong>每个顶点的位置作为其uv坐标</strong>进行采样，<strong>立方体的变换和正常物体一样</strong>，只是我们将立方体的中心位置始终设置为摄像机的位置，就实现了天空盒包裹住摄像机的效果。</p><p>由于立方体贴图是立体的，采样器要使用<strong>samplerCube</strong>类型进行采样，<strong>texture</strong>函数中传入的<strong>uv坐标也是三维</strong>的。</p><p>由于立方体贴图作为天空盒绘制在屏幕中，所以<strong>立方体贴图</strong>应该在场景中<strong>所有物体之后</strong>，我们只需要将该立方体的<strong>深度值</strong>始终<strong>设置为最大的1</strong>即可。</p><p>由下图流程可知，<strong>vertexShader</strong>输出的顶点坐标<strong>除以w</strong>后转化为NDC坐标，再将<strong>Z的NDC</strong>坐标<strong>加1除2</strong>可转化为最终的<strong>深度值</strong>，所以想让天空盒的深度值始终为一，只需<strong>vertexShader输出的Z坐标等于w</strong>即可。</p><p>所以在vertexShader的最后用<strong>gl_Position &#x3D; gl_Position.xyww</strong>，让输出的<strong>z值等于w</strong>。</p><p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250727230227272.png" alt="image-20250727230227272"></p><pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token comment">//------------------------------vertexShader</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">460</span> core</span></span><span class="token keyword">layout</span><span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token keyword">vec3</span> aPosition<span class="token punctuation">;</span><span class="token keyword">layout</span><span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token keyword">vec2</span> aUv<span class="token punctuation">;</span><span class="token keyword">out</span> <span class="token keyword">vec3</span> uvw<span class="token punctuation">;</span><span class="token keyword">uniform</span> <span class="token keyword">mat4</span> model<span class="token punctuation">;</span><span class="token keyword">uniform</span> <span class="token keyword">mat4</span> view<span class="token punctuation">;</span><span class="token keyword">uniform</span> <span class="token keyword">mat4</span> projection<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//顶点坐标作为uv坐标采样</span>uvw <span class="token operator">=</span> aPosition<span class="token punctuation">;</span><span class="token keyword">vec4</span> pos <span class="token operator">=</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span>aPosition<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>gl_Position <span class="token operator">=</span> projection <span class="token operator">*</span> view <span class="token operator">*</span> model <span class="token operator">*</span> pos<span class="token punctuation">;</span>gl_Position <span class="token operator">=</span> gl_Position<span class="token punctuation">.</span>xyww<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//------------------------------fragmentShader</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">460</span> core</span></span><span class="token keyword">out</span> <span class="token keyword">vec4</span> FragColor<span class="token punctuation">;</span><span class="token keyword">in</span> <span class="token keyword">vec3</span> uvw<span class="token punctuation">;</span><span class="token keyword">uniform</span> <span class="token keyword">samplerCube</span> cubeSampler<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>FragColor <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>cubeSampler<span class="token punctuation">,</span> uvw<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时在绘制天空盒时，由于深度缓冲盒天空盒的深度值都为1，深度测试时会出现zFighting现象。所以需要将深度测试函数设置为<strong>glDepthFunc(GL_LEQUAL)</strong>，让深度值等于1时也可用通过深度测试，这样场景中没有物体的部分会被填充为天空盒的颜色。</p><h3 id="环境映射"><a href="#环境映射" class="headerlink" title="环境映射"></a>环境映射</h3><p>我们将立方体贴图当作我们的天空盒，我们也同样可用将该<strong>立方体贴图</strong>应用在物体的<strong>环境光</strong>上。通过使用环境的立方体贴图，我们可以给物体<strong>反射</strong>和<strong>折射</strong>的属性。这样使用<strong>环境立方体贴图</strong>的技术叫做环境映射(Environment Mapping)</p><p>本质上就是给物体再加上一个立方体贴图用作环境光贴图，通过计算视线方向盒法线向量的反射方向，根据反射方向去立方体贴图上采样，作为环境光叠加到物体身上。</p><pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token comment">//---------------------------------------vertexShader</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">460</span> core</span></span><span class="token keyword">layout</span><span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token keyword">vec3</span> aPosition<span class="token punctuation">;</span><span class="token keyword">layout</span><span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token keyword">vec2</span> aUv<span class="token punctuation">;</span><span class="token keyword">layout</span><span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token keyword">vec3</span> aNormal<span class="token punctuation">;</span><span class="token keyword">out</span> <span class="token keyword">vec2</span> uv<span class="token punctuation">;</span><span class="token keyword">out</span> <span class="token keyword">vec3</span> normal<span class="token punctuation">;</span><span class="token keyword">out</span> <span class="token keyword">vec3</span> worldPosition<span class="token punctuation">;</span><span class="token keyword">uniform</span> <span class="token keyword">mat4</span> model<span class="token punctuation">;</span><span class="token keyword">uniform</span> <span class="token keyword">mat4</span> view<span class="token punctuation">;</span><span class="token keyword">uniform</span> <span class="token keyword">mat4</span> projection<span class="token punctuation">;</span><span class="token keyword">uniform</span> <span class="token keyword">mat3</span> normalMatrix<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>uv <span class="token operator">=</span> <span class="token keyword">vec2</span><span class="token punctuation">(</span>aUv<span class="token punctuation">.</span>x<span class="token punctuation">,</span> aUv<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>normal <span class="token operator">=</span> normalMatrix <span class="token operator">*</span> aNormal<span class="token punctuation">;</span><span class="token keyword">vec4</span> position <span class="token operator">=</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span>aPosition<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>worldPosition <span class="token operator">=</span> <span class="token punctuation">(</span>model <span class="token operator">*</span> position<span class="token punctuation">)</span><span class="token punctuation">.</span>xyz<span class="token punctuation">;</span>gl_Position <span class="token operator">=</span> projection <span class="token operator">*</span> view <span class="token operator">*</span> model <span class="token operator">*</span> position<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//---------------------------------------fragmentShader</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">460</span> core</span></span><span class="token keyword">out</span> <span class="token keyword">vec4</span> FragColor<span class="token punctuation">;</span><span class="token keyword">in</span> <span class="token keyword">vec2</span> uv<span class="token punctuation">;</span><span class="token keyword">in</span> <span class="token keyword">vec3</span> normal<span class="token punctuation">;</span><span class="token keyword">in</span> <span class="token keyword">vec3</span> worldPosition<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">DirectionLight</span><span class="token punctuation">&#123;</span><span class="token keyword">vec3</span> direction<span class="token punctuation">;</span><span class="token keyword">vec3</span> color<span class="token punctuation">;</span><span class="token keyword">float</span> specularIntensity<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">PointLight</span><span class="token punctuation">&#123;</span><span class="token keyword">vec3</span> position<span class="token punctuation">;</span><span class="token keyword">vec3</span> color<span class="token punctuation">;</span><span class="token keyword">float</span> specularIntensity<span class="token punctuation">;</span><span class="token keyword">float</span> k1<span class="token punctuation">;</span><span class="token keyword">float</span> k2<span class="token punctuation">;</span><span class="token keyword">float</span> kc<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">SpotLight</span><span class="token punctuation">&#123;</span><span class="token keyword">vec3</span> position<span class="token punctuation">;</span><span class="token keyword">vec3</span> color<span class="token punctuation">;</span><span class="token keyword">vec3</span> targetDirection<span class="token punctuation">;</span><span class="token keyword">float</span> innerLine<span class="token punctuation">;</span><span class="token comment">//cosθ</span><span class="token keyword">float</span> outerLine<span class="token punctuation">;</span><span class="token comment">//cosβ</span><span class="token keyword">float</span> specularIntensity<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">uniform</span> <span class="token keyword">sampler2D</span> diffuseSampler<span class="token punctuation">;</span><span class="token keyword">uniform</span> <span class="token keyword">sampler2D</span> specularSampler<span class="token punctuation">;</span><span class="token keyword">uniform</span> <span class="token keyword">samplerCube</span> cubeEnvSampler<span class="token punctuation">;</span><span class="token comment">//立方体贴图采样器</span><span class="token keyword">uniform</span> <span class="token keyword">float</span> shiness<span class="token punctuation">;</span><span class="token keyword">uniform</span> <span class="token keyword">vec3</span> cameraPosition<span class="token punctuation">;</span><span class="token keyword">uniform</span> DirectionLight directionLight<span class="token punctuation">;</span><span class="token keyword">uniform</span> SpotLight spotLight<span class="token punctuation">;</span><span class="token keyword">uniform</span> PointLight pointLight<span class="token punctuation">;</span><span class="token comment">//整体不透明度</span><span class="token keyword">uniform</span> <span class="token keyword">float</span> opacity<span class="token punctuation">;</span><span class="token comment">//计算漫反射</span><span class="token keyword">vec3</span> <span class="token function">calculateDiffuse</span><span class="token punctuation">(</span><span class="token keyword">vec3</span> lightDir<span class="token punctuation">,</span> <span class="token keyword">vec3</span> normal<span class="token punctuation">,</span> <span class="token keyword">vec3</span> lightColor<span class="token punctuation">,</span> <span class="token keyword">vec3</span> objColor<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//计算漫反射光</span><span class="token comment">//计算光线和法向量之间的夹角余弦值(颜色不能出现负数，要控制在0到1之间)</span><span class="token keyword">float</span> diffuse <span class="token operator">=</span> <span class="token function">clamp</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span><span class="token operator">-</span>lightDir<span class="token punctuation">,</span> normal<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//(lightColor * diffuse)表示该点吸收了多少光，再乘以objColor表示反射了多少光，就是最终反射光的颜色</span><span class="token keyword">vec3</span> diffuseColor <span class="token operator">=</span> lightColor <span class="token operator">*</span> diffuse <span class="token operator">*</span> objColor<span class="token punctuation">;</span><span class="token keyword">return</span> diffuseColor<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//计算镜面反射</span><span class="token keyword">vec3</span> <span class="token function">calculateSpecular</span><span class="token punctuation">(</span><span class="token keyword">vec3</span> lightDir<span class="token punctuation">,</span> <span class="token keyword">vec3</span> viewDir<span class="token punctuation">,</span> <span class="token keyword">vec3</span> normal<span class="token punctuation">,</span> <span class="token keyword">vec3</span> lightColor<span class="token punctuation">,</span> <span class="token keyword">float</span> specularIntensity<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//采样镜面反射纹理贴图的颜色</span><span class="token keyword">vec3</span> specularMaskColor <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>specularSampler<span class="token punctuation">,</span> uv<span class="token punctuation">)</span><span class="token punctuation">.</span>xyz<span class="token punctuation">;</span><span class="token comment">//计算镜面反射光</span><span class="token comment">//计算反射光方向</span><span class="token keyword">vec3</span> reflectDirection <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span><span class="token function">reflect</span><span class="token punctuation">(</span>lightDir<span class="token punctuation">,</span> normal<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//计算镜面反射光颜色</span><span class="token keyword">float</span> specular <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span><span class="token operator">-</span>viewDir<span class="token punctuation">,</span> reflectDirection<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">vec3</span> specularColor <span class="token operator">=</span> lightColor <span class="token operator">*</span> <span class="token function">pow</span><span class="token punctuation">(</span>specular<span class="token punctuation">,</span> shiness<span class="token punctuation">)</span> <span class="token operator">*</span> specularIntensity<span class="token punctuation">;</span><span class="token comment">//处理背面高光线性</span><span class="token keyword">float</span> flag <span class="token operator">=</span> <span class="token function">step</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token function">dot</span><span class="token punctuation">(</span><span class="token operator">-</span>lightDir<span class="token punctuation">,</span> normal<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> specularColor <span class="token operator">*</span> flag <span class="token operator">*</span> specularMaskColor<span class="token punctuation">.</span>x<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//计算立方体贴图环境反射光</span><span class="token keyword">vec3</span> <span class="token function">calculateAmbient</span><span class="token punctuation">(</span><span class="token keyword">vec3</span> viewDirN<span class="token punctuation">,</span> <span class="token keyword">vec3</span> normalN<span class="token punctuation">,</span> <span class="token keyword">vec3</span> objColor<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//计算反射向量</span><span class="token keyword">vec3</span> reflectDir <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span><span class="token function">reflect</span><span class="token punctuation">(</span>viewDirN<span class="token punctuation">,</span> normalN<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//根据反射向量去立方体贴图采样</span><span class="token keyword">return</span> <span class="token function">texture</span><span class="token punctuation">(</span>cubeEnvSampler<span class="token punctuation">,</span> reflectDir<span class="token punctuation">)</span><span class="token punctuation">.</span>rgb <span class="token operator">*</span> objColor<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">vec3</span> <span class="token function">getDirectionLightResult</span><span class="token punctuation">(</span>DirectionLight light<span class="token punctuation">,</span> <span class="token keyword">vec3</span> normal<span class="token punctuation">,</span> <span class="token keyword">vec3</span> objColor<span class="token punctuation">,</span> <span class="token keyword">vec3</span> viewDirection<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">vec3</span> result <span class="token operator">=</span> <span class="token keyword">vec3</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>result <span class="token operator">+=</span> <span class="token function">calculateDiffuse</span><span class="token punctuation">(</span>light<span class="token punctuation">.</span>direction<span class="token punctuation">,</span> normal<span class="token punctuation">,</span> light<span class="token punctuation">.</span>color<span class="token punctuation">,</span> objColor<span class="token punctuation">)</span><span class="token punctuation">;</span>result <span class="token operator">+=</span> <span class="token function">calculateSpecular</span><span class="token punctuation">(</span>light<span class="token punctuation">.</span>direction<span class="token punctuation">,</span> viewDirection<span class="token punctuation">,</span> normal<span class="token punctuation">,</span> light<span class="token punctuation">.</span>color<span class="token punctuation">,</span> light<span class="token punctuation">.</span>specularIntensity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//计算通用数据</span><span class="token keyword">vec3</span> normalN <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>normal<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">vec3</span> viewDirection <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>worldPosition <span class="token operator">-</span> cameraPosition<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">vec3</span> objColor <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>diffuseSampler<span class="token punctuation">,</span> uv<span class="token punctuation">)</span><span class="token punctuation">.</span>xyz<span class="token punctuation">;</span><span class="token keyword">float</span> alpha <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>diffuseSampler<span class="token punctuation">,</span> uv<span class="token punctuation">)</span><span class="token punctuation">.</span>a<span class="token punctuation">;</span><span class="token keyword">vec3</span> finalColor <span class="token operator">=</span> <span class="token keyword">vec3</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//计算平行光</span>finalColor <span class="token operator">+=</span> <span class="token function">getDirectionLightResult</span><span class="token punctuation">(</span>directionLight<span class="token punctuation">,</span> normalN<span class="token punctuation">,</span> objColor<span class="token punctuation">,</span> viewDirection<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//计算环境光</span><span class="token keyword">vec3</span> ambientColor <span class="token operator">=</span> <span class="token function">calculateAmbient</span><span class="token punctuation">(</span>viewDirection<span class="token punctuation">,</span> normalN<span class="token punctuation">,</span> objColor<span class="token punctuation">)</span><span class="token punctuation">;</span>finalColor <span class="token operator">+=</span> ambientColor<span class="token punctuation">;</span>FragColor <span class="token operator">=</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span>finalColor<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250727234541835.png" alt="image-20250727234541835" style="zoom:80%;" /><h2 id="实例化（Instancing）"><a href="#实例化（Instancing）" class="headerlink" title="实例化（Instancing）"></a>实例化（Instancing）</h2><h3 id="介绍-10"><a href="#介绍-10" class="headerlink" title="介绍"></a>介绍</h3><p>在之前的绘制中，我们的策略是对每一个mesh都调用一次绘制函数（DrawCall），但是执行一次绘制函数非常昂贵，会对性能产生非常大的影响。每次调用绘制时，都需要CPU向GPU发送一些数据和命令，对性能影响非常大。如果绘制一个大型场景，每个mesh都调用一次绘制函数，那么场景就会变得非常卡顿。</p><p>如果在一个大型场景中，大部分的模型包含的是同一组顶点数据和材质，只是模型变换不同。对于这样的物体，我们可用使用实例化的方式，只调用一次绘制函数，直接告诉GPU渲染N个这样的物体，可用大大提高性能。</p><p>由于每个物体只有模型变换不同，所以每个物体的模型变换矩阵（ModelMatrix）需要给出，以物体的不同变换。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250728113821698.png" alt="image-20250728113821698" style="zoom:50%;" /><h3 id="API-4"><a href="#API-4" class="headerlink" title="API"></a>API</h3><p>可以通过调用<strong>glDrawArraysInstanced</strong>或<strong>glDrawElementsInstanced</strong>函数即可实现实例化绘制。但是相比<strong>glDrawArrays</strong>和<strong>glDrawElements</strong>函数，实例化绘制函数的参数列表最后**多了一个实例数量(Instance Count)**的参数，它能够设置我们需要渲染的实例个数。</p><p>这样我们只需要将必须的数据发送到GPU一次，然后使用一次函数调用告诉GPU它应该如何绘制这些实例。GPU将会直接渲染这些实例，而不用不断地与CPU进行通信。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;实例化绘制函数和原始绘制函数参数列表相同，只是最后多了一个额外的参数instancecount，设置该实例渲染几个&#x2F;&#x2F;根据顶点顺序绘制void glDrawArrays(GLenum mode, GLint first, GLsizei count);&#x2F;&#x2F;根据顶点顺序绘制（实例化版本）void glDrawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei instancecount);&#x2F;&#x2F;根据顶点索引绘制void glDrawElements(GLenum mode, GLsizei count, GLenum type, const void *indices);&#x2F;&#x2F;根据顶点索引绘制（实例化版本）void glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>CPU向GPU传输数据有两种方式：Uniform和Attribute，我们要传输的<strong>模型变换矩阵数组</strong>也可以通过这两种方式传送到GPU。</p><h3 id="uniform更新策略"><a href="#uniform更新策略" class="headerlink" title="uniform更新策略"></a>uniform更新策略</h3><p>由于每个实例的模型变换矩阵不同，所以设置一个Uniform变量存储模型变换矩阵。</p><p>glsl中内置变量<strong>gl_InstanceID</strong>表示<strong>当前绘制的是第几个实例</strong>。在<strong>使用实例化渲染调用</strong>时，<strong>gl_InstanceID</strong>会<strong>从0开始</strong>，在<strong>每个实例被渲染时递增1</strong>。这样以来，对于<strong>每个实例的所有顶点</strong>来说，使用的都是<strong>同一个模型变换矩阵</strong>，也就能正确的应用模型变换。</p><p>结合模型变换矩阵数组和gl_InstanceID，我们就能正确地绘制出多个不同模型变换的物体，而且只调用了一次绘制函数。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250728115028104.png" alt="image-20250728115028104" style="zoom:50%;" /><h3 id="Attribute更新策略"><a href="#Attribute更新策略" class="headerlink" title="Attribute更新策略"></a>Attribute更新策略</h3><p>使用Uniform变量传输数据虽然较为简单，但是如果绘制一个非常大的场景，需要实例化的物体数量非常多，我们最终会超过最大能够发送至着色器的uniform数据大小（上限）。</p><p>因此可以采取<strong>实例化数组(Instanced Array)<strong>的方式传输数据，可以将这些模型变换矩阵数组</strong>存放到一个VBO</strong>中，让这些模型变换矩阵作为每个顶点的属性。</p><p>对于VBO中的每个属性（坐标、UV、法线等）来说，都是<strong>逐顶点进行更新</strong>的，也就是每处理下一个新的顶点，VBO都会自动跳到该属性的下一组数据中作为该顶点的属性，也就是说<strong>每个顶点拿到的属性值都不一样</strong>。但是对于我们的模型变换矩阵来说，<strong>每个实例的所有顶点的模型变换矩阵都应该一样</strong>，我们<strong>希望每渲染一个实例才更新到下一组矩阵数据</strong>。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250728120532989.png" alt="image-20250728120532989" style="zoom: 50%;" /><p>为了实现这一效果，我们可以用glVertexAttribDivisor函数设置某个属性值的更新策略。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250728120843150.png" alt="image-20250728120843150" style="zoom:50%;" /><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void glVertexAttribDivisor(Gluint index, Gluint divisor);&#x2F;&#x2F;案例&#x2F;&#x2F;设置uvVBO的属性glBindVertexArray(VAO);glBindBuffer(GL_ARRAY_BUFFER, uvVBO);glEnableVertexAttribArray(1);glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, sizeof(float)*2 (void*)0);glVertexAttribDivisor(1, 0);&#x2F;&#x2F;每个顶点更新一次，所有顶点拿到的都不一样glVertexAttribDivisor(1, 1);&#x2F;&#x2F;每个实例更新一次，同一实例的所有顶点拿到的都一样glVertexAttribDivisor(1, n);&#x2F;&#x2F;每n个实例更新一次，每n个实例的所有顶点拿到的都一样<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于我们传入的是一个四维矩阵的数组，里面有16个数据，但是opengl中一个顶点的<strong>Attribute最多支持四维向量</strong>的属性，我们没办法在一个属性内将矩阵传过去。</p><p>我们可以将四维矩阵拆分为4个四维列向量进行传输，每个列向量作为一个属性值，在shader中拿到四个列向量后再拼接为一个四维矩阵。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250728122259641.png" alt="image-20250728122259641" style="zoom:67%;" /><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;假设instanceCount &#x3D; 3，准备大小为3的模型变换矩阵数组glm::mat4 transforms[3];transforms[0] &#x3D; glm::mat4(1.0f);transforms[1] &#x3D; glm::translate(glm::mat4(1.0f), glm::vec3(3.0f, 0.0f, 0.0f));transforms[2] &#x3D; glm::translate(glm::mat4(1.0f), glm::vec3(2.0f, 3.0f, 0.0f));&#x2F;&#x2F;创建VBO，并将每个实例的变换矩阵数据传送到VBO中glGenBuffers(1, &amp;transformMatrixVBO);glBindBuffer(GL_ARRAY_BUFFER, transformMatrixVBO);glBufferData(GL_ARRAY_BUFFER, sizeof(glm::mat4) * instanceCount, transformMatrixs, GL_DYNAMIC_DRAW);&#x2F;&#x2F;将vbo绑定到vaoglBindVertexArray(vao);&#x2F;&#x2F;设置属性glEnableVertexAttribArray(3);glVertexAttribPointer(3, 4, GL_FLOAT, GL_FALSE, sizeof(glm::mat4), (void*)0);&#x2F;&#x2F;设置3号属性，每一个实例换到下一组数据glVertexAttribDivisor(3, 1);glEnableVertexAttribArray(4);glVertexAttribPointer(4, 4, GL_FLOAT, GL_FALSE, sizeof(glm::mat4), (void*)(sizeof(float)*4) );&#x2F;&#x2F;设置4号属性，每一个实例换到下一组数据glVertexAttribDivisor(4, 1);glEnableVertexAttribArray(5);glVertexAttribPointer(5, 4, GL_FLOAT, GL_FALSE, sizeof(glm::mat4), (void*)(sizeof(float)*8));&#x2F;&#x2F;设置5号属性，每一个实例换到下一组数据glVertexAttribDivisor(5, 1);glEnableVertexAttribArray(6);glVertexAttribPointer(6, 4, GL_FLOAT, GL_FALSE, sizeof(glm::mat4), (void*)(sizeof(float)*12));&#x2F;&#x2F;设置6号属性，每一个实例换到下一组数据glVertexAttribDivisor(6, 1);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终只调用了一次绘制函数，就绘制出了多个不同模型变换的同一物体。</p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250728122328266.png" alt="image-20250728122328266" style="zoom:50%;" />]]></content>
      
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题算法模板</title>
      <link href="/2025/11/22/%E7%AE%97%E6%B3%95/"/>
      <url>/2025/11/22/%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h1><p>​二分法用于在有序序列中快速查找，由于每次都会跳过一半的数据，所以时间复杂度为O(logn)。下面写一个通用的整数二分模板，该模板会返回序列中第一个<code>&gt;=</code>目标数<code>target</code>的数据的位置。</p><p>​所以这是一个万能模板，会返回序列中第一个<code>&gt;=</code>目标<code>target</code>的数的索引值，查找不到就返回数组长度。不论是找唯一数据的索引值、重复数据的左边界、大于<code>target</code>的第一个数的索引值（<code>target</code>不是数组的的某个值，但在数组的最大最小值之间），都可以直接用这个模板。</p><table><thead><tr><th align="center">需求</th><th align="center"><strong>写法</strong></th><th align="center"><strong>如果不存在</strong></th></tr></thead><tbody><tr><td align="center">≥ <em>x</em> 的第一个元素的下标</td><td align="center">lowerBound(<em>nums</em>, <em>x</em>)</td><td align="center">结果为 <em>n</em></td></tr><tr><td align="center">&gt; <em>x</em> 的第一个元素的下标</td><td align="center">lowerBound(<em>nums</em>, <em>x</em> + 1)</td><td align="center">结果为 <em>n</em></td></tr><tr><td align="center">&lt; <em>x</em> 的最后一个元素的下标</td><td align="center">lowerBound(<em>nums</em>, <em>x</em>) − 1</td><td align="center">结果为 −1</td></tr><tr><td align="center">≤ <em>x</em> 的最后一个元素的下标</td><td align="center">lowerBound(<em>nums</em>, <em>x</em> + 1) − 1</td><td align="center">结果为 −1</td></tr></tbody></table><table><thead><tr><th align="center">需求(数组下标从0开始)</th><th align="center"><strong>写法</strong></th></tr></thead><tbody><tr><td align="center">&lt; <em>x</em> 的元素个数</td><td align="center">lowerBound(<em>nums</em>, <em>x</em>)</td></tr><tr><td align="center">≤ <em>x</em> 的元素个数</td><td align="center">lowerBound(<em>nums</em>, <em>x</em>+1)</td></tr><tr><td align="center">≥ <em>x</em> 的元素个数</td><td align="center"><em>n</em>−lowerBound(<em>nums</em>, <em>x</em>)</td></tr><tr><td align="center">&gt; <em>x</em> 的元素个数</td><td align="center"><em>n</em>−lowerBound(<em>nums</em>, <em>x</em>+1)</td></tr></tbody></table><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;返回序列中第一个 &gt;&#x3D; targrt的数的索引值（找不到就返回数组的总长度len，因为l一直向右移动，直到出界）int lowerBound(vector&lt;int&gt;nums, int target)&#123;    &#x2F;&#x2F;这里我们要返回的索引值范围是[left, right]，都是闭区间，所以当left &gt; right时该区间为空，说明查找结束    int left &#x3D; 0, right &#x3D; nums.size() - 1;    while(left &lt;&#x3D; right)    &#123;        &#x2F;&#x2F;防止left + right数据溢出        int mid &#x3D; left + (right - left) &#x2F; 2;        if(nums[mid] &gt;&#x3D; target)right &#x3D; mid - 1;        else left &#x3D; mid + 1;    &#125;    return left;&#125;&#x2F;&#x2F;假设查找的数据都是合理的，找不到会返回len&#x2F;&#x2F;如果序列中数据唯一，不重复，那么最终返回target的索引值nums &#x3D; [1, 2, 3, 4, 5, 6, 7];lowerBound（nums, 3) ---&gt;最终返回3的索引值2;    &#x2F;&#x2F;如果序列中数据可以重复，那么最终返回target的左边界的索引值（第一个 &gt;&#x3D; target的数的位置）nums &#x3D; [1, 2, 2, 3, 3, 3, 4, 5, 6, 7];lowerBound（nums, 3) ---&gt;最终返回3的左边界3;&#x2F;&#x2F;如果要查找的数据在序列最大值和最小值范围内target∈[min, max]，会返回第一个 &gt; target的数的位置nums &#x3D; [1, 6, 8, 10, 10, 12, 18, 25, 33];lowerBound（nums, 11) ---&gt;最终返回第一个大于11的数12的位置5;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​上面说到的都是找到<code>&gt;=target</code>的位置，一般用于找target唯一索引  <strong>或者</strong>  <code>target</code>的左边界  <strong>或者</strong>  第一个<code>&gt;target</code>（<code>target</code>不在数组中，但是在数组的最大最小值范围中）。</p><p>​可以进行一些小转换，用于找到第一个<code>&gt;target</code>的值的索引，和前面的不同的是原始的模板只有当target不在数组中时才会返回第一个<code>&gt;target</code>的值的索引，而当target在数组中时无法处理，比如找到<code>target</code>的右边界，原始的模板无法处理。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;----------------------------------1.要找到 &gt;target 的第一个数的索引&#x2F;&#x2F;如果target+1存在，那么自然会找到第一个target+1的位置，那么就是第一个&gt;target的位置&#x2F;&#x2F;如果target+1不存在，那么后面找到的位置仍然是第一个&gt;target的位置lowerBound（nums, target + 1);nums &#x3D; [1, 2, 3, 4, 5, 9, 10];lowerBound（nums, 4 + 1);&#x2F;&#x2F;target&#x3D;4，lowerBound(nums, 4+1)会找到第一个&gt;&#x3D;5的数5，其位置为4lowerBound（nums, 5 + 1);&#x2F;&#x2F;target&#x3D;5，lowerBound(nums, 5+1)会找到第一个&gt;&#x3D;6的数9，其位置为5&#x2F;&#x2F;----------------------------------2.要找到 &lt;target 的第一个数的索引&#x2F;&#x2F;如果target存在，那么自然会找到target的左边界，那么左边界-1就是第一个 &lt;target 的第一个数的索引&#x2F;&#x2F;如果target不存在，那么后面找到的位置仍然是第一个&gt;target的位置，此位置-1就是第一个 &lt;target 的第一个数的索引lowerBound（nums, target) - 1;nums &#x3D; [1, 2, 5，5, 9, 11];&#x2F;&#x2F;target&#x3D;5，lowerBound(nums, 5)会找到的位置第一个&gt;&#x3D;5的数5，其位置为2，减一为1，而1就是符合要求的索引lowerBound（nums, 5) - 1;&#x2F;&#x2F;target&#x3D;4，lowerBound(nums, 4)会找到的位置第一个&gt;&#x3D;4的数5，其位置为2，减一为1，而1就是符合要求的索引lowerBound（nums, 4) - 1;&#x2F;&#x2F;----------------------------------3.要找到 &lt;&#x3D;target 的最后一个数的索引&#x2F;&#x2F;如果target存在，会找到target的右边界&#x2F;&#x2F;如果target不存在，会找到最后一个&lt;target的值的索引lowerBound（nums, target + 1) - 1;nums &#x3D; [1, 2, 5，5, 9, 11];&#x2F;&#x2F;target&#x3D;5，lowerBound(nums, 6)会找到nums[4]&#x3D;9的位置，该位置减一为3，就是target的右边界lowerBound（nums, 6) - 1;&#x2F;&#x2F;target&#x3D;3，lowerBound(nums, 4)会找到nums[2]&#x3D;5的位置，该位置减一为1，就是最后一个小于target的数的索引lowerBound（nums, 4) - 1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="最终结果取模"><a href="#最终结果取模" class="headerlink" title="最终结果取模"></a>最终结果取模</h1><p>​最终的各种计算时取模的代码如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">MOD &#x3D; 1_000_000_007&#x2F;&#x2F; 加(a + b) % MOD&#x2F;&#x2F; 减，b 在 [0,MOD-1] 中(a - b + MOD) % MOD&#x2F;&#x2F; 把任意整数 a 取模到 [0,MOD-1] 中，无论 a 是正是负(a % MOD + MOD) % MOD&#x2F;&#x2F; 乘（注意使用 64 位整数）a * b % MOD&#x2F;&#x2F; 多个数相乘，要步步取模，防止溢出a * b % MOD * c % MOD&#x2F;&#x2F; 除（MOD 是质数且 b 不是 MOD 的倍数），qpow是快速幂a * qpow(b, MOD - 2, MOD) % MOD<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p>滑动窗口使用前提：</p><ol><li><strong>连续</strong>子数组&#x2F;子串。（注意<strong>不是子序列</strong>，必须是<strong>连续的子串或者子数组</strong>）</li><li>有<strong>单调性</strong>，即<strong>所求的目标会随着窗口的变化单调变化</strong>。例如正数数组，或者负数数组，窗口内数组的和会随着数组的大小变化单调变化；但是如果数组内有正有负的话，就不满足单调性了，就无法使用滑动窗口解决。</li></ol><h2 id="定长窗口"><a href="#定长窗口" class="headerlink" title="定长窗口"></a>定长窗口</h2><p>​定长窗口的题目求解目标一般明确指出<strong>要求长度为k</strong>的<strong>符合要求</strong>的<strong>连续子数组或者子串</strong>。可以直接<strong>从0到n - 1枚举所有右端点</strong>，枚举所有以<strong>i位置为右端点</strong>的窗口，从中找到符合要求的答案。</p><p>​下面是算法模板：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int solution(vector&lt;int&gt;&amp; nums, int k)&#123;    int n &#x3D; nums.size(), left &#x3D; 0, ans &#x3D; 0;    &#x2F;&#x2F;枚举所有右端点    for(int i &#x3D; 0; i &lt; n; i++)    &#123;        &#x2F;&#x2F;右端点进入窗口        ...;&#x2F;&#x2F;计算                &#x2F;&#x2F;因为要求长度为k，所有窗口大小为k时才符合要求        if(i - left + 1 &lt; k)            continue;                &#x2F;&#x2F;此时窗口大小已经为k了，就找到了一个长度为k的窗口        ...;&#x2F;&#x2F;计算该窗口，更新结果ans                left++;&#x2F;&#x2F;左端点向前移动    &#125;    return ans;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="动长窗口"><a href="#动长窗口" class="headerlink" title="动长窗口"></a>动长窗口</h2><p>​动长窗口的题目一般不会对子数组或者子串的长度进行限制，<strong>一般会要求出满足某种限制条件的子数组或子序列</strong>，这种情况下窗口的大小就是不固定的。</p><p>​下面是算法模板：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int solution(vector&lt;int&gt;&amp; nums, int k)&#123;    int n &#x3D; nums.size(), left &#x3D; 0, ans &#x3D; 0;    &#x2F;&#x2F;枚举所有右端点    for(int i &#x3D; 0; i &lt; n; i++)    &#123;        &#x2F;&#x2F;右端点进入窗口        ...;&#x2F;&#x2F;计算                &#x2F;&#x2F;当窗口内的子数组或者子序列不满足条件时，循环让左端点移出窗口，直到满足限制条件        while(!限制条件)        &#123;            &#x2F;&#x2F;左端点移出窗口，直到该窗口内地子数组或者子序列满足限制条件            ...;&#x2F;&#x2F;执行左端点移出的更新操作            left++;        &#125;                &#x2F;&#x2F;此时的窗口是满足题目中限制条件的        ...;&#x2F;&#x2F;计算该窗口，更新结果ans    &#125;    return ans;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h1><h2 id="高精度加"><a href="#高精度加" class="headerlink" title="高精度加"></a>高精度加</h2><p>​问题：两个长度为1000（或者更长，以至于无法用某一个类型表示它）的大正整数<strong>A和B</strong>相加，输出<strong>A+B</strong>的结果。</p><p>​显然这么多位的数字，我们无法用任何一个数值类型变量存储，所以就需要使用高精度加方法来模拟计算。高精度加就是使用一个数组存储大整数的每一位，然后模拟加法运算。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123;    string a, b;    cin&gt;&gt;a&gt;&gt;b;        &#x2F;&#x2F;输入，因为要从个位开始加，所以逆序存储大整数    vector&lt;int&gt;va, vb;    for(int i &#x3D; a.size() - 1; i &gt;&#x3D; 0; i--) va.push_back(a[i] - &#39;0&#39;);    for(int i &#x3D; b.size() - 1; i &gt;&#x3D; 0; i--) vb.push_back(b[i] - &#39;0&#39;);        &#x2F;&#x2F;计算，向前进位    vector&lt;int&gt; ans;    int t &#x3D; 0; &#x2F;&#x2F;t承担进位，最低位没有进位，初始值为0    for(int i &#x3D; 0 ; i &lt; va.size() || i &lt; vb.size(); i++)    &#123;        if(i &lt; va.size()) t +&#x3D; va[i];        if(i &lt; vb.size()) t +&#x3D; vb[i];        ans.push_back(t % 10);        t &#x2F;&#x3D; 10; &#x2F;&#x2F;如果当前位相加的值 &gt;&#x3D; 10则t&#x2F;10 &#x3D;&#x3D; 1，表示向前进位，否则t&#x2F;10 &#x3D;&#x3D; 0，不会向前进位    &#125;    &#x2F;&#x2F;判断最高位是否还需要向前进位    if(t) ans.push_back(t);        &#x2F;&#x2F;逆序输出    for(int i &#x3D; ans.size() - 1; i &gt;&#x3D; 0; i--)        cout &lt;&lt; ans[i];    cout &lt;&lt; endl;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="高精度减"><a href="#高精度减" class="headerlink" title="高精度减"></a>高精度减</h2><h2 id="高精度乘"><a href="#高精度乘" class="headerlink" title="高精度乘"></a>高精度乘</h2><h2 id="高精度除"><a href="#高精度除" class="headerlink" title="高精度除"></a>高精度除</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++学习</title>
      <link href="/2025/11/22/C++/"/>
      <url>/2025/11/22/C++/</url>
      
        <content type="html"><![CDATA[<h1 id="C-三-五-零法则"><a href="#C-三-五-零法则" class="headerlink" title="C++三&#x2F;五&#x2F;零法则"></a>C++三&#x2F;五&#x2F;零法则</h1><h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><table><thead><tr><th>特性&#x2F;容器</th><th>set</th><th>map</th><th>unordered_set</th><th>unordered_map</th><th>vector</th></tr></thead><tbody><tr><td>底层数据结构</td><td>红黑树</td><td>红黑树</td><td>哈希表</td><td>哈希表</td><td>动态数组</td></tr><tr><td>元素顺序</td><td>有序</td><td>有序</td><td>无序</td><td>无序</td><td>插入顺序</td></tr><tr><td>查找效率</td><td>O(log n)</td><td>O(log n)</td><td>平均 O(1)，最坏 O(n)</td><td>平均 O(1)，最坏 O(n)</td><td>O(n)</td></tr><tr><td>插入效率</td><td>O(log n)</td><td>O(log n)</td><td>平均 O(1)，最坏 O(n)</td><td>平均 O(1)，最坏 O(n)</td><td>平均 O(1)，最坏 O(n)</td></tr><tr><td>元素唯一性</td><td>是</td><td>键是，值否</td><td>是</td><td>键是，值否</td><td>否</td></tr><tr><td>元素类型</td><td>单一值</td><td>键值对</td><td>单一值</td><td>键值对</td><td>单一值</td></tr><tr><td>支持随机访问</td><td>否</td><td>否</td><td>否</td><td>否</td><td>是</td></tr></tbody></table><h2 id="set系列"><a href="#set系列" class="headerlink" title="set系列"></a>set系列</h2><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>​<code>set</code>是<code>c++</code>标准模板库中的一部分，可以存储<strong>唯一</strong>的元素（即set中的元素不允许重复，都是唯一的）,而这些元素按照<strong>某种顺序排列</strong>（顺序可以自定义，默认是从小到大排列）。<code>set</code>的底层是使用红黑树实现的，所以即使在大量数据面前，操作（如插入、删除、查找）的效率也非常高，时间复杂度保持在 <code>O(log n)</code>。</p><p>​<code>set</code>的应用场景非常广泛，从<strong>数据去重</strong>，到<strong>构建有序元素集</strong>，再到支持<strong>快速查找</strong>操作，<code>set</code> 在很多方面都展示了其独特的价值。当我们想让数据唯一且有序的时候，<code>set</code>是一个很好的选择。</p><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p>​前面已经说过，set的底层是使用红黑树实现的，</p><h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h3 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h3><h2 id="map系列"><a href="#map系列" class="headerlink" title="map系列"></a>map系列</h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><h3 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h3><h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><h2 id="using"><a href="#using" class="headerlink" title="using"></a>using</h2><h2 id="override和final"><a href="#override和final" class="headerlink" title="override和final"></a>override和final</h2><h3 id="重写-override-、重载-overload-和隐藏-overwrite"><a href="#重写-override-、重载-overload-和隐藏-overwrite" class="headerlink" title="重写(override)、重载(overload)和隐藏(overwrite)"></a>重写(override)、重载(overload)和隐藏(overwrite)</h3><p>​首先来区分一下这三个概念，平时如果不注意的话会容易把他们混淆：</p><p>1．重写（override）的意思更接近<strong>覆盖</strong>，而且<strong>只会出现在继承关系</strong>中。在C++中是指<strong>派生类覆盖</strong>了<strong>基类的虚函数</strong>，这里的覆盖必须满足有<strong>相同的函数签名</strong>和<strong>返回类型</strong>，也就是说有<strong>相同的函数名、形参列表以及返回类型</strong>。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Base &#123;public:    virtual void Show() &#123; std::cout &lt;&lt; &quot;Base\n&quot;; &#125; &#x2F;&#x2F; 虚函数    virtual void Print(int a) &#123; std::cout &lt;&lt; &quot;Base\n&quot;; &#125; &#x2F;&#x2F; 虚函数&#125;;class Derived : public Base &#123;public:    &#x2F;&#x2F;函数名，参数类型，返回值都必须一样才会重写基类的函数    void Show() &#123; std::cout &lt;&lt; &quot;Derived\n&quot;; &#125; &#x2F;&#x2F; 重写基类虚函数        void Print(double b) &#123; std::cout &lt;&lt; &quot;Derived\n&quot;; &#125; &#x2F;&#x2F;没有重写，相当于子类自己增加的函数&#125;;int main() &#123;    Base* obj &#x3D; new Derived();    obj-&gt;Show(); &#x2F;&#x2F; 输出 &quot;Derived&quot;（动态绑定）    obj-&gt;Print(1.0); &#x2F;&#x2F; 输出 &quot;Base&quot;，因为子类的为Print(double)和基类的Print(int)，参数列表不同，不是重写&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2．重载（overload）指在<strong>同一个作用域</strong>内，定义多个<strong>同名函数</strong>，但它们的<strong>参数列表不同</strong>（参数类型、数量或顺序不同），即它们的<strong>函数名相同</strong>，但是<strong>函数签名不同</strong>。这种情况在类的构造函数中最容易看到，为了让类更方便使用，我们经常会重载多个构造函数。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class C&#123;public:    &#x2F;&#x2F;这都是函数重载    void Print(int a);  &#x2F;&#x2F;int  Print(int a); &#x2F;&#x2F;不允许一个作用域出现函数名和参数列表一样，仅仅返回类型不一样的函数，这样会引起二义性导致编译器不知道调用哪一个函数而报错。    void Print(int a, int b);    int  Print(int a, double b);&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3．隐藏（overwrite）的概念也十分容易与上面的概念混淆，隐藏也是<strong>发生在继承关系</strong>中。简单来说就是当派生类定义了与基类<strong>同名但不符合重写(override)条件</strong>的函数时，基类的所有同名函数会被<strong>隐藏</strong>（即使参数列表不同）。</p><p>​隐藏是指基类成员函数，无论它是否为虚函数，当派生类出现同名函数时，如果派生类函数签名不同于基类函数，则基类函数会被隐藏。如果派生类函数签名与基类函数相同，则需要确定基类函数是否为虚函数，如果是虚函数，则这里的概念就是重写；否则基类函数也会被隐藏。另外，如果还想使用基类函数，可以使用using关键字将其引入派生类。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Base1&#123;public:    void Print()    &#123;        std::cout &lt;&lt; &quot;Print Base1\n&quot;;    &#125;    void Show()    &#123;        std::cout &lt;&lt; &quot;Print Base1\n&quot;;    &#125;    int Hello(int a)    &#123;        std::cout &lt;&lt; &quot;Hello Base1\n&quot;;        return a;    &#125;&#125;;class Derive1 : public Base1&#123;public:    void Print(int a)    &#123;        std::cout &lt;&lt; &quot;Print Derive1\n&quot;;    &#125;    int Hello(int a)    &#123;        std::cout &lt;&lt; &quot;Hello Derive1\n&quot;;        return a;    &#125;&#125;;int main() &#123;    Base* obj &#x3D; new Derived();    obj-&gt;Show(); &#x2F;&#x2F; 输出 &quot;Derived&quot;（动态绑定）    obj-&gt;Print(1.0); &#x2F;&#x2F; 输出 &quot;Base&quot;，因为子类的为Print(double)和基类的Print(int)，参数列表不同，不是重写    Derive1 derive;  &#x2F;&#x2F;derive.Print(); 编译失败，因为子类中出现了同名但是不同参数列表的函数，基类的同名函数不能直接在子类中调用(所以叫隐藏)    derive.Base1::Print();&#x2F;&#x2F;被隐藏的基类函数，只能通过加上基类作用域Base1::访问    derive.Print(10);&#x2F;&#x2F;把基类的Print函数隐藏了，只能直接调用子类实现的    derive.Show(); &#x2F;&#x2F;子类没有实现同名函数，所以可以基类的函数不会被隐藏，子类可以直接调用    Base1* base &#x3D; new Derive1();    base-&gt;Hello(1); &#x2F;&#x2F;会输出Hello Base1，虽然子类实现了同名，同参数列表，同返回值的函数，但是由于基类中不是虚函数，所以会隐藏而不是重写&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="center"></th><th align="center">重载(overload)</th><th align="center">重写 or 覆盖(override)</th><th align="center">隐藏(overwrite)</th></tr></thead><tbody><tr><td align="center">发生场景</td><td align="center">同一作用域下多个重名函数</td><td align="center">只发生在继承关系的虚函数中</td><td align="center">只发生在继承关系中</td></tr><tr><td align="center">条件</td><td align="center">多个<strong>重名</strong>函数<strong>参数列表不同</strong>(参数数量、类型或顺序不同)</td><td align="center">基类为<strong>虚函数</strong>且子类定义<strong>一模一样的函数</strong>(返回值、函数名和参数列表都相同)</td><td align="center">子类实现两种函数：<br />1. 与基类函数重名但参数列表不同<br />2. 与基类函数一模一样，但基类中不是虚函数(如果是虚函数就是重写了)</td></tr></tbody></table><h3 id="override说明符"><a href="#override说明符" class="headerlink" title="override说明符"></a>override说明符</h3><p>​<strong>C++11</strong>标准提供了一个非常实用的<code>override</code>说明符，这个说明符<strong>必须放到虚函数的尾部</strong>，它明确告诉编译器这个虚函数需要覆盖基类的虚函数，一旦编译器发现该虚函数不符合重写规则，就会给出错误提示。也就是让编译器检查使用<code>override</code>修饰的函数是否符合重写的要求，不满足就会编译时报错。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Base2&#123;public:    &#x2F;&#x2F;编译失败，最底层的基类函数不能用override修饰    &#x2F;&#x2F;void Print(int a) override    &#x2F;&#x2F;&#123;    &#x2F;&#x2F;&#125;    virtual void Print()    &#123;    &#125;&#125;;class Derive2 : public Base2&#123;public:    &#x2F;&#x2F;编译失败，因为基类没有对应的虚函数    &#x2F;&#x2F;void Print(int a) override    &#x2F;&#x2F;&#123;    &#x2F;&#x2F;&#125;    void Print() override    &#123;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="final说明符"><a href="#final说明符" class="headerlink" title="final说明符"></a>final说明符</h3><p>​<strong>C++11</strong>标准引入<code>final</code>说明符，它告诉编译器<strong>该虚函数不能被派生类重写</strong>。<code>final</code>说明符用法和<code>override</code>说明符相同，需要声明在虚函数的尾部。除此之外，<code>final</code>还能用于<strong>修饰类</strong>，表明<strong>该类不能作为基类被继承</strong>。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Base3&#123;public:    virtual void Print() final    &#123;    &#125;&#125;;class Derive3 : public Base3&#123;public:        &#x2F;&#x2F;编译失败，因为基类中final修饰的虚函数不能被继承    &#x2F;&#x2F;void Print() override    &#x2F;&#x2F;&#123;    &#x2F;&#x2F;&#125;&#125;;class Base4 final&#123;&#125;;&#x2F;&#x2F;编译失败，final修饰的类不能被继承&#x2F;&#x2F;class Derive4 : public Base4&#x2F;&#x2F;&#123;&#x2F;&#x2F;&#x2F;&#x2F;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​另外，override和final没有作为像int，const，static那样保留的关键字，也就是说我们可以声明叫override或者final的变量或者类型，编译器不会报错。但是会容易出现错误和后期维护的难度，不建议使用。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;都是合法的int override &#x3D; 10;int final &#x3D; 10;class override&#123;&#125;;class final&#123;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><p>​<code>auto</code>关键字在C++98标准开始就已经存在了，当时auto是用来声明自动变量的，简单地说，就是拥有自动生命期的变量，显然这是多余的，现在我们几乎不会使用它。<strong>C++11</strong>标准赋予了<code>auto</code><strong>新的含义</strong>：声明变量时根据初始化表达式 自动推断该变量的类型、声明函数时函数返回值的占位符。</p><p>​<code>auto</code>占位符会让<strong>编译器去推导变量类型</strong>，如果我们编写的代码让编译器无法进行推导，那么使用auto会导致编译失败。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;编译失败，因为i并没有具体的值，所以auto无法推导i的类型auto i;i &#x3D; 5;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​根据上面的例子可以看出来，使用<code>auto</code>声明变量时必须要<strong>初始化变量</strong>，否则会编译失败。</p><h3 id="初始化推导规则"><a href="#初始化推导规则" class="headerlink" title="初始化推导规则"></a>初始化推导规则</h3><p>​<strong>1.<strong>如果<code>auto</code>声明的变量是</strong>按值初始化</strong>，则推导出的类型会<strong>忽略cv限定符</strong>。</p><p>​即在使用<code>auto</code>声明变量时，既<strong>没有使用引用</strong>，也<strong>没有使用指针</strong>，那么编译器在推导的时候会<strong>忽略const和volatile</strong>限定符。当然<code>auto</code>本身也可以使用<code>const</code>修饰。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int a &#x3D; 10;int b &#x3D; 10;&#x2F;&#x2F;---------------------------------------------1.初始化仅使用值，auto会忽略cv限定符auto tempA &#x3D; a; &#x2F;&#x2F;auto推到为int，没有constconst auto tempB &#x3D; a; &#x2F;&#x2F;auto推到为int，但是auto前使用const修饰，最终为const int&#x2F;&#x2F;---------------------------------------------2.初始化是指针或者引用，auto会带上cv限定符(如果原变量有的话)&#x2F;&#x2F;auto不能推导出引用，要显式加上引用符auto&amp; tempC1 &#x3D; a; &#x2F;&#x2F;声明为引用，会带上const修饰符，最终为const int&amp;auto&amp; tempC2 &#x3D; b; &#x2F;&#x2F;声明为引用，但是原变量没有const，所以最终为int&amp;&#x2F;&#x2F;指针类型可以显示声明（auto后面加上*），也可以让auto自动推导auto* tempP1 &#x3D; &a; &#x2F;&#x2F;auto推导为const int， 最终为const int*auto tempP2 &#x3D; &a;  &#x2F;&#x2F;auto推导为const int*，最终为const int*auto tempP3 &#x3D; &b; &#x2F;&#x2F;b没有const修饰，所以最终推导为int*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​根据上面的例子可以总结出：如果<strong>按值初始化</strong>，<code>auto</code>会<strong>忽略原变量的cv限定符</strong>；如果按<strong>引用或者指针</strong>初始化，<code>auto</code>会<strong>带上原变量的cv限定符</strong>（原变量有auto推导出来的就有，反之亦然）。</p><p>​从安全性角度思考，如果变量用<code>const</code>修饰后，肯定不希望被修改。<strong>普通的按值初始化</strong>，就是简单的把值复制给另一个变量，当然可以对这个新变量进行修改，所以<code>auto</code>会忽略对按值初始化的变量的cv限定符。但是使用<strong>引用或者指针初始化</strong>，对这个新变量操作就可能会修改原来的常量，这显然的不安全的，所以<code>auto</code>会对按引用或者指针初始化的变量加上原有的cv限定符。</p><p>​**2. **使用<code>auto</code>声明变量初始化时，目标对象如果是引用，则引用属性会被忽略。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int i &#x3D; 5;auto&amp; m &#x3D; i; &#x2F;&#x2F;auto推导为int，整体为int&amp;是引用类型auto n &#x3D; m; &#x2F;&#x2F;auto会推导为int，而不是int&amp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​<strong>3.</strong> 使用<code>auto</code>和万能引用声明变量时，对于左值会将<code>auto</code>推导为引用类型。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int i &#x3D; 1;auto&amp;&amp; m &#x3D; i; &#x2F;&#x2F;i为左值，auto推导为int&amp;，最终int&amp; &amp;&amp;引用折叠后为int&amp;auto&amp;&amp; n &#x3D; 10; &#x2F;&#x2F;10为右值，auto推导为int，最终int&amp;&amp;引用折叠后为int&amp;&amp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​<code>4.</code>使用<code>auto</code>声明变量，如果目标对象是一个数组或者函数，则<code>auto</code>会被推导为对应的指针类型。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int sum(int a1, int a2)&#123;return a1 + a2;&#125;int i[5];auto m &#x3D; i; &#x2F;&#x2F; auto推导类型为int*auto j &#x3D; sum; &#x2F;&#x2F; auto推导类型为int (__cdecl *)(int,int)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="函数返回类型推导"><a href="#函数返回类型推导" class="headerlink" title="函数返回类型推导"></a>函数返回类型推导</h3><p>​<strong>C++14</strong>标准支持对返回类型声明为<code>auto</code>的推导。但是如果函数内部有<strong>多个返回值</strong>时（有多个<code>return</code>语句），这些<strong>返回值的类型要统一</strong>，否则会编译不通过。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;根据返回值推导为intauto sum(int a1, int a2)&#123;return a1 + a2;&#125;&#x2F;&#x2F;会报错并提升推到类型int和float冲突，编译无法通过auto sum(int a1, int a2)&#123;if (1)return a1 + a2;elsereturn 1.0f;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="lambda中使用auto推导"><a href="#lambda中使用auto推导" class="headerlink" title="lambda中使用auto推导"></a>lambda中使用auto推导</h3><p>​在<strong>C++14</strong>标准中我们还可以把<code>auto</code>写到<code>lambda</code>表达式的形参中，这样就得到了一个泛型的<code>lambda</code>表达式，</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;lambda表达式的返回值可以显示给出，也可编译器自己推导auto square &#x3D; [](int x) -&gt; int &#123; return x * x; &#125;; &#x2F;&#x2F;显示指出auto square &#x3D; [](int x) &#123; return x * x; &#125;;  &#x2F;&#x2F; 自动推导&#x2F;&#x2F;该lambda表达式可以接收任意类型的两个参数，并且能够自动推导返回值类型auto l &#x3D; [](auto a, auto b) &#123; return a + b; &#125;;auto x &#x3D; l(1, 2.0f); &#x2F;&#x2F;传入的为int和float，最后返回类型推导为floatauto y &#x3D; l(1, 2);    &#x2F;&#x2F;传入的为int和int，最后返回类型推导为int<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><h2 id="noexpect"><a href="#noexpect" class="headerlink" title="noexpect"></a>noexpect</h2><h2 id="const-常量-、mutable-可变-和volatile-易变"><a href="#const-常量-、mutable-可变-和volatile-易变" class="headerlink" title="const(常量)、mutable(可变)和volatile(易变)"></a>const(常量)、mutable(可变)和volatile(易变)</h2><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>​<code>const</code> 是 <code>constant</code> 的缩写，本意是不变的，不易改变的意思。在 C++ 中是用来修饰内置类型变量，自定义对象，成员函数，返回值，函数参数。</p><p>​C++ <code>const</code> 允许指定一个语义约束，允许程序员<strong>告诉编译器某值是保持不变的</strong>。如果在编程中确实有某个值保持不变，就应该明确使用<code>const</code>，这样可以获得编译器的帮助。</p><h4 id="const修饰普通变量"><a href="#const修饰普通变量" class="headerlink" title="const修饰普通变量"></a>const修饰普通变量</h4><p>​当const修饰普通变量时，这个变量就会被编译器当作常量，且必须在定义时就给与初始化的值。而且修改一个常量的值是违法操作，编译器不允许常量的值被修改。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;const int t; &#x2F;&#x2F;不允许，const修饰的变量必须给予初始值&#x2F;&#x2F;const修饰的变量被编译器视作常量，不允许直接修改const int a &#x3D; 10;&#x2F;&#x2F;a &#x3D; 1; &#x2F;&#x2F;const修饰的变量的值不允许被修改const float b &#x3D; 5.0f;&#x2F;&#x2F;b &#x3D; 1.0f;&#x2F;&#x2F;虽然使用指针取地址的方式可以骗过编译器直接修改内存，但是编译器仍然认为变量a的值为原始值，不会被改变int* p &#x3D; (int*) &amp; a;*p &#x3D; 99;std::cout &lt;&lt; *p &lt;&lt; std::endl; &#x2F;&#x2F;输出99std::cout &lt;&lt; a &lt;&lt; std::endl;  &#x2F;&#x2F;输出10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​对于 <code>const</code>修饰的变量 <code>a</code>，我们取变量的地址并转换赋值给指向 <code>int</code> 的指针，然后利用 <code>*p = 99</code>; 重新对变量 <code>a</code> 地址内的值赋值。虽然地址内的值确实被修改为了<code>99</code>，但是直接输出a的值却仍然是<code>10</code>。</p><p>​虽然我们可以通过指针的实现绕过编译器的限制直接修改内存中的值，但是这<strong>会产生意想不到的后果</strong>，所以<strong>千万不要轻易修改</strong><code>const</code>修饰的变量的值。</p><h4 id="const修饰指针"><a href="#const修饰指针" class="headerlink" title="const修饰指针"></a>const修饰指针</h4><p>​const修饰指针有三种情况：</p><ul><li>const 修饰指针指向的内容，则内容为不可变量，即<strong>不允许修改指针所指向内存的内容</strong>。写法为<code>const int* p</code>。</li><li>const 修饰指针，则指针为不可变量，即<strong>不允许修改指针本身存储的内存地址</strong>。写法为<code>int* const p</code>。</li><li>const 修饰指针和指针指向的内容，则指针和指针指向的内容都为不可变量，即<strong>指针存储的内存地址和该内存地址所在内存的值都不允许修改</strong>。写法为<code>const int* const p</code>。</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a2 &#x3D; 10;int b2 &#x3D; 20;const int* cpa2 &#x3D; &a2;&#x2F;&#x2F;*cpa2 &#x3D; 12; &#x2F;&#x2F;不允许修改所指向内存的值cpa2 &#x3D; &b2;   &#x2F;&#x2F;可以修改指针所存储的内存地址int* const pca2 &#x3D; &a2;*pca2 &#x3D; 12;   &#x2F;&#x2F;可以修改所指向内存的值&#x2F;&#x2F;pca2 &#x3D; &b2; &#x2F;&#x2F;不允许修改指针所存储的内存地址const int* const cpca2 &#x3D; &a2;&#x2F;&#x2F;*cpca2 &#x3D; 12;  &#x2F;&#x2F;不允许修改所指向内存的值&#x2F;&#x2F;cpca2 &#x3D; &b2; &#x2F;&#x2F;不允许修改指针所存储的内存地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="const与函数"><a href="#const与函数" class="headerlink" title="const与函数"></a>const与函数</h4><p>​<code>const</code>与函数搭配时共有三种情况：</p><ul><li><code>const</code>修饰<strong>函数形参</strong></li><li><code>const</code>修饰<strong>函数返回值</strong></li><li><code>const</code>修饰<strong>类成员函数</strong></li></ul><p>​当函数参数使用const修饰后，函数内部就不能修改该参数的值了。对于基本数据类型(<code>int</code>、<code>float</code>等)不需要使用<code>const</code>修饰，但<strong>对于自定义类型或者类的对象</strong>来说，<strong>常常需要传递其指针或者引用</strong>，为了<strong>防止函数内部修改值</strong>，往往需要用<code>const</code>修饰。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void func(const int a)&#123;std::cout &lt;&lt; a &lt;&lt; std::endl;&#x2F;&#x2F;a++; &#x2F;&#x2F;禁止修改，因为a是const类型&#125;void func(const int* p)&#123;&#x2F;&#x2F;(*p)++; &#x2F;&#x2F;因此指针为const int*，所以不能修改内存值&#125;struct MyStruct&#123;int temp;&#125;;void func(const MyStruct&amp; p)&#123;&#x2F;&#x2F;p.temp &#x3D; 10; &#x2F;&#x2F;传来的引用也为const，禁止修改内部的值&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="const修饰函数返回值"><a href="#const修饰函数返回值" class="headerlink" title="const修饰函数返回值"></a>const修饰函数返回值</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​const也可修饰类的成员函数，当成员函数使用<code>const</code>修饰后，那么<strong>函数体内就不能修改类的成员变量</strong>。而且<code>const</code>修饰的类的实例对象只能调用<code>const</code>修饰的成员函数，这是为了保证const修饰的对象不能改变内部成员变量的值。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class MyClass&#123;public:MyClass(int a, float b):m_A(a), m_B(b)&#123;&#125;int GetA() const&#123;&#x2F;&#x2F;m_A &#x3D; 10; &#x2F;&#x2F;const修饰的成员函数不允许修改成员变量的值return m_A;&#125;void SetA(int a)&#123;m_A &#x3D; a; &#x2F;&#x2F;没有const修饰的成员函数可以自由修改成员变量的值&#125;float GetB() const&#123;&#x2F;&#x2F;m_B &#x3D; 5.0f; &#x2F;&#x2F;const修饰的成员函数不允许修改成员变量的值return m_B;&#125;void Print()&#123;std::cout &lt;&lt; &quot;Print&quot; &lt;&lt; std::endl;&#125;void PrintConst() const&#123;std::cout &lt;&lt; &quot;PrintConst&quot; &lt;&lt; std::endl;&#125;private:int m_A;float m_B;&#125;;int main()&#123;    &#x2F;&#x2F;普通的实例对象任何成员函数都可以调用    MyClass mc1(1, 1.0f);mc1.Print();mc1.PrintConst();        &#x2F;&#x2F;const修饰的实例对象只能调用const修饰的成员函数const MyClass mc2(2, 2.0f);&#x2F;&#x2F;mc2.Print(); &#x2F;&#x2F;const修饰的实例对象只能调用const修饰的成员函数mc2.PrintConst();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="底层const和顶层const"><a href="#底层const和顶层const" class="headerlink" title="底层const和顶层const"></a>底层const和顶层const</h4><table><thead><tr><th align="left">特性</th><th align="left">顶层 <code>const</code></th><th align="left">底层 <code>const</code></th></tr></thead><tbody><tr><td align="left"><strong>核心含义</strong></td><td align="left">对象<strong>本身</strong>存储的值是常量，不可修改。</td><td align="left"><strong>指针或引用</strong>所指向&#x2F;绑定的<strong>对象</strong>是常量，不可通过该指针&#x2F;引用修改。</td></tr><tr><td align="left"><strong>作用对象</strong></td><td align="left">任意类型（内置类型、类、指针等）。</td><td align="left">主要与指针和引用相关。</td></tr><tr><td align="left"><strong>典型示例</strong></td><td align="left"><code>const int a = 10;</code> <code>int *const p = &amp;x;</code>（常量指针）</td><td align="left"><code>const int *p = &amp;a;</code>（指向常量的指针） <code>const int &amp;r = a;</code>（常量引用）</td></tr><tr><td align="left"><strong>拷贝操作影响</strong></td><td align="left"><strong>可忽略</strong>。一个拥有顶层<code>const</code>的对象可以被拷贝给非<code>const</code>对象。（这个变量本身存储的值不可以被改变，但是可以把值赋值给其他变量）</td><td align="left"><strong>不可忽略</strong>。进行拷贝时，双方必须具有相同的底层<code>const</code>资格，或者能将非常量转换为常量。（因为要保证不能通过指针或引用改变指向内容的值，所以拷贝的对象也不能通过指针或引用的方式修改值）</td></tr></tbody></table><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><h2 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h2><h2 id="implicit和explicit"><a href="#implicit和explicit" class="headerlink" title="implicit和explicit"></a>implicit和explicit</h2><p>​在C++中，<code>explicit</code>和<code>implicit</code>关键字控制着类型转换的行为方式。可用于修饰<strong>构造函数</strong>和<strong>类型转换函数</strong>。</p><h3 id="implicit"><a href="#implicit" class="headerlink" title="implicit"></a>implicit</h3><p>​当用户<strong>未标记为explicit</strong>时，<strong>默认为implicit</strong>，编译器会自动执行类型转换。在创建对象时，如果构造函数未标记<code>explicit</code>，那么编译器会自动根据函数参数隐式调用对应的构造函数创建对象。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class MyInt&#123;public:explicit MyInt(int data, int num)&#123;printf(&quot;Create\n&quot;);m_Data &#x3D; data;&#125;explicit MyInt(int data)&#123;printf(&quot;Create\n&quot;);m_Data &#x3D; data;&#125;MyInt(MyInt&amp; data)&#123;printf(&quot;Copy\n&quot;);m_Data &#x3D; data.m_Data;&#125;MyInt&amp; operator+(const MyInt&amp; other)&#123;m_Data +&#x3D; other.m_Data;return *this;&#125;        &#x2F;&#x2F;当需要将MyInt转换为int时会自动调用该函数实现隐式转换(默认为implicit)operator int()&#123;return m_Data;&#125;public:int m_Data;&#125;;int main()&#123;    &#x2F;&#x2F;编译器会隐式调用构造函数MyInt a(1, 2);MyInt a &#x3D; &#123; 1, 2 &#125;;    &#x2F;&#x2F;编译器会隐式调用构造函数MyInt a(10);MyInt b &#x3D; 10;    &#x2F;&#x2F;编译器会把10隐式转换为MyInt    MyInt c &#x3D; a + 10;    &#x2F;&#x2F;隐式调用operator int    int temp &#x3D; b;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h3><p>​当构造函数或者类型转换函数使用<code>explicit</code>关键字修饰后，不允许编译器隐式进行类型转换，必须显示调用才可以。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class MyInt&#123;public:explicit MyInt(int data, int num)&#123;printf(&quot;Create\n&quot;);m_Data &#x3D; data;&#125;explicit MyInt(int data)&#123;printf(&quot;Create\n&quot;);m_Data &#x3D; data;&#125;MyInt(MyInt&amp; data)&#123;printf(&quot;Copy\n&quot;);m_Data &#x3D; data.m_Data;&#125;MyInt&amp; operator+(const MyInt&amp; other)&#123;m_Data +&#x3D; other.m_Data;return *this;&#125;        &#x2F;&#x2F;必须显示转换才可以，不允许隐式转换为int    explicit operator int()&#123;return m_Data;&#125;    public:int m_Data;&#125;;int main()&#123;    &#x2F;&#x2F;标记为显示转换后，不允许编译器自动转换，只能手动显示转换&#x2F;&#x2F;MyInt a &#x3D; &#123; 1, 2 &#125;;    MyInt a(1, 2);    &#x2F;&#x2F;MyInt b &#x3D; 10;    MyInt a(10);    &#x2F;&#x2F;MyInt c &#x3D; a + 10;    MyInt c &#x3D; a + MyInt(10);    &#x2F;&#x2F;类型转换函数用explicit修饰后必须显示转换，不允许编译器隐式转换    &#x2F;&#x2F;int temp &#x3D; b;    int temp &#x3D; int(b);    int temp &#x3D; static_cast&lt;int&gt;(b);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="类的内存布局"><a href="#类的内存布局" class="headerlink" title="类的内存布局"></a>类的内存布局</h1><h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><p>​首先来看一个例子，<code>Data</code>结构体中有<code>int</code>类型和<code>char</code>类型两个成员变量，其中<code>int</code>类型大小为<strong>4</strong>字节，<code>char</code>类型大小为<strong>1</strong>字节，但是输出的结果却显示<code>Data</code>类型的大小是<strong>8</strong>个字节，显然并不是我们直觉上认为的4 + 1 &#x3D; 5字节，出现这种情况的原因就是<strong>内存对齐</strong>。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define LOG(X) std::cout &lt;&lt; X &lt;&lt; std::endlstruct Data&#123;int val;char ch;&#125;;int main()&#123;LOG(sizeof(int)); &#x2F;&#x2F;4字节LOG(sizeof(char)); &#x2F;&#x2F;1字节LOG(sizeof(Data)); &#x2F;&#x2F;8字节&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​虽然计算机内存是按照字节划分的，理论上任何一个内存地址都可以存储数据。但是实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是某个数k的倍数（通常为2、4、8等2的幂次方），这就是所谓的内存对齐。</p><p>​尽管内存按照字节划分，但是CPU并不是按照字节取内存的，现代CPU通常以字长（如4字节或8字节）为块来访问内存。假设CPU一次可以访问4字节内存，如果没有内存对齐的话，一个int类型的数据随意存放，那么访问这个数据就可能需要两次访问，并且两次访问还需要分别取出该数据对应的部分再拼一起，这显然会降低运行效率。如果内存对齐后，int类型的数据都存放在地址为4的整数倍的地方，那么CPU只需要一次就能拿到完整的数据。</p><p>​下面介绍一下对齐规则：</p><ol><li>基本数据类型的对齐值就是sizeof求出来的值，也即自身大小。</li><li>结构体内每个成员的起始地址（偏移量）必须是其类型对齐值的整数倍。为了满足这个要求，编译器会在成员之间自动插入填充字节。</li></ol><p>例如：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct Data&#123;char ch; &#x2F;&#x2F; 1字节，偏移量为0&#x2F;&#x2F;会在char后面补充3字节的padding，让int类型的偏移量为4的整数倍int val; &#x2F;&#x2F; 4字节，偏移量为4&#125;;&#x2F;&#x2F;所以对齐后Data类型的大小为8字节，其中char类型后面有3个字节的填充，后面就是int的四个字节<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>结构体的对齐值是其成员的最大对齐值，也就是说结构体变量的起始地址要是其对齐值的整数倍。</li><li>结构体的总大小必须是其内部最宽成员大小的整数倍。</li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct Data2&#123;int val; &#x2F;&#x2F;4字节char ch1; &#x2F;&#x2F;1字节char ch2; &#x2F;&#x2F;1字节&#x2F;&#x2F;结构体内部最大成员为4字节的int，所以结构体大小要为4的倍数，目前为6字节&#x2F;&#x2F;尾部填充两个字节&#125;;struct Data3&#123;char ch; &#x2F;&#x2F;1字节char ch1; &#x2F;&#x2F;1字节char ch2; &#x2F;&#x2F;1字节&#x2F;&#x2F;结构体内部最大成员为1字节的char，所以结构体大小要为1的倍数，不用填充&#125;;int main()&#123;    sizeof(Data2); &#x2F;&#x2F;8字节sizeof(Data3); &#x2F;&#x2F;3字节&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​前面的介绍是简化版本的，下面详细说明一下：</p><p>​每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数），可以通过预编译命令<code>#pragma pack(n)</code>，n &#x3D; 1,2,4,8,16来改变这一系数。</p><p>​每个类型的对齐值都会和这个对齐系数比较，较小的哪个就是有效对齐值；对于结构体来说，有效对齐值就是结构体中最长成员的长度和对齐系数的最小值。</p><p>​当我们使用<code>#pragma pack(n)</code>后，上面的几条规则都要在这个对齐系数的约束下求出有效对齐值之后再进行对齐。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#pragma pack(1) &#x2F;&#x2F;因为是取最小值，所以有效对齐值总是会为1struct Data&#123;char ch; &#x2F;&#x2F; 1字节，偏移量为0&#x2F;&#x2F;有效对齐值 &#x3D; min(1, 4) &#x3D;&#x3D; 1，所以val的有效对齐值为1，可以随便放，不会再char后面填充int val; &#x2F;&#x2F; 4字节，偏移量为1&#125;;sizeof(Data); &#x2F;&#x2F;此时Data大小为5字节#pragma pack(2)struct Data&#123;char ch; &#x2F;&#x2F; 1字节，偏移量为0&#x2F;&#x2F;有效对齐值 &#x3D; min(2, 4) &#x3D;&#x3D; 2，所以val的有效对齐值为2，偏移量必须为2的整数倍，所以要在char后面填充一个字节    int val; &#x2F;&#x2F; 4字节，偏移量为2&#125;;sizeof(Data); &#x2F;&#x2F;此时Data大小为6字节#pragma pack(2)struct Data4&#123;int val; &#x2F;&#x2F;4字节char ch1; &#x2F;&#x2F;1字节    &#x2F;&#x2F;有效对齐值 &#x3D; min(2, 4) &#x3D;&#x3D; 2，所以Data4的大小要为2的整数倍，所以char后面填充一个字节变为6&#125;;sizeof(Data4) &#x2F;&#x2F;此时Data4是6字节<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​一般情况下使用默认的对齐系数即可，无需特别设置<code>#pragram pack(n)</code>。</p><h2 id="RTTI"><a href="#RTTI" class="headerlink" title="RTTI"></a>RTTI</h2><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>​<code>C++</code>的多态有<strong>静态多态</strong>和<strong>动态多态</strong>。静态多态通过<strong>函数重载</strong>和<strong>模板</strong>实现；动态多态通过<strong>虚函数</strong>实现，下面所介绍的多态都是动态多态。下面举个例子说明一些多态的使用（<strong>基类的指针或引用指向子类对象</strong>）。</p><p>​先来看下面的一个案例，三个类都可以执行<code>Say()</code>函数，如果我想让每个类说的内容不一样，就必须在子类中也实现<code>Say()</code>函数才可以，并且只能用符合各自类型的对象、指针或引用才能调用正确的函数。<code>C++</code>中使用<code>virtual</code>关键字声明一个成员函数为虚函数，并且<strong>只能修饰普通的成员函数</strong>，<strong>静态成员函数和友元函数都不能声明为虚函数</strong>。当基类中声明一个虚函数之后，子类可以重写这个虚函数，此时使用<strong>基类的指针或引用指向子类对象</strong>，调用该虚函数时，会自动根据上下文信息找到正确类型的虚函数调用，也就是说一个函数接口在运行时可以有不同的功能。</p><p>​从下面的例子也能看出，只能用<strong>基类的指针</strong>或<strong>引用</strong>指向子类对象，如果直接用一个基类对象接收子类对象，会发生类型阶段，就完全变成了基类对象了。</p><p>​有了多态之后能方便我们实现各种功能，比如下面的<code>Print(Base*)</code>函数，函数只需要接收基类指针类型的形参，而调用该函数时可以传递基类或者子类的指针，并且函数内调用虚函数也会找到各自的实现。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Base&#123;public:Base()&#123;&#125;~Base()&#123;std::cout &lt;&lt; &quot; Base删除&quot; &lt;&lt; std::endl;&#125;    &#x2F;&#x2F;使用virtual关键字声明为虚函数virtual void Say()&#123;std::cout &lt;&lt; &quot;我是Base&quot; &lt;&lt; std::endl;&#125;&#125;;class Derive1 : public Base&#123;public:Derive1()&#123;&#125;~Derive1()&#123;std::cout &lt;&lt; &quot; Derive1删除&quot; &lt;&lt; std::endl;&#125;void Say() override&#123;std::cout &lt;&lt; &quot;我是Derive1&quot; &lt;&lt; std::endl;&#125;&#125;;class Derive2 : public Base&#123;public:Derive2()&#123;&#125;~Derive2()&#123;std::cout &lt;&lt; &quot; Derive2删除&quot; &lt;&lt; std::endl;&#125;void Say() override&#123;std::cout &lt;&lt; &quot;我是Derive2&quot; &lt;&lt; std::endl;&#125;&#125;;void Print(Base* b)&#123;b-&gt;Say();&#125;int main()&#123;&#x2F;&#x2F;Say不是虚函数时&#123;Base* b &#x3D; new Base();b-&gt;Say(); &#x2F;&#x2F;调用Base的Base* b1 &#x3D; new Derive1();b1-&gt;Say(); &#x2F;&#x2F;调用Base的Derive1 d1;Base&amp; b11 &#x3D; d1;b11.Say(); &#x2F;&#x2F;调用Base的Base* b2 &#x3D; new Derive2();b2-&gt;Say(); &#x2F;&#x2F;调用Base的Derive2 d2;Base&amp; b22 &#x3D; d2;b22.Say(); &#x2F;&#x2F;调用Base的Base b3 &#x3D; d1;b22.Say(); &#x2F;&#x2F;调用Base的Base b4 &#x3D; d2;b4.Say();  &#x2F;&#x2F;调用Base的delete b, b1, b2;&#125;&#x2F;&#x2F;Say是虚函数时（多态）&#123;Base* b &#x3D; new Base();b-&gt;Say(); &#x2F;&#x2F;指向Base对象，调用Base的Base* b1 &#x3D; new Derive1();b1-&gt;Say(); &#x2F;&#x2F;指向Derive1对象，调用Derive1的Derive1 d1;Base&amp; b11 &#x3D; d1;b11.Say(); &#x2F;&#x2F;Derive1对象引用，调用Derive1的Base* b2 &#x3D; new Derive2();b2-&gt;Say(); &#x2F;&#x2F;指向Derive2对象，调用Derive2的Derive2 d2;Base&amp; b22 &#x3D; d2;b22.Say(); &#x2F;&#x2F;Derive2对象的引用，调用Derive2的        Base b3 &#x3D; d1;b3.Say(); &#x2F;&#x2F;类型截断，调用Base的Base b4 &#x3D; d2;b4.Say(); &#x2F;&#x2F;类型截断，调用Base的delete b, b1, b2;&#125;       &#x2F;&#x2F;多态的方式实现函数参数传递&#123;Base* b &#x3D; new Base();Print(b); &#x2F;&#x2F;调用Base的Base* b1 &#x3D; new Derive1();Print(b1); &#x2F;&#x2F;调用Derive1的Base* b2 &#x3D; new Derive2();Print(b2); &#x2F;&#x2F;调用Derive2的delete b, b1, b2;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>​前面已经说过了，多态是利用虚函数来实现的，而虚函数的实现原理就是<strong>虚函数表(vtable)<strong>和</strong>虚函数表指针(vptr)</strong>。</p><p>​<strong>虚函数表（vtable）</strong>：是一个存放该类中所有虚函数地址的数组，每个有虚函数(或继承了有虚函数的基类)的类都会有一张虚函数表，他是C++<strong>运行时多态（动态绑定）</strong> 的核心机制。<strong>虚函数表由编译器在编译时生成（编译时就为该数组分配好了内存，值为每个虚函数的对应地址）</strong>，存放在程序的只读数据段。</p><p>​<strong>虚函数表指针（vptr）</strong>：一个指向虚函数表的指针，每个类的所有实例对象共享一张虚函数表，而每个对象都会有一个指向虚函数表的指针。虚函数表指针位于每个对象内存布局的最前面，由编译器负责创建和初始化。</p><p>​当每次调用虚函数时，会先根据对象内部的虚函数表指针找到该类的虚函数表，查表找到对应虚函数的地址，从而调用正确的虚函数，这都是运行时发生的。</p><p>​如下面的例子所示，一个空类的大小是1字节，但是声明了一个虚函数之后大小变为了8字节（32位机器中为4字节）。首先空类大小为1字节是因为C++要求每个对象的内存地址都要不同，如果空类大小为0的话，那么两个对象就有可能有相同的地址，所以空类大小为1字节。</p><p>​其次可以发现声明了虚函数之后，32为机器中类大小为4字节，64为机器中类大小为8字节，刚好是一个指针的长度。没错，这就是编译器自动为有虚函数的类的实例对象添加的虚函数表指针。通过这种方式也可以证明编译器确实会自动为有虚函数的类的实例对象创建一个虚函数表指针。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Test&#123;    void Say()&#123;&#125;&#125;;class TestVirtual&#123;    virtual void Say()&#123;&#125;&#125;;int main()&#123;    std::cout &lt;&lt; sizeof(Test) &lt;&lt; std::endl; &#x2F;&#x2F;大小为1std::cout &lt;&lt; sizeof(TestVirtual) &lt;&lt; std::endl; &#x2F;&#x2F;大小为8(32位机器是输出为4)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><h3 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h3><p>​如果子类单继承一个有虚函数的基类的话，编译器会根据基类的虚函数表来创建子类的虚函数表。这并不是简单的复制操作，如果子类重写了基类的虚函数，就把子类虚函数表对应的虚函数地址修改为子类实现的虚函数的地址，如果子类新增了虚函数，就在虚函数表尾部追加新增虚函数的地址。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Base&#123;public:Base()&#123;&#125;~Base()&#123;std::cout &lt;&lt; &quot; Base删除&quot; &lt;&lt; std::endl;&#125;virtual void Say()&#123;std::cout &lt;&lt; &quot;我是Base&quot; &lt;&lt; std::endl;&#125;&#125;;class Test&#123;    void Say()&#123;&#125;&#125;;class TestDerived : public Base&#123;    &#125;;int main()&#123;    std::cout &lt;&lt; sizeof(Test) &lt;&lt; std::endl; &#x2F;&#x2F;大小为1std::cout &lt;&lt; sizeof(TestDerived) &lt;&lt; std::endl; &#x2F;&#x2F;大小为8(32位机器是输出为4)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>​先看下面一个例子：</p><p>​使用基类指针指向了子类对象，当使用<code>delete</code>删除指针指向的内存时，会发现只调用了<code>Base</code>类的析构函数，并没有调用<code>Derive</code>类的析构函数。如果子类中有申请了一些资源，但并没得到释放，就造成了内存泄漏。为此就需要把<strong>基类的析构函数也声明为虚函数</strong>，这样使用<code>delete</code>删除指针时也会调用子类的析构函数，保证在子类中获取的资源能够正常释放。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Base&#123;public:~Base()&#123;std::cout &lt;&lt; &quot;Base删除&quot; &lt;&lt; std::endl;&#125;Base()&#123;&#125;virtual void Say()&#123;&#125;&#125;;class Derive : public Base&#123;public:~Derive()&#123;std::cout &lt;&lt; &quot;Derive删除&quot; &lt;&lt; std::endl;&#125;Derive()&#123;&#125;void Say() override&#123;&#125;&#125;;int main()&#123;Base* b &#x3D; new Derive();delete b; &#x2F;&#x2F;删除后只调用了Base的析构函数&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​虚析构函数的原理和普通虚函数一样，都是<strong>通过虚函数表和虚函数表指针实现的</strong>。当基类的析构函数声明为虚析构函数时，子类的析构函数也默认为虚析构函数，此时会在虚函数表中将子类的虚析构函数的函数地址添加到表中。</p><p>​当使用<code>delete</code>关键字删除基类指针时，会首先通过子类的虚函数表指针找到子类的析构函数并调用。子类的析构函数执行完毕之后，编译器会<strong>自动地、隐式地</strong>在代码末尾插入对直接基类析构函数的调用。这是一个<strong>编译期确定的静态调用</strong>，从而形成从派生类到基类的完整析构链。</p><p>​所以一般的多态情况下，一定要把基类的析构函数设置为虚函数。除非<strong>确定不会有通过基类指针删除派生类对象的行为</strong>或者<strong>基类不是为继承而设计的</strong></p><p>，在这些情况下不需要将基类的析构函数设置为虚函数，避免每个对象携带<strong>vptr</strong>的开销。</p><p>​所以<strong>多态中的析构</strong>是<strong>动态</strong>和<strong>静态</strong>两种机制协同工作的：</p><ul><li><strong>动态多态</strong>（通过vtable查找对应子类的析构函数地址）确保了析构的<strong>起点</strong>是正确的。</li><li><strong>静态编译</strong>确保了析构的<strong>链条</strong>是完整且顺序正确的（确定了析构起点后，每个子类都会由编译器自动调用其直接父类的析构函数）。</li></ul><h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>​当某个类中声明了一个纯虚函数时，这个类就叫做抽象类。抽象类不能被实例化，只能被继承，类似<code>Java</code>中的<code>Interface</code>。当某个子类继承了一个抽象类时，就必须重写基类中的纯虚函数，否则子类也会成为一个抽象类无法实例化。抽象类常被用来作为接口，强迫继承自己的子类必须提供相应的函数声明和实现。</p><p>​声明语法和虚函数类似：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Base&#123;    &#x2F;&#x2F;声明虚函数    virtual Test1();    &#x2F;&#x2F;声明纯虚函数    virtual Test2() &#x3D; 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​对于<strong>普通的虚函数</strong>来说：子类<strong>可以选择重写</strong>基类的虚函数，也<strong>可以不重写</strong>；但是<strong>基类必须提供虚函数的函数实现</strong>作为默认实现，否则实例化对象时就会编译错误。</p><p>​对于<strong>纯虚函数</strong>来说：子类<strong>必须重写</strong>基类的纯虚函数；基类<strong>可以给普通纯虚函数提供</strong>函数实现也<strong>可以不提供</strong>（因为子类一定重写），但是基类的<strong>纯虚析构函数必须要提供函数实现</strong>，因为编译器会自动调用基类的析构函数，不提供函数实现的话会编译错误。</p><p>​纯虚函数的函数声明要写在类内，定义必须写在类外。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class TestBase&#123;public:    &#x2F;&#x2F;纯虚析构函数必须要在类外提供函数定义virtual ~TestBase() &#x3D; 0;TestBase()&#123;&#125;    &#x2F;&#x2F;普通虚函数在基类中必须提供实现，即使函数体内没有内容也要写，是基类提供的默认实现，否则会编译错误virtual void Hello()&#123;&#125;    &#x2F;&#x2F;纯虚函数可以提供函数实现，也可以不提供virtual void Say() &#x3D; 0;&#125;;&#x2F;&#x2F;纯虚析构函数必须提供函数实现TestBase::~TestBase()&#123;    &#125;&#x2F;&#x2F;普通纯虚可以提供函数实现，也可以不提供void TestBase::Say()&#123;    &#125;class TestDerive : public TestBase&#123;public:virtual ~TestDerive()&#123;&#125;TestDerive()&#123;&#125;    &#x2F;&#x2F;子类必须重写基类的纯虚函数void Say() override&#123;&#125;&#125;;int main()&#123;&#123;Base* b &#x3D; new Derive();delete b; &#x2F;&#x2F;删除后只调用了Base的析构函数&#125;&#123;TestBase* tb &#x3D; new TestDerive();delete tb;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="left">特性</th><th align="left">普通虚函数</th><th align="left">纯虚函数</th></tr></thead><tbody><tr><td align="left">是否必须有实现</td><td align="left">✅ 必须</td><td align="left">❌ 不需要（普通纯虚函数可写也可不写），纯虚析构函数必须有实现</td></tr><tr><td align="left">子类是否必须实现</td><td align="left">❌ 可选</td><td align="left">✅ 必须</td></tr><tr><td align="left">基类能否实例化</td><td align="left">✅ 可以</td><td align="left">❌ 不行（抽象类）</td></tr><tr><td align="left">用途</td><td align="left">提供默认行为，子类可选覆盖</td><td align="left">定义接口规范，强制子类实现</td></tr></tbody></table><h3 id="为什么构造函数不能声明为虚函数？"><a href="#为什么构造函数不能声明为虚函数？" class="headerlink" title="为什么构造函数不能声明为虚函数？"></a>为什么构造函数不能声明为虚函数？</h3><p>​从逻辑上来说：多态是通过基类指针或引用指向子类对象来实现多态的，必须是对象创建完成以后才能使用多态特性的。而构造函数就是用来初始化对象的，在对象构造之前并没有对象产生，因此无法使用多态特性，这是矛盾的。</p><p>​从内存空间上来说：虚函数的调用需要虚函数表指针，虚函数表指针会存放在对象的内存空间中，而且虚函数表指针的初始化是在构造函数内部实现的。所以会陷入鸡生蛋蛋生鸡的矛盾中，所以构造函数不能声明为虚函数。</p><h3 id="为什么内联-inline-成员函数不能声明为虚函数？"><a href="#为什么内联-inline-成员函数不能声明为虚函数？" class="headerlink" title="为什么内联(inline)成员函数不能声明为虚函数？"></a>为什么内联(inline)成员函数不能声明为虚函数？</h3><p>​内联函数可以在编译时把函数调用展开为函数体，减少函数调用的开销，显然这是编译时由编译器完成的。但是多态是运行时绑定的，运行时才知道要调用的是哪一个函数。显然内联函数和多态的特性是相违背的，自然无法将内联的成员函数声明为虚函数。</p><h3 id="类成员函数（包括构造和析构）内调用虚函数"><a href="#类成员函数（包括构造和析构）内调用虚函数" class="headerlink" title="类成员函数（包括构造和析构）内调用虚函数"></a>类成员函数（包括构造和析构）内调用虚函数</h3><p>​首先说一下结论，在<strong>普通成员函数内调用虚成员函数是多态</strong>，在<strong>构造函数或析构函数中调用虚成员函数不是多态</strong>。</p><p>​首先，对象创建时调用的构造函数是从基类到派生类按顺序层层调用的，而他的虚函数表指针也是在构造过程中层层设置的。当基类的构造函数执行时，整个对象还只是一个基类的对象（子类的那部分还没有开始创建），此时虚函数表指针也只知道基类的虚函数表，所以只会调用当前知道的基类的虚函数，而不会如期的调用你想要的子类的虚函数。</p><p>​析构函数中调用虚函数也是同理。</p><p>​而普通的成员函数调用肯定是对象创建完成之后才能调用的，此时虚函数表指针正确的指向了子类的虚函数表，可以正确的调用虚函数。</p><h1 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h1><h1 id="运算符重载（operator）"><a href="#运算符重载（operator）" class="headerlink" title="运算符重载（operator）"></a>运算符重载（operator）</h1><h1 id="new和delete关键字"><a href="#new和delete关键字" class="headerlink" title="new和delete关键字"></a>new和delete关键字</h1><p>​<strong>C++<strong>中的<code>new</code>和<code>delete</code>是关键字，同时也是</strong>操作符</strong>，用于管理内存控件。<code>new</code>可以在堆区申请一块内存空间，而<code>delete</code>则负责释放某一指针指向的内存空间。说到这里就不得不提一下<strong>C语言</strong>中的<code>malloc()</code>和<code>free()</code><strong>函数</strong>了，他们是<strong>C语言</strong>中申请和释放内存的工具，这两个函数在**C++**中也是支持的。但要注意一点，这两套管理内存的工具要配套使用，即使用<code>new</code>申请的内存必须要使用<code>delete</code>释放，使用<code>malloc()</code>函数申请的内存必须要使用<code>free()</code>函数释放。不能混着用，更不能只申请而不释放内存，这样会造成内存泄漏。所以切记，申请了内存后，一定要使用对应的方式释放的那块内存。</p><p>​首先来详细说一下<strong>C语言</strong>的<code>malloc()</code>和<code>free()</code>函数，因为<code>new</code>和<code>delete</code>是<strong>C++<strong>的</strong>关键字</strong>，而<strong>C语言</strong>的<code>malloc()</code>和<code>free()</code><strong>是函数</strong>，所以会在函数后面加上<code>()</code>，以清晰的表面这是一个函数。</p><h2 id="C里的malloc-和free"><a href="#C里的malloc-和free" class="headerlink" title="C里的malloc( )和free( )"></a>C里的malloc( )和free( )</h2><p>​<strong>C语言</strong>申请空间都是在<strong>堆区</strong>上开辟的，而申请的方式有3种；<code>malloc()</code>、<code>calloc()</code>和<code>realloc()</code>，但是下面主要介绍的是<code>malloc()</code>函数。</p><ol><li><code>malloc</code>：函数原型<code>void* malloc(size_t size);</code> ，参数<code>size</code>为要分配的字节数，返回值是<code>void*</code>,通常要强转为我们需要申请空间的类型，开辟成功回返回空间首地址；<strong>失败会返回NULL</strong>。但是申请成功后并<strong>不进行初始化</strong>，每个数据都是随机值。</li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;在堆区申请一块连续内存作为数组int a[5]，但是里面的值没有初始化int* a &#x3D; (int*)malloc(sizeof(int) * 5);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li><code>calloc</code>：函数原型<code>void* calloc(size_t count, size_t size);</code>， 参数<code>count</code>为要申请的个数；<code>size</code>为每一个数据的大小，返回值是<code>void*</code>,通常要强转为我们需要申请空间的类型，开辟成功回返回空间首地址；<strong>失败会返回NULL</strong>。但是申请成功会对空间<strong>进行初始化</strong>，且<strong>初始为0</strong>。可以把函数的第一个字母c理解为<code>count</code>，表面可以指定个数。</li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;效果和上面使用malloc的等价，但是里面的值会初始化为0int* b &#x3D; (int*)calloc(5, sizeof(int));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="3"><li><code>realloc</code>：函数原型 <code>void* realloc(void * ptr, size_t size);</code> 参数<code>ptr</code>为要扩展调整的空间首地址，参数<code>size</code>为调整为多少字节的空间，返回值是<code>void*</code>，通常要强转为我们需要申请空间的类型，调整成功回返回调整后的空间首地址；<strong>调整失败会返回NULL，原内存不会被改变</strong>。但是申请成功后并<strong>不进行初始化</strong>，每个数据都是随机值。简单来说，这个函数会<strong>尝试重新调整</strong><code>ptr</code>所指向的内存块大小为<code>size</code>。如果<code>ptr</code>为空指针的话，会申请一个<code>size</code>字节大小的空间并返回指向该空间的指针，也就是说第一个参数为<code>NULL</code>时，作用就和<code>malloc</code>函数一样了。注意，使用该函数后，我们只需要负责释放掉返回的地址即可（如果返回值不为<code>NULL</code>的话），原先的内存函数内会帮我们调整，多余的会释放掉，不足的话会重新申请更大的内存空间释放旧内存空间或者在后面拓展内存。</li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int* temp &#x3D; (int*)calloc(5, sizeof(int));&#x2F;&#x2F;将temp指向的内存空间大小调整为1字节，返回的新地址有可能与temp相等，有可能不等int* c &#x3D; (int*)realloc(temp, 1);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​释放内存就比较简单了，只需要调用<code>free()</code>函数即可，其函数原型为free(void* ptr)，<code>ptr</code>参数是一个指向先前分配的内存块的指针。如果<code>ptr</code>为<code>NULL</code>，则<code>free</code>函数不执行任何操作。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int* a &#x3D; (int*)malloc(sizeof(int) * 5);free(a);int* b &#x3D; (int*)calloc(5, sizeof(int));free(b);int* temp &#x3D; (int*)calloc(5, sizeof(int));int* c &#x3D; (int*)realloc(temp, 1);free(c); &#x2F;&#x2F;使用ralloc函数调整内存后，只需要对返回的地址调用free函数即可，不需要再释放temp（返回值不为NULL的情况下）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="new-和-delete"><a href="#new-和-delete" class="headerlink" title="new 和 delete"></a>new 和 delete</h2><h3 id="new-operator-new和placement-new"><a href="#new-operator-new和placement-new" class="headerlink" title="new,operator new和placement new"></a>new,operator new和placement new</h3><p>​1. 首先要明确一点，<code>new</code>是<strong>C++<strong>里面的</strong>运算符</strong>，是一个关键字，类似于<code>sizeof</code>那种，我们无法改变其行为。<code>new</code>运算符要干的就是固定的三件事：<strong>1.<strong>调用名为<code>operator new</code>（或者<code>operator new[ ]</code>）的</strong>标准库函数</strong>，分配一块未初始化的、未命名的、足够大的内存空间以便我们存储指定的对象或者数组。**2.**编译器调用相应的构造函数创建对象并初始化。**3.**经过前两步的操作，对象以及分配了空间并初始化完成，返回一个指向该对象的指针。</p><p>​<code>new</code>运算符的具体使用如下，可以看到，我们不需要显示的给出所需内存的大小，<code>new</code>运算符会自动推导空间大小传递给对应的<code>operator new</code>函数。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">type* ptr1 &#x3D; new type;type* ptr2 &#x3D; new type(初始值);type* ptr3 &#x3D; new type[n];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​2. <code>operator new</code>是一个全局的标准库函数，可以被重载，让用户自定义内存分配的行为，默认行为就是简单地分配指定字节的未初始化的原始内存，其底层调用的仍然是<code>malloc</code>函数。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;定义全局的operator new函数，会隐藏掉默认的全局operator new函数，而调用我们的，所以我们必须实现内存的分配&#x2F;&#x2F;当new单个对象时，size为单个对象的内存大小void* operator new(size_t size)&#123;std::cout &lt;&lt; &quot;分配了&quot; &lt;&lt; size &lt;&lt; &quot;字节的数据&quot; &lt;&lt; std::endl;return malloc(size);&#125;&#x2F;&#x2F;当new一个数组时，size为整个数组所需的内存大小void* operator new[](size_t size)&#123;std::cout &lt;&lt; &quot;operator new[] : 分配了&quot; &lt;&lt; size &lt;&lt; &quot;字节的数据&quot; &lt;&lt; std::endl;return malloc(size);&#125;int main()&#123;    &#x2F;&#x2F;调用我们实现的全局operaotr new函数    int* a &#x3D; new int(10); &#x2F;&#x2F;分配4字节    int* arr &#x3D; new int[10]; &#x2F;&#x2F;分配40字节        delete a;    delete[] arr;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​我们也可以在类内重载<code>operator new</code>函数，以此实现每个类都可以有专属于自己的内存分配方式。可以看到，如果自定义类型内部重载了operator new函数之后，使用new创建该自定义对象时，会优先执行类内的重载版本。所以对于自定义类型，编译器<strong>会首先查找该类或者基类中是否有重载版本</strong>，如果有就调用；如果没有<strong>就到全局作用域查找</strong>，如果全局作用域有我们重载的，就会调用我们重载的版本；如果都<strong>没找到用户自定义的重载版本，就调用标准库的默认实现版本</strong>。</p><p>​还要一个需要注意的就是，类内重载的<code>operator new</code>函数必须为静态共有函数才可以正常使用，否则<code>new Test()</code>会编译错误。但是不用担心，类内重载的<code>operator new</code>函数是<strong>隐式静态</strong>的，我们<strong>无须显示声明它为静态函数</strong>，只需要设置为<code>public</code>即可。</p><p>​我们也可以使用 <code>::new Test()</code> 来<strong>指明在全局作用域内搜索operator new函数</strong>，而不是调用内类的重载版本。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;基本语法，返回值必须为void*，第一个参数为size_tvoid* operator new(size_t size)&#123;    &#x2F;&#x2F;具体实现&#125;void* operator new[](size_t size)&#123;    &#x2F;&#x2F;具体实现&#125;&#x2F;&#x2F;endclass Test&#123;public:Test()&#123;&#125;Test(int a, int b)&#123;&#125;    &#x2F;&#x2F;使用new构造单个Test对象时调用void* operator new(size_t size)&#123;std::cout &lt;&lt; &quot;Test::operator new : 分配了&quot; &lt;&lt; size &lt;&lt; &quot;字节的数据&quot; &lt;&lt; std::endl;return malloc(size);&#125;    &#x2F;&#x2F;使用new构造Test对象数组时调用void* operator new[](size_t size)&#123;std::cout &lt;&lt; &quot;Test::operator new[] : 分配了&quot; &lt;&lt; size &lt;&lt; &quot;字节的数据&quot; &lt;&lt; std::endl;return malloc(size);&#125;&#125;;int main()&#123;    Test* t1 &#x3D; new Test(1, 2); &#x2F;&#x2F;调用有参构造Test* t2 &#x3D; new Test(); &#x2F;&#x2F;调用无参构造,即使调用无参构造也必须带上()&#x2F;&#x2F;必须要有无参构造函数才可以编译通过，因为数组形式不能传递参数Test* tArr &#x3D; new Test[10];&#x2F;&#x2F;使用 ::new 显示调用全局的operator new，而不是调用类内重载的Test* tArr2 &#x3D; ::new Test[10];delete t1, t2;delete[] tArr;delete[] tArr2;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​3. <code>placement new</code>是<code>operator new</code>的特殊的重载版本，<strong>不可以被重载</strong>，它允许在一块已经分配好的内存上调用构造函数来构造对象，不会分配内存，只是对已分配好的内存调用构造函数构造对象进行初始化。定位new对应的是一个特殊的，不可被重载的operator new函数，它不会在内部分配内存，只是简单的返回传入的指针ptr。随后编译器就在该指针指向的内存空间上调用构造函数构造对象来初始化内存空间。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;placement new专属的operator new版本，不可被重载void* operator new(std::size_t, void* ptr) noexcept &#123; return ptr; &#125;&#x2F;&#x2F;定位new的写法new(ptr) type;new(ptr) type(初始值);new(ptr) type&#123;初始化值&#125;;new(ptr) type[n];new(ptr) type[n]&#123;初始化值&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​下面看一下具体使用的例子：</p><p>​可以看到下面四条<code>placement new</code>的语句中，指针的地址都没有发生变化，只是指向的内存空间中对象的值发生了变化，这就是<code>placement new</code>的用法。并且<code>placement new</code>不是普通的<code>new</code>，所以创建出来的对象不能使用<code>delete</code>释放，所以我们必须手动调用析构函数释放对象内的资源，防止内存泄漏。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Test&#123;public:Test()&#123;&#125;Test(int a, int b):val(a)&#123;&#125;~Test()&#123;&#125;void* operator new(size_t size)&#123;std::cout &lt;&lt; &quot;Test::operator new : 分配了&quot; &lt;&lt; size &lt;&lt; &quot;字节的数据&quot; &lt;&lt; std::endl;return malloc(size);&#125;void* operator new[](size_t size)&#123;std::cout &lt;&lt; &quot;Test::operator new[] : 分配了&quot; &lt;&lt; size &lt;&lt; &quot;字节的数据&quot; &lt;&lt; std::endl;return malloc(size);&#125;private:int val &#x3D; 0;&#125;;int main()&#123;    Test* t &#x3D; (Test*)malloc(sizeof(Test));    &#x2F;&#x2F;因为Test内部重载了operator new，但是定位new的是不能被重载的，所以要使用::new显示调用全局的，不然会编译错误        &#x2F;&#x2F;都会调用无参默认构造函数    ::new(t) Test; &#x2F;&#x2F;val初始化为默认值0      t的地址为：0x0000020296ab2640    ::new(t) Test(); &#x2F;&#x2F;val初始化为默认值0    t的地址为：0x0000020296ab2640    &#x2F;&#x2F;传参调用对应构造函数，使用()和&#123;&#125;都可以     ::new(t) Test(10, 11);  &#x2F;&#x2F;val初始化为10  t的地址为：0x0000020296ab2640    ::new(t) Test&#123;99, 11&#125;;  &#x2F;&#x2F;val初始化为99  t的地址为：0x0000020296ab2640    &#x2F;&#x2F;因为不是使用new创建的，所以不能使用delete释放，所以必须手动调用析构函数以释放资源    t-&gt;~Test();    free(t);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="delete和operator-delete"><a href="#delete和operator-delete" class="headerlink" title="delete和operator delete"></a>delete和operator delete</h3><p>​首先，<code>delete</code>和<code>new</code>一样是一个运算符，也是一个关键字，我们无法对其进行修改，<code>delete</code>的行为总是固定的两件事：**1.**对指针所指向的对象或者数组内的对象调用对应的析构函数销毁对象。**2.**调用名为<code>operator delete</code>（或者<code>operator delete[ ]</code>）的全局标准库函数释放内存空间。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int* a &#x3D; new int(10);int* b &#x3D; new int[5];delete a;delete[] b;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​和<code>operator new</code>一样，我们也可以自定义我们的<code>operator delete</code>，这样编译器会优先调用我们实现的版本，同样我们也可以使用<code>::delete</code>显示调用<strong>全局作用域内</strong>的<code>operator delete</code>，就不会调用类内的重载版本。并且<code>operator delete</code>的返回值是<code>void</code>，且<strong>不允许抛出异常</strong>，所以必须使用<code>noexcept</code>声明不会出现异常。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;基本写法，返回值必须为void，第一个参数为void*void operator delete(void* ptr) noexcept&#123;    &#x2F;&#x2F;释放内存操作&#125;void operator delete[](void* ptr) noexcept&#123;    &#x2F;&#x2F;释放内存操作&#125;&#x2F;&#x2F;endint main()&#123;    int* a &#x3D; new int(10);    int* arr &#x3D; new int[10];            delete a;    delete[] arr;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​下面是标准库中（不包括<code>placement new</code>的）的<code>operator new</code>和<code>operator delete</code>，其中最下面四个是<code>nothrow</code>版本，会保证不抛出异常，主要是针对<code>operator new</code>来说的，因为<code>operator delete</code>不允许抛出异常。这几个函数我们都可以自定义，实现自己的版本，但是函数签名要和下面的一致，这样才能符合重载的要求。</p><table><thead><tr><th align="left">函数原型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>void* operator new(std::size_t size)</code></td><td align="left">基本的单个对象内存分配函数。分配失败时抛出 <code>std::bad_alloc</code>异常。</td></tr><tr><td align="left"><code>void* operator new[](std::size_t size)</code></td><td align="left">基本的数组对象内存分配函数。分配失败时抛出 <code>std::bad_alloc</code>异常。</td></tr><tr><td align="left"><code>void operator delete(void* ptr) noexcept</code></td><td align="left">基本的单个对象内存释放函数。</td></tr><tr><td align="left"><code>void operator delete[](void* ptr) noexcept</code></td><td align="left">基本的数组对象内存释放函数。</td></tr><tr><td align="left"><strong>函数原型（这里的operator new不会抛出异常）</strong></td><td align="left"><strong>说明</strong></td></tr><tr><td align="left"><code>void* operator new(std::size_t size, const std::nothrow_t&amp;) noexcept</code></td><td align="left"><strong>不抛出异常</strong>的单个对象分配版本。分配失败时返回空指针。</td></tr><tr><td align="left"><code>void* operator new[](std::size_t size, const std::nothrow_t&amp;) noexcept</code></td><td align="left"><strong>不抛出异常</strong>的数组对象分配版本。分配失败时返回空指针。</td></tr><tr><td align="left"><code>void operator delete(void* ptr, const std::nothrow_t&amp;) noexcept</code></td><td align="left">与 <code>nothrow new</code>对应的释放函数。</td></tr><tr><td align="left"><code>void operator delete[](void* ptr, const std::nothrow_t&amp;) noexcept</code></td><td align="left">与 <code>nothrow new[]</code>对应的释放函数。</td></tr></tbody></table><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;调用nothrow版本的operator new，分配失败时返回空指针int* t1 &#x3D; new(std::nothrow) int[100000000000000];&#x2F;&#x2F;调用普通版本的operator new，分配失败时抛出std::bad_alloc异常int* t2 &#x3D; new int[100000000000000];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="std-new-handler"><a href="#std-new-handler" class="headerlink" title="std::new_handler"></a>std::new_handler</h2><p>​前面介绍过，当<code>operator new</code>无法分配所需内存时，会抛出<code>std::bad_alloc</code>异常，这个说法并不完全正确。实际上，在抛出异常之前，会先调用一个由客户指定的处理函数：<code>new_hanlder</code>，如果没有指定这个函数才会抛出异常。</p><p>​<code>new_handler</code>类型较为简单，就是一个返回值为<code>void</code>，函数参数为空的函数指针。</p><p>​我们可以使用<code>std::set_new_handler</code>传递一个函数指针来设置我们的全局错误处理函数，并且会返回之前的全局错误处理函数的函数指针。也可以使用<code>std::get_new_handler</code>获取当前的全局错误处理函数。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">using new_handler &#x3D; void(*)();new_handler set_new_handler(new_handler) noexcept;new_handler get_new_handler() noexcept<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​如果我们设置了全局错误处理函数，分配失败时就会一直调用错误处理函数并再次尝试分配内存，直到它能找到足够的内存或者错误处理内函数内抛出异常或终止程序。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void MyNewHandler()&#123;std::cout &lt;&lt; &quot;MyNewHandler&quot; &lt;&lt; std::endl;&#125;int main()&#123;    &#x2F;&#x2F;设置自定义的全局错误处理函数    std::set_new_handler(&amp;MyNewHandler);    &#x2F;&#x2F;分配失败时会调用我们的错误处理函数    int* a &#x3D; new int[100000000000000];        &#x2F;&#x2F;将全局错误处理函数设置为空    std::set_new_handler(0);    &#x2F;&#x2F;分配失败时抛出异常    int* b &#x3D; new int[100000000000000];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="new-delete和malloc-free的区别"><a href="#new-delete和malloc-free的区别" class="headerlink" title="new,delete和malloc,free的区别"></a>new,delete和malloc,free的区别</h2><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="size-t"><a href="#size-t" class="headerlink" title="size_t"></a>size_t</h2><p>​<code>size_t</code>是C++标准中定义的<strong>与平台相关的无符号整数类型</strong>，通常<strong>用于表示内存大小、数组索引</strong>等。其<strong>大小与平台相关</strong>，在64位平台上为64位(8字节)，而在32位平台上位32字节(4字节)。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;在32位平台上byteNum为4，是4字节大小&#x2F;&#x2F;在64位平台上byteNum为8，是8字节大小int byteNum &#x3D; sizeof(size_t);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用场景：</p><ul><li>表示<strong>内存大小、数组索引、字符串长度</strong>等与“数量”相关的场景。</li><li>C++标准库中广泛使用（如 <code>std::vector::size()</code> 返回 <code>size_t</code>）。</li><li>示例：遍历数组时的循环变量、动态内存分配的字节数（<code>malloc(size_t)</code>）。</li></ul><h2 id="uint32-t"><a href="#uint32-t" class="headerlink" title="uint32_t"></a>uint32_t</h2><p>​<code>uint32_t</code>是C++11标准中定义的<strong>固定宽度无符号整数类型</strong>，明确表示<strong>32位无符号整数</strong>。其<strong>大小与平台无关</strong>，不论在32位平台还是64位平台，<code>uint32_t</code>始终占用4个字节。</p><p>使用场景：</p><ul><li>需要<strong>精确控制数据宽度</strong>的场景（如网络协议、文件格式、嵌入式开发）。</li><li>要求<strong>跨平台一致性</strong>的数值计算（避免因平台差异导致数据溢出）。</li><li>示例：存储IP地址（32位）、编码格式中的字段长度（如HTTP头部字段）。</li></ul><h2 id="int32-t"><a href="#int32-t" class="headerlink" title="int32_t"></a>int32_t</h2><p>​<code>int32_t</code>是C99标准引入的<strong>固定宽度整数类型</strong>，明确表示<strong>32位有符号整数</strong>，其<strong>大小与平台无关</strong>，不论在32位平台还是64位平台，<code>int32_t</code>始终占用4个字节。只是相比于<code>uint32_t</code>来说，<code>int32_t</code>是有符号整数，可以表示正负。</p><h1 id="左值、右值和移动语义"><a href="#左值、右值和移动语义" class="headerlink" title="左值、右值和移动语义"></a>左值、右值和移动语义</h1><p>​在大部分情况下，我们可以<strong>简单理解</strong>为赋值操作中，<code>=</code>左侧的为左值，<code>=</code>右侧的为右值。例如<code>int i = 10;</code>中左侧的<code>i</code>就是左值，右侧的<code>10</code>就是右值，下面就详细说明一下二者的区别。</p><h2 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h2><h3 id="左值"><a href="#左值" class="headerlink" title="左值"></a>左值</h3><p>​<strong>左值（lvalue）<strong>指表达式结束后</strong>仍然持久存在</strong>的对象（有明确的内存地址）,可以简单理解为左值是一块内存空间的标识，可以对其使用<code>&amp;</code>取地址，而不是一个用完即销毁的临时变量。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; x 是左值int x &#x3D; 42;&#x2F;&#x2F; 返回左值引用的函数调用是左值int&amp; GetRef() &#123;return m_Val;&#125;GetRef() &#x3D; 10;   &#x2F;&#x2F; arr[0] 是左值int arr[3] &#x3D; &#123;1, 2, 3&#125;;arr[0] &#x3D; 99;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="右值"><a href="#右值" class="headerlink" title="右值"></a>右值</h3><p>​<strong>右值（rvalue）<strong>指表达式结束后</strong>即将被销毁</strong>的临时值，不能用<code>&amp;</code>进行取地址操作，通常代表<strong>值（value）本身</strong>，就是一个数字或一个字面值或一个常量。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 42 是右值（rvalue）int x &#x3D; 42;&#x2F;&#x2F;返回右值的函数调用仍是右值，因为返回的是一个临时变量，用完就被销毁了int GetVal() &#123;return m_Val;&#125;int x &#x3D; GetVal(); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="左值和右值的区别"><a href="#左值和右值的区别" class="headerlink" title="左值和右值的区别"></a>左值和右值的区别</h3><p>​在赋值操作中，因为右值仅表示一个值，所以只能出现在<code>=</code>右边。但是左值本身也存储了一个数值，除了可以出现在<code>=</code>左边接收一个值外，也可以出现在<code>=</code>右边（相当于把x存储的数值拿出来拷贝再赋值给别人，但x本身还是一个左值）。简单来说就是<strong>右值只能当作右值用</strong>，而<strong>左值也可以被当作右值使用</strong>。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;x有内存空间，可以取地址，可以长期存在，是一个左值int x &#x3D; 1;&#x2F;&#x2F;y也是左值，虽然x出现在&#x3D;右侧，但x仍是左值int y &#x3D; x;&#x2F;&#x2F;z显然是左值，但是x + y会创建一个临时变量存在结果，所以表达式x + y是右值int z &#x3D; x + y;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​下面看一下左值引用和右值引用用作函数参数的形式</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;int m_Val &#x3D; 10;&#x2F;&#x2F;因为参数是引用形式，右值只是一个临时变量，没有持久的存储空间，该函数只能接收左值引用void SetValue(int&amp; val)&#123;    std::cout &lt;&lt; &quot;Non const&quot; &lt;&lt; std::endl;    m_Val &#x3D; val;&#125;&#x2F;&#x2F;加入const修饰后，函数可以接收左值和右值void SetValue(const int&amp; val)&#123;    std::cout &lt;&lt; &quot;Const&quot; &lt;&lt; std::endl;    m_Val &#x3D; val;&#125;int main()&#123;    int i &#x3D; 10;    SetValue(i);&#x2F;&#x2F;传入左值，会自动匹配第一个函数    SetValue(10);&#x2F;&#x2F;传入的是右值，会自动匹配第二个函数    SetValue(i + 10);&#x2F;&#x2F;传入的是右值，会自动匹配第二个函数    int j &#x3D; 20;SetValue(i + j);&#x2F;&#x2F;传入的是右值，会自动匹配第二个函数&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​知道了这些后，再回顾一下函数参数为<code>std::string</code>的形式，函数接收字符串引用，外面调用时直接传入<code>str1 + str2</code>组成的字符串，这是比较场景的场景，但是这样会报错。因为函数接收的是左值引用的形式，但是<code>str1 + str2</code>是一个右值，所以会报错。这也是为什么函数参数为字符串时都会加入<code>const</code>修饰符的原因。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;左值引用只能接收左值，下面的调用会报错void PrintString(std::string&amp; str)&#123;    std::cout &lt;&lt; str &lt;&lt; std::endl;&#125;&#x2F;&#x2F;const修饰后可以接收右值,下面可以正常调用void PrintString(const std::string&amp; str)&#123;    std::cout &lt;&lt; str &lt;&lt; std::endl;&#125;int main()&#123;    &#x2F;&#x2F; &quot;hmy&quot;是字符串字面量，是一个左值，但是const char*类型    &#x2F;&#x2F; 因为函数形参为std::string类型，传递时会将const char*转为std::string的临时变量，这个临时变量是右值，所以无法编译通关    PrintString(&quot;hmy&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​c++中对于一个<code>&quot;hmy&quot;</code>形式的字符串字面量来说，也是一个左值，因为该字符串会被存储在<strong>静态存储区</strong>，生命周期会伴随整个应用程序，我们可以使用<code>&amp;</code>直接对字符串<code>&quot;hmy&quot;</code><strong>取地址</strong>，所以这样的<strong>字符串字面量是一个左值</strong>。</p><p>​但是为什么这样的字符串是一个左值，却无法正确被接收左值引用的函数所使用呢？</p><p>​因为字符串字面量<code>&quot;hmy&quot;</code>是<code>const char*</code>类型的左值，传参时会隐式转换，创建一个<code>std::string</code>类型的<strong>临时变量</strong>，这个<strong>临时变量是右值，所以无法传参</strong>。但是函数参数加入const修饰后，可以接收右值参数，此时才可以正常传参。</p><h3 id="i和i"><a href="#i和i" class="headerlink" title="++i和i++"></a>++i和i++</h3><p>​这两个在日常使用中很常见，但是就左值右值来说却不一样。首先说一下结论，<code>++i</code>是一个<strong>左值</strong>，<code>i++</code>是一个<strong>右值</strong>。下面来分析一下具体的过程。</p><p>​<code>++i</code>操作会先将<code>i</code>加一后返回<code>i</code>，因此执行<code>++i</code>返回的就是加一后的<code>i</code>本身。所以<code>++i</code>是一个<strong>左值</strong>。</p><p>​<code>i++</code>操作会先将<code>i</code>的值复制一份存到<strong>栈里的临时变量</strong>中，然后再将i加一，最后<strong>返回的是栈中的临时变量</strong>。所以<code>i++</code>是一个<strong>右值</strong>。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int i &#x3D; 0; int* p1 &#x3D; &amp;(++i); &#x2F;&#x2F;因为++i返回的是自增后的i本身，是一个右值，可以取地址&#x2F;&#x2F;因为++i执行后返回的是i本身，所以p1和&amp;i的地址是一样的std::cout &lt;&lt; &quot;i:  &quot; &lt;&lt; &amp;i &lt;&lt; std::endl;std::cout &lt;&lt; &quot;++i:&quot; &lt;&lt; p1 &lt;&lt; std::endl;&#x2F;&#x2F;int* p2 &#x3D; &amp;(i++); 因为i++返回的是右值，所以不能取地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​最后从汇编代码看一下底层原理：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int i &#x3D; 0; &#x2F;&#x2F;使用const int&amp;接收返回的值，更准确的看出返回的到的是什么const int&amp; j &#x3D; ++i;&#x2F;&#x2F;首先，将i中的值加载到寄存器中执行递增(加一)操作00007FF69CDE250D  mov         eax,dword ptr [i]  00007FF69CDE2513  inc         eax  &#x2F;&#x2F;然后，将寄存器中递增后的值放回i中00007FF69CDE2515  mov         dword ptr [i],eax  &#x2F;&#x2F;最后，获取变量i的内存地址，绑定到引用j00007FF69CDE251B  lea         rax,[i]  00007FF69CDE2522  mov         qword ptr [j],rax      const int&amp; k &#x3D; i++;&#x2F;&#x2F;首先，将i中的值(旧值)加载到寄存器中00007FF69CDE2529  mov         eax,dword ptr [i]  &#x2F;&#x2F;再将寄存器中的值(旧值)保存到栈上的临时变量中00007FF69CDE252F  mov         dword ptr [rbp+274h],eax&#x2F;&#x2F;然后再对i中的值执行递增(加一)操作00007FF69CDE2535  mov         eax,dword ptr [i]  00007FF69CDE253B  inc         eax  &#x2F;&#x2F;将递增后的新值保存到i中00007FF69CDE253D  mov         dword ptr [i],eax  &#x2F;&#x2F;从临时变量中获取旧值，最后将临时变量的地址绑定到引用k00007FF69CDE2543  mov         eax,dword ptr [rbp+274h]  00007FF69CDE2549  mov         dword ptr [rbp+164h],eax  00007FF69CDE254F  lea         rax,[rbp+164h]  00007FF69CDE2556  mov         qword ptr [k],rax  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="左值引用和右值引用"><a href="#左值引用和右值引用" class="headerlink" title="左值引用和右值引用"></a>左值引用和右值引用</h2><h3 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h3><p>​左值引用就是平时使用的那种引用，形式为<code>T&amp;</code>（如<code>int&amp;</code>，<code>std::string&amp;</code>等），只能绑定到 <strong>左值</strong>（有持久内存地址的对象）。</p><p>​其实每个变量可以看做是地址的别名，高级语言进行了封装，对该变量进行操作就等同于对该内存操作。而左值引用就相当于又给该地址起了另一个别名，对这两个别名操作都等同于对一块内存操作，所以一改俱改。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;右侧是对应的汇编代码int a &#x3D; 10; &#x2F;&#x2F; dword ptr [a],0Aha &#x3D; 20;     &#x2F;&#x2F; dword ptr [a],14hint a &#x3D; 10;a &#x3D; 20;int&amp; b &#x3D; a;int&amp; c &#x3D; a;&#x2F;&#x2F;最终输出的地址都是一样的std::cout &lt;&lt; &amp;a &lt;&lt; std::endl;std::cout &lt;&lt; &amp;b &lt;&lt; std::endl;std::cout &lt;&lt; &amp;c &lt;&lt; std::endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​前面说过，普通的左值引用<code>T&amp;</code>不能绑定右值只能绑定左值，但是常左值引用<code>const T&amp;</code>就能够绑定到右值。前面说过，右值一般都是没有内存地址的字面量或者用完即毁的临时变量。</p><p>​底层在实现时会先<strong>在栈上创建一个临时变量</strong>，再把该临时变量的地址给d，而且<strong>临时变量的生命周期和对应的引用一致</strong>，当该引用销毁时才会销毁该临时变量。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;int&amp; d &#x3D; 10; &#x2F;&#x2F;普通的左值引用不能绑定右值const int&amp; d &#x3D; 10; &#x2F;&#x2F;该行代码对应的汇编代码dword ptr [rbp+0E4h],0Ah  &#x2F;&#x2F;从栈上创建一个临时变量，值为10rax,[rbp+0E4h]  qword ptr [d],rax &#x2F;&#x2F;将栈上临时变量的地址给d，并且该临时变量的生命周期变为和引用d一样<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​那这样做的理由在哪里呢？</p><ul><li>C++早期（C++98）没有右值引用（<code>T&amp;&amp;</code>），但需要一种方式让函数接受临时对象（右值）作为参数，<code>const T&amp;</code>的引入解决了这一问题。</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void print(const std::string&amp; str); &#x2F;&#x2F; 可接受左值或右值std::string s &#x3D; &quot;hello&quot;;print(s) &#x2F;&#x2F;传入左值也可以print(&quot;hello&quot;); &#x2F;&#x2F;传入右值也可以<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>同时使用<code>const T&amp;</code>也能保证安全性。右值通常是临时对象，允许引用修改它们无意义且危险，使用const修饰后，可以避免该引用修改临时变量的值。</li></ul><h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>​我们也可以使用<code>&amp;&amp;</code>表面函数参数为一个<strong>右值引用</strong>，表面该函数只接受右值作为函数参数。现在分别有了只接受左值和只接受右值的函数，我们可以利用这两中函数更准确的区分左值和右值。能被第一个函数使用的就是左值，能被第二个函数使用的就是右值。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;左值引用只接收非左值void PrintString(std::string&amp; str)&#123;    std::cout &lt;&lt; str &lt;&lt; std::endl;&#125;&#x2F;&#x2F;右值引用只接收右值void PrintString(std::string&amp;&amp; str)&#123;    std::cout &lt;&lt; str &lt;&lt; std::endl;&#125;int main()&#123;    std::string str1 &#x3D; &quot;hmy&quot;;    std::string str2 &#x3D; &quot;hello&quot;;        PrintString(str1);&#x2F;&#x2F;传入左值，调用第一个函数    PrintString(str1 + str2);&#x2F;&#x2F;传入右值，调用第二个函数&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="移动语义-std-move"><a href="#移动语义-std-move" class="headerlink" title="移动语义(std::move)"></a>移动语义(std::move)</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>​对于下面的例子来说，创建了一个<code>Entity</code>对象<code>e</code>，并传入了一个<code>String</code>对象，首先会调用<code>String</code>类的构造函数创建一个临时变量，然后该临时变量会赋值给<code>Entity</code>构造函数的形参，其形参也是一个<code>String</code>类，所以会触发<code>String</code>的拷贝构造函数。</p><p>​可以看到这一个简单的过程调用了<code>String</code>的普通构造函数和拷贝构造函数，使用new在堆区创建了两次内存。但是我们明明都在栈区创建了一个对象了，传到函数里却还要再进行一次深拷贝，这种开销是没有必要的。</p><p>​所以c++11引入了移动语义，可以解决这一问题。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class String&#123;public:&#x2F;&#x2F;默认构造函数String() &#x3D; default;&#x2F;&#x2F;一般的构造函数String(const char* data)&#123;printf(&quot;Create\n&quot;);m_Size &#x3D; strlen(data);m_Data &#x3D; new char[m_Size];memcpy(m_Data, data, m_Size);&#125;&#x2F;&#x2F;拷贝构造函数(接收左值引用和右值)String(const String&amp; other)&#123;printf(&quot;Copy\n&quot;);m_Size &#x3D; other.m_Size;m_Data &#x3D; new char[m_Size];memcpy(m_Data, other.m_Data, m_Size);&#125;&#x2F;&#x2F;析构函数~String()&#123;printf(&quot;Destory\n&quot;);delete[] m_Data;&#125;void ShowData()&#123;puts(m_Data);&#125;public:uint32_t m_Size;char* m_Data;&#125;;class Entity&#123;public:Entity(const String&amp; name):m_Name(name)&#123;&#125;    void Print()&#123;puts(m_Name.m_Data);&#125;private:String m_Name;&#125;;int main()&#123;    &#x2F;&#x2F;String(&quot;hmy&quot;)创建一个临时对象，临时对象赋值给函数形参    &#x2F;&#x2F;这一个过程调用了String的普通构造函数和拷贝构造函数，使用new在堆区创建了两次内存Entity e(String(&quot;hmy&quot;));e.Print();return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h3><p>​移动语义是 C++11 引入的一项重要特性，它允许资源的<strong>高效转移而非复制</strong>，显著提高了程序的性能。C++11之前，对象的资源转移只能通过复制（拷贝）完成，创建一个临时变量传入拷贝构造函数，对象再进行资源拷贝。</p><p>​有了移动语义之后，允许我们直接对<strong>资源进行窃取</strong>而非复制。简单来说就是我们不必再通过先创建临时变量，再从临时变量那里复制一份数据，而是<strong>直接把临时变量里面的数据拿过来占为己有</strong>。</p><p>​为此我们需要<code>Entity</code>的构造函数支持右值引用，允许接收一个临时变量，这样再给<code>m_Name</code>赋值时可以调用<code>String</code>的<strong>移动构造函数</strong>而<strong>不是拷贝构造函数</strong>。</p><p>​修改后的代码执行后，执行了一次普通构造函数和一次移动构造函数，而且数据只在堆区创建了一次。所以对于那些需要被转移走数据的变量，我们通常会将他强转为<code>(Type&amp;&amp;)</code>，明确表示其为右值引用类型，数据是可以被转移的。</p><p>​在一个移动构造函数中，如果当一个对象的资源移动到另一个对象时发生了异常，也就是说对象的一部分发生了转移而另一部分没有，这就会造成源对象和目标对象都不完整的情况发生，这种情况的后果是无法预测的。所以在<strong>编写移动语义的函数时建议确保函数不会抛出异常</strong>，与此同时，如果无法保证移动构造函数不会抛出异常，可以使用<code>noexcept</code>说明符限制该函数。这样当函数抛出异常的时候，程序不会再继续执行而是调用<code>std::terminate</code>中止执行以免造成其他不良影响。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class String&#123;public:&#x2F;&#x2F;默认构造函数String() &#x3D; default;&#x2F;&#x2F;一般的构造函数String(const char* data)&#123;printf(&quot;Create\n&quot;);m_Size &#x3D; strlen(data);m_Data &#x3D; new char[m_Size];memcpy(m_Data, data, m_Size);&#125;&#x2F;&#x2F;拷贝构造函数(接收左值引用和右值)String(const String&amp; other)&#123;printf(&quot;Copy\n&quot;);m_Size &#x3D; other.m_Size;m_Data &#x3D; new char[m_Size];memcpy(m_Data, other.m_Data, m_Size);&#125;        &#x2F;&#x2F;移动构造函数(接收右值引用)    &#x2F;&#x2F;使用移动语义的函数要加入noexcept修饰，告诉编译器这是不会出现错误的，否则编译器会认为移动数据可能有危险，会出现警告String(const String&amp; other) noexcept&#123;printf(&quot;Copy\n&quot;);        &#x2F;&#x2F;将临时变量的数据占为己有m_Size &#x3D; other.m_Size;m_Data &#x3D; other.m_Data;        &#x2F;&#x2F;临时变量的数据已经被占有，自己没有任何数据了，要把他的指针置为空，否则销毁时会把原先的数据释放掉        other.m_Size &#x3D; 0;        other.m_Data &#x3D; nullptr;&#125;&#x2F;&#x2F;析构函数~String()&#123;printf(&quot;Destory\n&quot;);delete[] m_Data;&#125;void ShowData()&#123;puts(m_Data);&#125;public:uint32_t m_Size;char* m_Data;&#125;;class Entity&#123;public:Entity(const String&amp; name):m_Name(name)&#123;                &#125;    &#x2F;&#x2F;函数参数为右值引用，表面允许接收一个临时变量，讲临时变量传递给m_Name时调用他的移动构造函数而非拷贝构造函数    Entity(String&amp;&amp; name):m_Name((String&amp;&amp;)name)&#123;                &#125;    void Print()&#123;puts(m_Name.m_Data);&#125;private:String m_Name;&#125;;int main()&#123;    &#x2F;&#x2F;String(&quot;hmy&quot;)创建一个临时对象，临时对象赋值给函数形参    &#x2F;&#x2F;由于Entity增加了支持右值引用的构造函数，会优先调用该右值引用构造函数，再创建m_Name时会调用String的移动构造函数而非拷贝构造函数Entity e1(String(&quot;hmy&quot;));e1.Print();return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​参考下面一个例子，如果我们希望将str1的数据移动到str2，如果直接将str1赋值给str2，会触发拷贝构造函数。必须显式的将str2转换为(String&amp;&amp;)类型才可以。但是这样手动转换是很不方便的，而且有时数据类型我们不一定能明确知道，可以使用<code>std::move()</code>，其作用就是<strong>将传进来的参数转为右值引用</strong>，并且会自动推到类型。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main()&#123;    String str1 &#x3D; &quot;hmy&quot;;    &#x2F;&#x2F;触发拷贝构造函数    String str2 &#x3D; str1;    &#x2F;&#x2F;触发移动构造函数    String str2 &#x3D; (String&amp;&amp;)str1;&#x2F;&#x2F;触发移动构造函数(和第二种写法等价)    String str2 &#x3D; std::move(str1);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="移动构造函数和赋值运算符"><a href="#移动构造函数和赋值运算符" class="headerlink" title="移动构造函数和赋值运算符"></a>移动构造函数和赋值运算符</h3><p>​可以看到，情况1和情况2都是调用的构造函数，但是情况3调用的是赋值运算符。那是因为情况三在赋值操作的时候str2已经调用默认构造函数创建完成了，一个已经创建完成的对象，所以再赋值时会调用赋值运算符。</p><p>​为了能执行，我们必须给String类添加支持右值移动的赋值运算符重载，但是赋值运算符会出现<code>str2 = std::move(str2)</code>操作，此时执行的话会导致自己的数据被删除。所以必须要判断二者是否为一个对象，确认二者不是一个对象才可以删除数据，否则会出大问题。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;给String类添加支持右值移动的赋值运算符重载String&amp; operator&#x3D;(String&amp;&amp; other)&#123;    &#x2F;&#x2F;因为赋值运算符有可能出现str2 &#x3D; std::move(str2)的情况，如果是一个对象要直接返回，否则会自己的删除数据    if (this &#x3D;&#x3D; &amp;other)return;    printf(&quot;Moved\n&quot;);        &#x2F;&#x2F;先删除自己的数据    delete[]m_Data;        &#x2F;&#x2F;将其他对象的数据占为己有    m_Size &#x3D; other.m_Size;    m_Data &#x3D; other.m_Data;        &#x2F;&#x2F;其他对象的数据已经被占有，自己没有任何数据了    other.m_Size &#x3D; 0;    other.m_Data &#x3D; nullptr;&#125;int main()&#123;    String str1 &#x3D; &quot;hmy&quot;;    &#x2F;&#x2F;情况1.触发拷贝构造函数    String str2 &#x3D; str1;    &#x2F;&#x2F;情况2.触发移动构造函数    String str2 &#x3D; std::move(str1);        &#x2F;&#x2F;情况3.触发赋值运算符    String str2;    str2 &#x3D; std::move(str1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​所以为了能支持移动语义，类里面必须要由<strong>移动构造函数</strong>和<strong>移动赋值运算符重载</strong>。所以<code>std::move</code>所干的事情并<strong>不是实现资源移动</strong>，而是将某个<strong>左值转变为右值</strong>(临时变量)，从而<strong>触发移动构造函数</strong>或<strong>移动赋值运算符重载</strong>，<strong>避免深拷贝</strong>。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; std::move底层实现如下(简化版)&#x2F;&#x2F; _Ty&amp;&amp;是通用引用,可以绑定到左值或右值&#x2F;&#x2F; remove_reference_t能移除_Ty身上所有的引用修饰符(例如int&amp;,int&amp;&amp;都能转为int)&#x2F;&#x2F; 使用static_cast和remove_reference_t&lt;_Ty&gt;&amp;&amp;，将类型强制转换为右值引用的形式，最后一定为type&amp;&amp;的形式template &lt;class _Ty&gt;constexpr remove_reference_t&lt;_Ty&gt;&amp;&amp; move(_Ty&amp;&amp; _Arg) noexcept &#123;    return static_cast&lt;remove_reference_t&lt;_Ty&gt;&amp;&amp;&gt;(_Arg);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="万能引用"><a href="#万能引用" class="headerlink" title="万能引用"></a>万能引用</h2><p>​在有了右值引用后，我们在编写函数时也会编写一个函数版本能够接收右值引用，但是这样会导致函数需要写多个版本，太过冗余。此时就可以使用模板+万能引用解决这个问题。</p><p>​模板函数中参数为<code>T&amp;&amp;</code>以后：</p><ul><li><p>如果传入的是<strong>左值</strong>，T会被推到为<code>type&amp;</code>，此时函数参数为<code>type&amp; &amp;&amp;</code>，<strong>引用折叠后</strong>为<code>type&amp;</code>，最终为左值引用。</p></li><li><p>如果为<strong>右值</strong>，T会被推导为<code>type</code>，此时函数参数为<code>type&amp;&amp;</code>，最终为右值引用。</p></li></ul><p>​如果不希望传入左值引用被函数内部修改，可以在外部将该右值变量定义为<code>const</code>，这样T会推到为<code>const type&amp;</code>，函数内部就无法修改值了。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;针对每个参数都要有接收左值引用和右值引用的情况，显然过于麻烦void Print(int&amp;&amp; a, float&amp; b)&#123;&#125;void Print(int&amp;&amp; a, float&amp;&amp; b)&#123;&#125;void Print(int&amp; a, float&amp;&amp; b)&#123;&#125;void Print(int&amp; a, float&amp;&amp; b)&#123;&#125;&#x2F;&#x2F;使用模板＋T&amp;&amp;万能引用，能够自动推导T是左值还是右值template&lt;typename T&gt;void Print(T &amp;&amp;val)&#123;std::cout &lt;&lt; val &lt;&lt; std::endl;&#125;int main()&#123;    int a &#x3D; 10;Print(a); &#x2F;&#x2F;推导T为int&amp;，int&amp; &amp;&amp;引用折叠后为int&amp;Print(1); &#x2F;&#x2F;推导T为int，int&amp;&amp;就是int&amp;&amp;        const int b &#x3D; 10;    Print(b); &#x2F;&#x2F;推导T为const int&amp;，const int&amp; &amp;&amp;引用折叠后为const int&amp;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​万能引用的形式必须为<code>T&amp;&amp;</code>或者<code>auto&amp;&amp;</code>，也就是说必须在初始化的时候可以直接推导出来，写作其他形式的都不是万能引用。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;只有T&amp;&amp;写法的才算万能引用，std::vector&lt;T&gt; &amp;&amp;不是万能引用，知识一个右值引用template&lt;typename T&gt;void Print1(std::vector&lt;T&gt; &amp;&amp; v)&#123;&#125;&#x2F;&#x2F;只有严格为 T&amp;&amp; 写法的才算万能引用template&lt;typename T&gt;void Print2(T&amp;&amp; v)&#123;&#125;int main()&#123;    std::vector&lt;int&gt;v;    &#x2F;&#x2F;Print1不是万能引用，只能接收右值引用Print1(std::vector&lt;int&gt;&#123;1&#125;);&#x2F;&#x2F;Print1(v); 编译错误，因为Print1不是万能引用，只能接收右值引用    &#x2F;&#x2F;Print2是万能引用，能自己推导Print2(std::vector&lt;int&gt;&#123;1&#125;);Print2(v);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h2><p>​引用折叠是 C++11 引入的一个规则，用于处理模板和类型推导中引用类型的组合情况。它在<strong>完美转发</strong>(perfect forwarding)和<strong>模板元编程</strong>中非常重要。</p><table><thead><tr><th align="left">第一种引用</th><th align="left">第二种引用</th><th align="left">折叠结果</th></tr></thead><tbody><tr><td align="left"><code>T&amp;</code></td><td align="left"><code>&amp;</code></td><td align="left"><code>T&amp;</code></td></tr><tr><td align="left"><code>T&amp;</code></td><td align="left"><code>&amp;&amp;</code></td><td align="left"><code>T&amp;</code></td></tr><tr><td align="left"><code>T&amp;&amp;</code></td><td align="left"><code>&amp;</code></td><td align="left"><code>T&amp;</code></td></tr><tr><td align="left"><code>T&amp;&amp;</code></td><td align="left"><code>&amp;&amp;</code></td><td align="left"><code>T&amp;&amp;</code></td></tr></tbody></table><p>​简单来说就是<strong>有左为左</strong>，<strong>全右才右</strong>。即只要出现左值引用和其他引用混合，一律折叠为左值引用；只有两个都是右值引用时才会折叠为右值引用。</p><h2 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h2><p>​完美转发是C++11引入的一项重要特性，它允许函数模板将其参数<strong>原封不动</strong>地转发给其他函数，保持参数的<strong>值类别</strong>（左值&#x2F;右值）和<strong>类型</strong>不变。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Hello(int&amp; a)&#123;std::cout &lt;&lt; &quot;右值引用函数&quot; &lt;&lt; std::endl;&#125;void Hello(int&amp;&amp; a)&#123;std::cout &lt;&lt; &quot;左值引用函数&quot; &lt;&lt; std::endl;&#125;template&lt;typename T&gt;void Say(T&amp;&amp; a)&#123;    &#x2F;&#x2F;传入右值时T&amp;&amp; a--&gt;变为int&amp;&amp; a，而右值引用a本身是一个左值，传递给Hello函数时会当作左值传递&#x2F;&#x2F;Hello(a);&#x2F;&#x2F;1.向下传递参数之前使用万能引用将参数强转为正确类型&#x2F;&#x2F;Hello(static_cast&lt;T&amp;&amp;&gt;(a));&#x2F;&#x2F;2. 使用std::forward&lt;T&gt;(a)向下传递(1,2等价)Hello(std::forward&lt;T&gt;(a));&#125;int main()&#123;int f &#x3D; 10;        &#x2F;&#x2F;T推断为int&amp;，引用折叠后为int&amp; a，a是一个左值引用，调用左值引用的函数Say(f);&#x2F;&#x2F;T推断为int，引用折叠后为int&amp;&amp; a，a是一个右值引用，但是右值引用本身是一个左值(会在栈上创建一个临时变量),所以将a传递给下一个函数时会被当作左值传递，所以调用了左值函数Say(10);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​在向下传递参数时，可以先使用<code>static_cast&lt;T&amp;&amp;&gt;</code>将参数强转为正确的类型再向下传递，也可以直接使用<code>std::forward&lt; T &gt;</code>实现完美转发，这两种操作其实是等价的，都能将参数按照正确类型传递。</p><p>​<code>std::forward</code>的底层原理如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;这个重载版本接收的是左值引用类型的参数（T为引用时说明是一个左值，调用该函数）&#x2F;&#x2F;remove_reference_t&lt;T&gt;会去除T的所有引用修饰，变为一个原始类型(例如int、float或自定义类型的原始类型)，所以remove_reference_t&lt;T&gt;&amp; 会得到一个原始类型的左值引用(int&amp;，float&amp;等)template &lt;class T&gt;constexpr T&amp;&amp; forward(remove_reference_t&lt;T&gt;&amp; _Arg) noexcept &#123;    return static_cast&lt;T&amp;&amp;&gt;(_Arg);&#x2F;&#x2F;使用static_cast&lt;T&amp;&amp;&gt;强转为正确的类型&#125;&#x2F;&#x2F;这个重载版本接收的是右值引用类型的参数（T为非引用时说明是一个右值，调用该函数）&#x2F;&#x2F;同理remove_reference_t&lt;T&gt;&amp;&amp; 会得到原始类型的右值引用(int&amp;&amp;, float&amp;&amp;等)template &lt;class T&gt;constexpr T&amp;&amp; forward(remove_reference_t&lt;T&gt;&amp;&amp; _Arg) noexcept &#123;    static_assert(!is_lvalue_reference_v&lt;T&gt;, &quot;bad forward call&quot;);&#x2F;&#x2F;安全性保证，这个函数只用来处理右值引用类型    return static_cast&lt;T&amp;&amp;&gt;(_Arg);&#x2F;&#x2F;使用static_cast&lt;T&amp;&amp;&gt;强转为正确的类型&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="函数指针、Lambda表达式和std-functional、std-bind"><a href="#函数指针、Lambda表达式和std-functional、std-bind" class="headerlink" title="函数指针、Lambda表达式和std::functional、std::bind"></a>函数指针、Lambda表达式和std::functional、std::bind</h1><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>​<strong>函数指针</strong>是<strong>指向函数的指针</strong>，它可以保存某个函数的地址，使得程序可以通过函数指针调用对应的函数。尤其在回调函数，事件处理函数等场景中会经常用到。或者将函数作为返回值，或者在不同的上下文中动态地调用不同的函数。</p><p>​计算机中，所有高级语言的代码最终都会编译转换为CPU可以执行的机器语言的指令。函数由一系列的指令组成，这些指令告诉CPU该如何执行该函数的任务。<strong>这些指令序列必须存储在内存中</strong>，以便CPU可以按照程序的流程来执行它们。<strong>函数的内存地址</strong>就是<strong>这些指令序列在存中开始的地方</strong>。</p><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>​声明一个函数指针：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">返回类型(* 函数指针名)(参数类型)&#x2F;&#x2F;返回int类型，指针名叫addPtr，接受两个为int类型的参数int(* addPtr)(int, int);int f1(int a, int b)&#123;return a + b;&#125;void f2(int a, int b)&#123;&#125;int main()&#123;    addPtr &#x3D; &f1;&#x2F;&#x2F;对函数名取地址拿到函数的地址    &#x2F;&#x2F;拿到函数地址以后可以直接用()调用函数std::cout &lt;&lt; addPtr(1, 2) &lt;&lt; std::endl;addPtr &#x3D; f1;&#x2F;&#x2F;直接用函数名赋值会隐式转换std::cout &lt;&lt; addPtr(2, 2) &lt;&lt; std::endl;&#x2F;&#x2F;addPtr &#x3D; &f2; &#x2F;&#x2F;返回类型和参数列表必须一致&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​函数指针作为函数参数传递：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;函数指针可以作为函数参数传递，在函数体里可以直接调用int sum(int a, int b, int(*fPtr)(int, int))&#123;return fPtr(a, b);&#125;int f1(int a, int b)&#123;return a + b;&#125;int main()&#123;    int(* addPtr)(int, int);    addPtr &#x3D; &f1;    &#x2F;&#x2F;将函数指针当早函数参数传递，函数体内可以直接调用函数指针    std::cout &lt;&lt; sum(1, 6, addPtr) &lt;&lt; std::endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​函数指针作为返回值：根据我们以往编写函数的经验来看，返回函数指针的语法应该为</p><p><code>int(*)(int, int) getFunPtr(int choice)</code>，但是<strong>这样并不能通过编译</strong>。正确的语法为</p><p><code>int(* getFunPtr(int choice))(int, int)</code>，这样的写法非常反直觉，后面可以简化。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int f1(int a, int b)&#123;std::cout&lt;&lt; &quot;f1&quot; &lt;&lt; std::endl;return a + b;&#125;int f3(int a, int b)&#123;std::cout &lt;&lt; &quot;f3&quot; &lt;&lt; std::endl;return a + b;&#125;&#x2F;&#x2F;函数指针作为函数返回值,(*函数声明)，可以看到与一般的函数写法不同int (*getFuncPtr(int choice))(int, int)&#123;if (choice &#x3D;&#x3D; 1)return &f1;else if (choice &#x3D;&#x3D; 3)return &f3;return nullptr;&#125;int main()&#123;    int(* addPtr)(int, int);        addPtr &#x3D; getFuncPtr(1); &#x2F;&#x2F;拿到函数指针addPtr(1, 1); &#x2F;&#x2F;调用函数f1getFuncPtr(3)(2,3); &#x2F;&#x2F;也可以直接调用，最终调用f3&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​函数指针的简化：</p><p>​可以看到，如果我们用<code>int(* addPtr)(int, int);</code>的语法声明一个函数指针，不仅可读性不强，而且作为函数返回值返回时更不方便。而且这样只能声明一个变量名为<code>addPtr</code>的函数指针变量，想声明多个还要写这样的代码。</p><p>​值得高兴的是，我们可以使用<code>typedef</code>或者<code>using</code>关键字简化函数指针的声明。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int f1(int a, int b)&#123;std::cout&lt;&lt; &quot;f1&quot; &lt;&lt; std::endl;return a + b;&#125;void f2(int a, int b)&#123;&#125;int f3(int a, int b)&#123;std::cout &lt;&lt; &quot;f3&quot; &lt;&lt; std::endl;return a + b;&#125;&#x2F;&#x2F;这样就相当于声明了一个函数指针的类型AddFunPtr，可以用这个类型去声明函数指针变量&#x2F;&#x2F;下面两种写法是等价的typedef int(*AddFunPtr)(int, int); &#x2F;&#x2F;使用typedef只能写(*name)using AddFunPtr2 &#x3D; int (*)(int, int); &#x2F;&#x2F;使用using的话只能写(*)，这样写(*name)会编译失败&#x2F;&#x2F;AddFunPtr类型可以作为函数返回值AddFunPtr getFuncPtr2(int choice)&#123;if (choice &#x3D;&#x3D; 1)return &f1;else if (choice &#x3D;&#x3D; 3)return &f3;return nullptr;&#125;&#x2F;&#x2F;AddFunPtr类型可以作为参数类型int sum2(int a, int b, AddFunPtr fPtr)&#123;return fPtr(a, b);&#125;int main()&#123;    &#x2F;&#x2F;使用AddFunPtr类型声明其他函数指针变量    AddFunPtr p1 &#x3D; &f1;sum2(1, 2, p1);AddFunPtr p2 &#x3D; getFuncPtr2(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="仿函数（函数对象）"><a href="#仿函数（函数对象）" class="headerlink" title="仿函数（函数对象）"></a>仿函数（函数对象）</h2><p>​仿函数本质上是通过重载<code>operator()</code>的类实现的函数对象。所以仿函数在作为函数参数或者返回值时传递或者返回的都是这个对象。而且由于我们是通过实现运算符重载，本质上还是一个对象，所以我们也可以在对象内部定义一下成员变量，使用成员变量记录一下状态。而且当该调用的性能接近普通函数调用，并且比直接声明函数指针要方便。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;创建一个结构体struct SF&#123;int x &#x3D; 0;SF(int v):x(v) &#123;&#125;    &#x2F;&#x2F;每次调用会让x加一int operator()(int a, int b)&#123;x++;return a + b;&#125;&#125;;&#x2F;&#x2F;传递的就是该类型的对象void showSF(int x, SF&amp; sf)&#123;std::cout &lt;&lt; sf(x, x) &lt;&lt; std::endl;&#125;&#x2F;&#x2F;返回的也是该类型的对象SF getSF(int a)&#123;return SF(a);&#125;int main()&#123;    SF sf1(0);    &#x2F;&#x2F;每次调用都让导致sf1的成员变量x加一std::cout &lt;&lt; sf1(1, 2) &lt;&lt; std::endl;std::cout &lt;&lt; sf1.x &lt;&lt; std::endl;std::cout &lt;&lt; sf1(2, 2) &lt;&lt; std::endl;std::cout &lt;&lt; sf1.x &lt;&lt; std::endl;std::cout &lt;&lt; sf1(3, 2) &lt;&lt; std::endl;std::cout &lt;&lt; sf1.x &lt;&lt; std::endl;std::cout &lt;&lt; sf1(4, 2) &lt;&lt; std::endl;    std::cout &lt;&lt; sf1.x &lt;&lt; std::endl; &#x2F;&#x2F;最终输出sf1.x为4    showSF(1, sf1);SF sf2 &#x3D; getSF(1);sf2(1, 2);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>​<code>Lambda</code>表达式是<strong>C++11</strong>引入的一种<strong>创建匿名函数对象</strong>的简洁方式，它极大地简化了函数对象的创建和使用。基本语法如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;其中[]里面是捕获列表；()里面是参数列表，如果没有参数可以省略；-&gt;后面的是返回类型，可以省略编译器自动推导；&#123;&#125;里面就是函数体&#x2F;&#x2F;没有参数时可以省略()[capture]-&gt; return_type &#123;     &#x2F;&#x2F; 函数体&#125;;&#x2F;&#x2F;使用后置返回类型指明返回类型[capture](parameters) -&gt; return_type &#123;     &#x2F;&#x2F; 函数体&#125;;&#x2F;&#x2F;不指明返回类型，编译器自动推导[capture](parameters)&#123;     &#x2F;&#x2F; 函数体&#125;;&#x2F;&#x2F;最简单的lambda表达式(返回值省略，参数列表省略)[capture]&#123;    &#x2F;&#x2F;函数体&#125;;int main()&#123;    &#x2F;&#x2F;lambda简单使用    auto lAdd &#x3D; [](int a, int b)&#123;    std::cout &lt;&lt; a + b &lt;&lt; std::endl;        &#x2F;&#x2F;其他执行代码    &#125;;    lAdd(1,2);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="捕获列表"><a href="#捕获列表" class="headerlink" title="捕获列表"></a>捕获列表</h3><p>​捕获列表位于方括号 <code>[]</code> 中，决定了<code>lambda</code>表达式如何访问外部变量。捕获方式可以是值捕获、引用捕获，标准还规定能<strong>捕获的变量</strong>必须是一个<strong>自动存储类型</strong>。简单来说就是<strong>非静态的局部变量</strong>。</p><table><thead><tr><th align="left">捕获方式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>[]</code></td><td align="left">不捕获任何外部变量</td></tr><tr><td align="left"><code>[=]</code></td><td align="left">按值捕获所有外部变量</td></tr><tr><td align="left"><code>[&amp;]</code></td><td align="left">按引用捕获所有外部变量</td></tr><tr><td align="left"><code>[x, &amp;y]</code></td><td align="left">按值捕获x，按<strong>引用捕获y</strong></td></tr><tr><td align="left"><code>[=, &amp;x]</code></td><td align="left">默认按值捕获外部变量，但<strong>x按引用</strong>捕获</td></tr><tr><td align="left"><code>[&amp;, x]</code></td><td align="left">默认按引用捕获外部变量，但x按值捕获</td></tr><tr><td align="left"><code>[this]</code></td><td align="left">捕获当前类的this指针</td></tr></tbody></table><p>​捕获列表中的变量存在于两个作用域——<strong>lambda表达式定义的函数作用域</strong>以及lambda 表达式<strong>函数体的作用域</strong>，简单来说就是和这个lambda表达式定义时的同一个作用域和lambda函数体内部的作用域。</p><p>​根据上面的规则来说，如果我们将一个<strong>lambda表达式定义在全局作用域</strong>，那么lambda表达式的<strong>捕获列表必须为空</strong>。因为根据上面提到的规则，捕获列表的变量必须是一个自动存储类型，但是全局作用域并没有这样的类型。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int globalNum &#x3D; 10;&#x2F;&#x2F;捕获列表必须为空，因为全局作用域下的变量不符合捕获变量的要求auto globalLambad &#x3D; []() &#123;&#125;;int main()&#123;    static int sNum &#x3D; 10;int num &#x3D; 10;auto lam1 &#x3D; [num]() &#123;&#125;;    &#x2F;&#x2F;下面写法否编译失败&#x2F;&#x2F;auto lam2 &#x3D; [sNum]() &#123;&#125;; &#x2F;&#x2F;sNum是静态变量，不符合要求&#x2F;&#x2F;auto lam3 &#x3D; [globalNum]() &#123;&#125;; &#x2F;&#x2F;1.globalNum不是局部变量；2.globalNum位于全局作用域，和lambad定义时不在同一个作用域        &#x2F;&#x2F;但是我们可以像普通函数那样在函数体内部直接使用全局变量或者可见的静态变量    auto lam4 &#x3D; [num]() &#123;int a &#x3D; sNum;int b &#x3D; globalNum;&#125;;    int b &#x3D; 1;    &#x2F;&#x2F;但非静态局部变量不能直接在函数体内部使用，必须通过捕获才可以    &#x2F;&#x2F;auto ff &#x3D; [] &#123;    &#x2F;&#x2F;std::cout &lt;&lt; b &lt;&lt; std::endl;    &#x2F;&#x2F;&#125;;    auto ff1 &#x3D; [b] &#123;    std::cout &lt;&lt; b &lt;&lt; std::endl;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​前面已经说过，捕获列表可以按值捕获和按值捕获，如果捕获多个变量，变量之间使用逗号隔开即可。</p><p>​捕获的变量时默认lambda是一个常量函数（类似于<code>const</code>修饰的成员函数，捕获的变量类似于类的成员变量），所以<strong>按值捕获时****不能在内部修改这些变量的值</strong>，所以编译会失败。</p><p>​但是按<strong>引用捕获</strong>时，捕获变量实际上是一个引用，我们在函数体内改变的并不是引用本身，而是引用的值，所以<strong>编译会通过</strong>。因为捕获的是外部变量的引用，所以<code>lambda</code>函数体内修改值也会影响外部变量的值。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main()&#123;    int x &#x3D; 111, int y &#x3D; 222;        &#x2F;&#x2F;按值捕获，把x和y的值复制一份到lambda内部的变量中    auto f1 &#x3D; [x, y] &#123;        return x + y;        &#125;;    &#x2F;&#x2F;按引用捕获，把x和y的引用给lambda内部的变量中    auto f2 &#x3D; [&amp;x, &amp;y] &#123;        return x + y;        &#125;;        &#x2F;&#x2F;捕获的变量时默认lambda是一个常量函数，类似于const修饰的成员函数，不能在内部修改内部变量的值，所以编译会失败    &#x2F;*    auto f3 &#x3D; [x, y] &#123;        x++;        y++;        &#125;;    *&#x2F;        &#x2F;&#x2F;按引用捕获时，捕获变量实际上是一个引用，我们在函数体内改变的并不是引用本身，而是引用的值，所以编译会通过    auto f4 &#x3D; [&amp;x, &amp;y] &#123;        x++;        y++;        &#125;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​虽然<code>lambda</code>默认为一个常量函数，但是使用<code>mutable</code>说明符可以<strong>移除<code>lambda</code>表达式的常量性</strong>。也就是说<code>lambda</code>使用<code>mutable</code>修饰后，就能在内部修改按值捕获的变量的值。但由于按值捕获的实际上就是复制了一份，所以内部的修改并不会影响外部的值。但是要注意<code>lambda</code>表达式使用说明符修饰以后，参数列表必须写上，也就是<code>()</code>必须加上，哪怕没有参数。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main()&#123;    x &#x3D; 111, y &#x3D; 222;    &#x2F;&#x2F;使用mutable修饰后可以修改捕获的值了，但参数列表的()必须写上，且由于是复制的数据，内部修改无法影响外部    auto f5 &#x3D; [x, y]() mutable &#123;        x++;        y++;        &#125;;    &#x2F;&#x2F;引用捕获时，内部的修改会影响外部的值    auto f5 &#x3D; [&amp;x, &amp;y]() mutable &#123;        x++;        y++;    &#125;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>​不难发现，<code>lambda</code>表达式与<strong>函数对象（仿函数）<strong>非常相似，但事实上<code>lambda</code>的实现原理也正是</strong>通过函数对象来实现</strong>的。</p><p>​首先创建一个简单的按值捕获的<code>lambda</code>表达式为例：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int i &#x3D; 10, j &#x3D; 10;&#x2F;&#x2F;按值捕获auto foo1 &#x3D; [i, j]() &#123;    return i + j;    &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​最后编译器处理后产生的中间代码如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">  int i &#x3D; 10;  int j &#x3D; 10;&#x2F;&#x2F;按值捕获  class __lambda_6_15  &#123;    public:     &#x2F;&#x2F;如果lambda使用utable修饰，const会去掉    inline &#x2F;*constexpr *&#x2F; int operator()() const    &#123;      return i + j;    &#125;        private:     int i;    int j;        public:    __lambda_6_15(int &amp; _i, int &amp; _j)    :i&#123;_i&#125;,j&#123;_j&#125;    &#123;&#125;      &#125;;&#x2F;&#x2F;按引用捕获  class __lambda_6_15  &#123;    public:      &#x2F;&#x2F;如果lambda使用utable修饰，const会去掉    inline &#x2F;*constexpr *&#x2F; int operator()() const    &#123;      return i + j;    &#125;    private:    &#x2F;&#x2F;引用捕获时，内部的成员变量变为了引用类型    int &amp; i;    int &amp; j;        public:    __lambda_6_15(int &amp; _i, int &amp; _j)    : i&#123;_i&#125;    , j&#123;_j&#125;    &#123;&#125;      &#125;;    __lambda_6_15 foo1 &#x3D; __lambda_6_15&#123;i, j&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​通过中间代码不难发现，我们创建<code>lambda</code>表达式的语句，编译器自动替换为了<strong>创建一个函数对象</strong>，而我们最终拿到的<code>foo1</code>也就是一个函数对象。</p><p>​并且可以看到我们捕<strong>获的值</strong>都会在函数对象内部创建<strong>相应的成员变量接收</strong>，并且重载运算符<code>()</code>函数也被标记为了<code>const</code>，这就是为什么不能在函数体内部修改按值捕获的变量的原因。</p><p>​所以流程如下，首先会创建一个函数对象，内部的成员变量跟捕获列表的一一对应（如果按值捕获成员变量就是对于应的普通类型，按引用捕获就是对应的引用类型）。然后使用外部的捕获变量创建并初始化一个函数对象，函数体内部对捕获变量的读取和修改操作都是对函数对象内部的成员变量做的，所以普通的按值捕获变量无法在函数体内被修改，即使用mutable修饰后修改的值也无法影响外部的变量，因为修改的只是函数对象内部的成员变量。（按引用捕获的变量则不受这些限制）。</p><p>​所以，在某种程度上来说，<code>lambda</code>表达式是<strong>C++11</strong>给我们提供的一块<strong>语法糖</strong>而已，可以让我们更方便的创建一个匿名的函数对象。</p><h2 id="std-function"><a href="#std-function" class="headerlink" title="std::function"></a>std::function</h2><p>​<code>std::function</code>是 <strong>C++11</strong>引入的一个通用函数包装器，定义在 <code>&lt;functional&gt;</code>头文件中。它可以存储、复制和调用任何可调用对象（Callable Object），包括：</p><ul><li><strong>普通函数</strong></li><li><strong>Lambda 表达式</strong></li><li><strong>仿函数（Functor，即重载了 <code>operator()</code>的类）</strong></li><li><strong>成员函数（需结合 <code>std::bind</code>使用）</strong></li><li><strong>函数指针</strong></li></ul><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;普通函数void print(int a, int b)&#123;std::cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; std::endl;&#125;&#x2F;&#x2F;lambda表达式auto add &#x3D; [](int a, int b)&#123;return a + b;&#125;;&#x2F;&#x2F;仿函数class adder &#123;public:int operator()(int a, int b)&#123;return a + b;&#125;&#125;;&#x2F;&#x2F;类成员函数class math&#123;public:float multi(float a, float b)&#123;return a * b;&#125;&#125;;int main()&#123;    &#x2F;&#x2F;接收普通函数    std::function&lt;void(int, int)&gt; f1 &#x3D; print;    f1(1, 2);        &#x2F;&#x2F;接收一个函数指针    auto ff &#x3D; &print;    std::function&lt;void(int, int)&gt;ff1 &#x3D; ff;    ff1(2, 3);        &#x2F;&#x2F;接收lambda表达式    std::function&lt;int(int, int)&gt; f2 &#x3D; add;    f2(3, 4);        &#x2F;&#x2F;接收仿函数    std::function&lt;int(int, int)&gt; f3 &#x3D; adder();    f3(4, 5);        &#x2F;&#x2F;接受类成员函数(要使用std::bind才可以接收)    math m;    std::function&lt;float(float, float)&gt; f4 &#x3D;         std::bind(&amp;math::multi, &amp;m, std::placeholders::_1, std::placeholders::_2);    f4(1.0f, 2.0f);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​不难发现和函数指针很类似，但是函数指针无法接收仿函数、捕获状态的<code>lambda</code>表达式，而<code>std::function</code>却都可以接受。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int addfn(int a, int b)&#123;    std::cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; std::endl;    return a + b;&#125;&#x2F;&#x2F;没有状态的lambda表达式() (没有捕获外部的变量)auto add &#x3D; [](int a, int b)&#123;    return a + b;&#125;;&#x2F;&#x2F;有状态的lambda表达式() (设置了捕获列表，有可能捕获外部变量)auto addc &#x3D; [&#x3D;](int a, int b)&#123;    return a + b;&#125;;&#x2F;&#x2F;仿函数class adder &#123;public:    int operator()(int a, int b)    &#123;        return a + b;    &#125;&#125;;int main()&#123;    &#x2F;&#x2F;创建一个函数指针auto ffptr &#x3D; &addfn;&#x2F;&#x2F;没有状态的lambda，函数指针可以接收ffptr &#x3D; add;&#x2F;&#x2F;有状态的lambda，函数指针无法接收，会编译错误&#x2F;&#x2F;ffptr &#x3D; addc;&#x2F;&#x2F;函数指针无法接收仿函数    adder aer;&#x2F;&#x2F;ffptr &#x3D; aer;&#x2F;&#x2F;ffptr &#x3D; &aer;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​可以看到<code>std::function</code>的功能非常强大，我们只需要指定要接受的函数的返回值和参数列表即可接收任何符合要求的可调用对象。语法也较为简单<code>std::function&lt;返回类型(参数类型列表)&gt; 变量名;</code> 那么代价是什么呢？虽然std::function功能强大，但由于内部的实现，所以会带来一些开销。</p><p>​使用了<code>std::function</code>作为参数可以很方便的让我们使用回调函数，因为不论是什么可调用对象，都能够被接收。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class App&#123;public:void handle(int a)&#123;std::cout &lt;&lt; &quot;APP:&quot; &lt;&lt; a &lt;&lt; std::endl;&#125;&#125;;&#x2F;&#x2F;使用std::function实现回调函数void handle(int a, int b, std::function&lt;void(int)&gt; callback)&#123;int res &#x3D; a + b;callback(res);&#125;void show(int a)&#123;&#125;class Handler&#123;public:void operator()(int a)&#123;&#125;&#125;;int main()&#123;    &#x2F;&#x2F;回调可以是类的成员函数    App app;    handle(1, 2, std::bind(&amp;App::handle, &amp;app, std::placeholders::_1));    &#x2F;&#x2F;回调可以是一个仿函数    Handler h;    handle(3, 3, h);    &#x2F;&#x2F;回调可以是一个lambda表达式    handle(2, 2, [](int a) &#123;        std::cout &lt;&lt; &quot;Lambda:&quot; &lt;&lt; a &lt;&lt; std::endl;    &#125;);    &#x2F;&#x2F;回调可以是一个函数指针    handle(2, 3, show);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><h4 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h4><h4 id="小对象优化-Small-Object-Optimization，SOO"><a href="#小对象优化-Small-Object-Optimization，SOO" class="headerlink" title="小对象优化(Small Object Optimization，SOO)"></a>小对象优化(Small Object Optimization，SOO)</h4><h4 id="关键成员函数"><a href="#关键成员函数" class="headerlink" title="关键成员函数"></a>关键成员函数</h4><h2 id="std-bind"><a href="#std-bind" class="headerlink" title="std::bind"></a>std::bind</h2><h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><p>​<code>std::bind</code>是 <strong>C++11</strong> 引入的一个函数适配器，定义在 <code>&lt;functional&gt;</code>头文件中，用于 <strong>绑定函数参数</strong> 或 <strong>调整函数调用方式</strong>。它可以将一个可调用对象（函数、<code>Lambda</code>、成员函数等）与<strong>部分参数绑定</strong>，返回一个新的可调用对象。</p><p>​<code>std::bind</code>将可调用对象与其参数一起进行绑定，绑定后的结果可以使用<code>std::function</code>保存。<code>std::bind</code>主要有以下两个作用：</p><ul><li>将可调用对象和其参数绑定成一个仿函数；</li><li>只绑定部分参数，减少可调用对象传入的参数。</li></ul><p>基本语法如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">auto bound_func &#x3D; std::bind(    original_function,    &#x2F;&#x2F; 要绑定的函数（或成员函数、函数对象）    bound_arguments...    &#x2F;&#x2F; 绑定的参数（可以是值、占位符或嵌套绑定）);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><ol><li>绑定普通函数</li></ol><p>​绑定普通函数时，<strong>第一个参数为要绑定的函数</strong>，当传递一个函数名作为实参时，会转换为函数指针，所以第一个参数写<code>sum</code>和<code>&amp;sum</code>是等价的。后面的参数就是我们要绑定的参数，如果填入变量或者具体的值，<strong>该位置就会和对应位置的形参绑定</strong>，也可以用<code>std::placeholders::_i</code>占位符，等待外界调用的时候传入参数到占位符位置。（绑定的参数连同占位符的数量要和绑定的函数一致，否则调用返回的可调用对象时会报错）。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int sum(int a, int b)&#123;return a + b;&#125;void show(int a, int b)&#123;std::cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; std::endl;&#125;int main()&#123;    &#x2F;&#x2F;auto f1 &#x3D; std::bind(sum, 10, std::placeholders::_1); 这两种写法是等价的    auto f1 &#x3D; std::bind(&amp;show, 10, std::placeholders::_1);    f1(2); &#x2F;&#x2F;输出a:10 b:2    auto f2 &#x3D; std::bind(&amp;show, std::placeholders::_1, 10);    f2(2); &#x2F;&#x2F;输出a:2 b:10        auto f3 &#x3D; std::bind(&amp;sum, 10, 11, 12); &#x2F;&#x2F;这样写会编译通过    &#x2F;&#x2F;f3(); &#x2F;&#x2F;调用这个返回的可调用对象时会报错，因为参数列表和绑定的函数不匹配&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>绑定一个成员函数</li></ol><p>​<code>std::bind</code>绑定<strong>类成员函数</strong>时，第一个参数表示对象的成员函数（公有成员函数）的指针，第二个参数表示该实例化对象的地址，后面的就是要绑定的参数。其中绑定成员函数时，第一个参数要显示指明<code>&amp;Base::fun</code>，因为编译器<strong>不会将对象的成员函数隐式转换成函数指针</strong>，这一步可以理解为要绑定的是哪个类里面的哪个函数。第二个参数是说明具体是哪一个对象的函数，把该对象的地址传进来。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Base&#123;public:void PublicShow(int a, int b)&#123;std::cout &lt;&lt; &quot;Base a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; std::endl;&#125;    static void StaticShow(int a, int b)&#123;std::cout &lt;&lt; &quot;Base Static a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; std::endl;&#125;private:&#x2F;&#x2F;只有公有的成员函数才能被绑定void PrivateShow(int a, int b)&#123;std::cout &lt;&lt; &quot;Base a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; std::endl;&#125;&#125;;int main()&#123;    Base b1;    &#x2F;&#x2F;Base::PublicShow前没有显示加上&amp;，直接编译失败    &#x2F;&#x2F;auto f4 &#x3D; std::bind(Base::PublicShow, &amp;b1, 666, std::placeholders::_1);    &#x2F;&#x2F;没有传入实例对象的地址，调用f4时编译失败    &#x2F;&#x2F;auto f4 &#x3D; std::bind(&amp;Base::PublicShow, 666, std::placeholders::_1);    auto f4 &#x3D; std::bind(&amp;Base::PublicShow, &amp;b1, 666, std::placeholders::_1);    f4(111);        &#x2F;&#x2F;静态成员函数也可以绑定，但是由于是静态函数，绑定时不能传入实例化对象的地址了    auto f5 &#x3D; std::bind(&amp;Base::StaticShow, 666, std::placeholders::_1);    f5(111);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>绑定引用参数</li></ol><p>​std::bind绑定参数默认都是按值绑定的，也就是会把值复制到可调用对象里。如果向绑定一个引用的话，必须使用**使用 <code>std::ref</code>(可变引用)或 <code>std::cref</code>(常量引用)**显示绑定引用。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void modify(int&amp; a)&#123;a &#x3D; 999;&#125;int main()&#123;    int v &#x3D; 10;    &#x2F;&#x2F;默认按值绑定，调用f6后不会影响v的值    auto f6 &#x3D; std::bind(modify, v);    f6();    std::cout &lt;&lt; v &lt;&lt; std::endl; &#x2F;&#x2F;输出还是10    &#x2F;&#x2F;调用f7会提示编译失败，因此cref表面为常量引用，不可修改    &#x2F;&#x2F;auto f7 &#x3D; std::bind(modify, std::cref(v));    &#x2F;&#x2F;f7();    &#x2F;&#x2F;使用std::ref显示引用绑定，调用f8后会修改v的值    auto f8 &#x3D; std::bind(modify, std::ref(v));    f8();    std::cout &lt;&lt; v &lt;&lt; std::endl; &#x2F;&#x2F;输出为999&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li><code>std::placeholder::_i</code>占位符</li></ol><p>​使用<code>std::bind</code>绑定参数时，可以直接绑定一个变量或值，也可以使用<code>std::placeholder::_i</code>占位符表面该位置的形参等外界调用时传入，其中<code>_i</code>表示该位置的值为调用时传入的实参的第<code>i</code>个参数的值。这样就说明了，我们调用时传入的实参至少要为<code>i</code>个，否则会编译失败。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void showAll(int a, int b, int c)&#123;std::cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; &quot; c:&quot; &lt;&lt; c &lt;&lt;std::endl;&#125;int main()&#123;    auto f &#x3D; std::bind(showAll, 1, 2, std::placeholders::_3);    &#x2F;&#x2F;f(10); 编译失败，因为std::placeholders::_3指明了接收实参列表的第三个，但是只传入了一个    &#x2F;&#x2F;f(10, 20); 编译失败，因为std::placeholders::_3指明了接收实参列表的第三个，但是只传入了两个    &#x2F;&#x2F;编译成功，最终std::placeholders::_3占位符位置的值为3    f(10, 20, 3); &#x2F;&#x2F;输出为a:1 b:2 c:3&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​知道了占位符的作用后，我们也可以调用时改变传入实参的顺序。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void showAll(int a, int b, int c)&#123;std::cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; &quot; c:&quot; &lt;&lt; c &lt;&lt;std::endl;&#125;int main()&#123;    &#x2F;&#x2F;第一个占位符表示为传入的第二个实参，第二个表示传入的第一个实参，迪桑表示传入的第三个实参    auto f1 &#x3D; std::bind(showAll, std::placeholders::_2, std::placeholders::_1, std::placeholders::_3);    &#x2F;&#x2F;经过这样处理后，相当于调用的是showAll(2, 1, 3)    f1(1, 2, 3); &#x2F;&#x2F;输出为a:2 b:1 c:3&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="std-initializer-list"><a href="#std-initializer-list" class="headerlink" title="std::initializer_list"></a>std::initializer_list</h1><h2 id="变量初始化方法"><a href="#变量初始化方法" class="headerlink" title="变量初始化方法"></a>变量初始化方法</h2><p>​在没有列表初始化之前，在C++中可以使用 <code>()</code> 和 <code>=</code> 对变量进行初始化操作。可以看到使用等号和小括号的效果是一样的，因为使用等号初始化时也是隐式调用了对应的构造函数。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class C&#123;public:C(int a)&#123;            &#125;&#125;;void foo(C temp)&#123;    &#125;int main()&#123;int a1 &#x3D; 10; &#x2F;&#x2F;使用等号拷贝初始化int a2(10); &#x2F;&#x2F;使用小括号直接初始化C c1 &#x3D; 10; &#x2F;&#x2F;使用等号拷贝初始化C c2(10); &#x2F;&#x2F;使用小括号直接初始化        foo(8); &#x2F;&#x2F;拷贝初始化，传入8，隐式调用构造函数&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="使用列表初始化"><a href="#使用列表初始化" class="headerlink" title="使用列表初始化"></a>使用列表初始化</h2><p>​C++11标准引入了列表初始化，它使用大括号<code>{}</code>对变量进行初始化。列表初始化在支持隐式调用多参数的构造函数，所以**{1, 2}<strong>可以</strong>隐式调用<strong>构造函数<code>B(int a, int b)</code>创建了</strong>B**的实例对象。如果不希望隐式调用，可以给对应构造函数前加上关键字<code>explicit</code>，表面该构造函数不能隐式调用。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class C&#123;public:C(int a)&#123;&#125;&#125;;class B&#123;public:B(int a, int b)&#123;&#125;&#125;;void foo(B temp)&#123;    &#125;int main()&#123;    int t1 &#x3D; &#123; 10 &#125;; &#x2F;&#x2F;拷贝初始化int t2&#123; 10 &#125;; &#x2F;&#x2F;直接初始化C cc1 &#x3D; &#123; 10 &#125;; &#x2F;&#x2F;拷贝初始化C cc2&#123; 10 &#125;; &#x2F;&#x2F;直接初始化B b1 &#x3D; &#123; 1, 2 &#125;; &#x2F;&#x2F;拷贝初始化B b2&#123; 1, 2 &#125;; &#x2F;&#x2F;直接初始化        foo(&#123;1,2&#125;); &#x2F;&#x2F;传入&#123;1, 2&#125;，隐式调用B(1,2)构造函数&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​在初始化列表出现之前，我们可以使用大括号对数组初始化，但无法对vector，list，map这些标准库容器使用大括号初始化，只能遍历一个个赋值。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;使用大括号对数组初始化int arr1[] &#x3D; &#123; 1, 2, 3 &#125;;int arr2[][2] &#x3D; &#123; &#123;1, 2&#125;, &#123;1, 2 &#125; &#125;;&#x2F;&#x2F;c++11之前不允许大括号对标准库容器初始化&#x2F;&#x2F;std::vector&lt;int&gt;v &#x3D; &#123; 1, 2, 3 &#125;;&#x2F;&#x2F;初始化列表出现以后，可以使用大括号对标准库容器初始化std::vector&lt;int&gt;v1 &#x3D; &#123; 1, 2, 3 &#125;;&#x2F;&#x2F;std::vector&lt;int&gt;v2&#123; 1, 2, 3 &#125;;std::map&lt;std::string, int&gt;m1 &#x3D; &#123; &#123;&quot;string&quot;, 1&#125;, &#123;&quot;sss&quot;, 2&#125; &#125;;std::map&lt;std::string, int&gt;m2&#123; &#123;&quot;string&quot;, 1&#125;, &#123;&quot;sss&quot;, 2&#125; &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="std-initializer-list详解"><a href="#std-initializer-list详解" class="headerlink" title="std::initializer_list详解"></a>std::initializer_list详解</h2><p>​标准容器之所以能够支持列表初始化，离不开编译器支持的同时，它们自己也必须满足一个条件：支持<code>std::initializer_list</code>为<strong>形参的构造函数</strong>。</p><p>​下面是<code>std::initializer_list</code>的简化实现代码：</p><p>​可以看到，其构造函数是传入两个指针，一个指向起始位置，一个指向结束位置，而<code>begin</code>和<code>end</code>函数返回的也都是**<code>const</code>修饰的原始指针**。标准库容器提供一个形参为<code>std::initializer_list</code>的构造函数，这样使用大括号赋值时就会调用该构造函数，容器内部再使用初始化列表的<code>begin</code>和<code>end</code>函数拿到指针进行初始化赋值。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class _Elem&gt;class initializer_list &#123;public:    using value_type      &#x3D; _Elem;    using size_type       &#x3D; size_t;    constexpr initializer_list() noexcept : _First(nullptr), _Last(nullptr) &#123;&#125;    constexpr initializer_list(const _Elem* _First_arg, const _Elem* _Last_arg) noexcept        : _First(_First_arg), _Last(_Last_arg) &#123;&#125;    constexpr const _Elem* begin() const noexcept &#123;        return _First;    &#125;    constexpr const _Elem* end() const noexcept &#123;        return _Last;    &#125;    constexpr size_t size() const noexcept &#123;        return static_cast&lt;size_t&gt;(_Last - _First);    &#125;private:    const _Elem* _First;    const _Elem* _Last;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​我们的自定义类在实现一个接收形参为<code>std::initializer_list</code>的构造函数后，也可以直接使用大括号进行初始化，并且可以接收任意数量的同类型参数。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class C&#123;public:C(int a)&#123;&#125;&#x2F;*C(std::initializer_list&lt;int&gt; list)&#123;&#x2F;&#x2F;返回的是const 原始指针for (const int* item &#x3D; list.begin(); item !&#x3D; list.end();++item) &#123;std::cout &lt;&lt; *item &lt;&lt; &quot; &quot;;&#125;std::cout &lt;&lt; std::endl;&#125;*&#x2F;        C(std::initializer_list&lt;int&gt; list)&#123;const int* pre &#x3D; nullptr;        &#x2F;&#x2F;返回的是const 原始指针        &#x2F;&#x2F;输出每个地址之间的间隔（以字节为单位）for (const int* item &#x3D; list.begin(); item !&#x3D; list.end();++item) &#123;if (pre &#x3D;&#x3D; nullptr)pre &#x3D; item;else                &#x2F;&#x2F;最后输出的都为4字节，表示一个int类型的大小，说明地址都是连续的std::cout &lt;&lt; (uint8_t)item - (uint8_t)pre &lt;&lt; &quot; &quot;;pre &#x3D; item;&#125;std::cout &lt;&lt; std::endl;&#125;&#125;;int main()&#123;    C c &#x3D; &#123; 1, 2, 3, 4, 5, 6 &#125;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​最后执行代码后发现形参中接收到的初始化列表里各个地址都是连续的，这说明当我们使用大括号初始化时，编译器很可能先创建了一个数组，然后再用这个数组创建<code>std::initializer_list</code>，最后调用对用的构造函数。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;先根据&#123;&#125;里面的值创建一个数组const int __a[3] &#x3D; &#123; 1, 2, 3, 4, 5, 6 &#125;;&#x2F;&#x2F;再把数组的起始指针传递给initializer_list构造一个初始化列表对象传递给对应的构造函数C c(std::initializer_list&lt;int&gt;(__a, __a+3));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="隐式缩窄转换"><a href="#隐式缩窄转换" class="headerlink" title="隐式缩窄转换"></a>隐式缩窄转换</h3><p>​在 C++ 中，<strong>隐式缩窄转换</strong>（implicit narrowing conversion）指的是在隐式类型转换过程中，目标类型无法完全容纳源类型的值，可能导致数据丢失或精度损失的情况。简单来说就是从一个<strong>范围较大或精度较高</strong>的类型<strong>转换</strong>为<strong>范围较小或精度较低</strong>的类型。</p><p>​隐式缩窄转换在传统变量初始化时是没有问题的，编译器不会报错，最多是给出一个转换可能会损失精度的警告。但是如果使用<strong>初始化列表的形式是不允许隐式缩窄转换</strong>的，会在<strong>编译时就报错</strong>。下面是出现隐式缩窄转换的操作。</p><p>​符合转换的转换源<strong>首先一定是常量或者常量表达式</strong>，然后接受的<strong>目标类型要能准确表示这个值</strong>，其次就是这<strong>两种类型对于这个值能够相互准确的转换(整形转浮点型才会出现这种问题)</strong>。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;--------------------------------------1.从浮点类型转换整数类型(浮点数可表示范围比整型大)&#123;    float f1 &#x3D; 1.0f;    int x1 &#x3D; f1; &#x2F;&#x2F; 编译成功，传统变量初始化支持隐式缩窄转换        &#x2F;&#x2F;int x2&#123; f1 &#125;; &#x2F;&#x2F;编译失败，列表初始化不支持支持隐式缩窄转换    int x3&#123; (int)f1 &#125;; &#x2F;&#x2F;这种写法也可以通过编译&#125;&#123;    double d1 &#x3D; 1.0;    int x1 &#x3D; d1; &#x2F;&#x2F; 编译成功    &#x2F;&#x2F;int x2&#123; d1 &#125;; &#x2F;&#x2F; 编译失败    int x3&#123; (int)d1 &#125;; &#x2F;&#x2F; 编译成功&#125;&#x2F;&#x2F;--------------------------------------2.从long double转换到double或float；或者从double转换到float。(但是当转换源是一个常量表达式且转换后的值在目标类型的可表示范围内，就允许列表初始化进行隐式缩窄转换)&#123;    long double ld &#x3D; 1.0;    double d1 &#x3D; ld;    &#x2F;&#x2F;double d2&#123; ld &#125;; &#x2F;&#x2F;编译不通过    float f1 &#x3D; ld;    &#x2F;&#x2F;float f2&#123; ld &#125;; &#x2F;&#x2F;编译不通过    double d3 &#x3D; 1.0;    float f3 &#x3D; d3;    &#x2F;&#x2F;float f3&#123; d3 &#125;; &#x2F;&#x2F;编译不通过        const double cd1 &#x3D; 1.0;    float f4 &#x3D; cd1;    float f5&#123; cd1 &#125;; &#x2F;&#x2F;编译通过，因为cd是常量，且1.0 在float可表示范围内    const double cd2 &#x3D; std::numeric_limits&lt;double&gt;::max();    float f6 &#x3D; cd2; &#x2F;&#x2F;虽然对于float溢出了，但是会截断，编译仍然通过    &#x2F;&#x2F;float f7&#123; cd2 &#125;; &#x2F;&#x2F;编译不通过，虽然cd是常量，但是显然double的最大值不在float可表示范围内&#125;&#x2F;&#x2F;--------------------------------------3.从整数类型或非强枚举类型转换到浮点类型(但是当转换源是一个常量表达式且转换后的值在目标类型的可表示范围内，且这个值能够再从目标值转换回原始类型的原始值时，就允许列表初始化进行隐式缩窄转换)&#123;    int x &#x3D; 10;    const int x1 &#x3D; 16777217;     const int x2 &#x3D; 100;     &#x2F;&#x2F;float f&#123; x &#125;; &#x2F;&#x2F;编译失败，要想列表初始化转换为float，首先要是常量或者常量表达式        &#x2F;&#x2F;float f1&#123; x1 &#125;; &#x2F;&#x2F;编译失败，这个数在float中无法准确存储，如果转为float后再转回int是不相等的    float f2&#123; x2 &#125;; &#x2F;&#x2F;编译成功，这个数在float中可以准确存储，转为float后再转回int是相等的    &#x2F;&#x2F;float f3&#123; 16777217 &#125;; &#x2F;&#x2F;编译失败，这个数在float中无法准确存储，如果存入float后再转回int是不相等的&#125;&#x2F;&#x2F;--------------------------------------4.从整数类型或非强枚举类型转换到不能代表所有原始类型值的整数类型(long-&gt;int,int-&gt;unsigned int等)。但是如果转换源是一个常量表达式，其值在转换之后能够适合目标类型，就允许列表初始化进行隐式缩窄转换&#123;    const int x1 &#x3D; 1 &lt;&lt; 10; &#x2F;&#x2F; 1左移十位，也就是2^10    const int x2 &#x3D; 10;    const int x3 &#x3D; -1;    &#x2F;&#x2F;char c1&#123; x1 &#125;; &#x2F;&#x2F;编译失败,char类型八位，无法表示1024    char c2&#123; x2 &#125;; &#x2F;&#x2F;编译成功,可以表示10    char c3&#123; x3 &#125;; &#x2F;&#x2F;编译成功,可以表示-1    &#x2F;&#x2F;unsigned char c4&#123; x3 &#125;; &#x2F;&#x2F;编译失败,unsigned char无法表示负数    unsigned int ui1&#123; x1 &#125;; &#x2F;&#x2F;编译成功,unsigned int可以表示1024    &#x2F;&#x2F;unsigned int ui2&#123; x3 &#125;; &#x2F;&#x2F;编译失败,unsigned int无法表示负数&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="列表初始化优先级"><a href="#列表初始化优先级" class="headerlink" title="列表初始化优先级"></a>列表初始化优先级</h3><p>​当类的构造函数接受一个<code>initializer_list</code>为形参时，那么他的<strong>优先级就会大于</strong>能匹配上的普通的构造函数。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Test&#123;public:    Test(int a, int b)    &#123;        std::cout &lt;&lt; &quot;Constructor&quot; &lt;&lt; std::endl;    &#125;    Test(int a)    &#123;        std::cout &lt;&lt; &quot;Constructor&quot; &lt;&lt; std::endl;    &#125;    Test(float a, float b)    &#123;        std::cout &lt;&lt; &quot;Constructor&quot; &lt;&lt; std::endl;    &#125;    Test(const std::string&amp; a)    &#123;        std::cout &lt;&lt; &quot;Constructor&quot; &lt;&lt; std::endl;    &#125;    Test(std::initializer_list&lt;int&gt; lists)    &#123;        std::cout &lt;&lt; &quot;initializer_list&quot; &lt;&lt; std::endl;    &#125;&#125;;int main()&#123;    Test t &#x3D; &#123; 1, 2 &#125;; &#x2F;&#x2F;隐式调用列表初始化构造函数    Test t2 &#x3D; &#123; 1 &#125;; &#x2F;&#x2F;隐式调用列表初始化构造函数        Test t3 &#x3D; std::string(&quot;123&quot;); &#x2F;&#x2F;隐式普通构造函数    &#x2F;&#x2F;虽然我们传入的是float类型，显然想让他隐式调用Test(float a, float b)，但是他却调用初始化列表的，而且想进行隐式转换，但是这属于隐式缩窄转换，是不允许的，所以会报错    &#x2F;&#x2F;Test t3 &#x3D; &#123;1.0f, 1.0f&#125;; 隐式调用列表初始化构造函数，但是不允许隐式缩窄转换，所以会报错&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h1><h2 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h2><p>​对于一个有多个参数的类来说，我们可以需要编写不同版本的构造函数，以适应各种初始化参数的情况，像下面的代码那样。而且这么多构造函数的初始化操作的代码也都一样，虽然我们可以编写一个<code>CommonInit</code>来执行最终的成员初始化和初始化逻辑，但是这样仍然也会存在大量的代码冗余，不便于后期的维护。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class X1&#123;public:X1() &#123; CommonInit(0, 0.); &#125;X1(int a) &#123; CommonInit(a, 0.); &#125;X1(double b) &#123; CommonInit(0, b); &#125;X1(int a, double b) &#123; CommonInit(a, b); &#125;private:void CommonInit(int a, double b)&#123;m_A &#x3D; a;m_B &#x3D; b;&#x2F;&#x2F;执行初始化操作&#x2F;&#x2F;...&#125;int m_A;double m_B;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​为了合理复用构造函数来减少代码冗余，<strong>C++11</strong>标准支持了<strong>委托构造函数</strong>：某个类型的<strong>一个构造函数（委托构造函数）<strong>可以</strong>委托同类型的另一个构造函数（代理构造函数）<strong>对对象</strong>进行初始化</strong>。也就是说委托构造函数可以作为一个老板，雇佣另一个构造函数执行初始化。委托构造函数会将控制权交给代理构造函数，在代理构造函数执行完之后，再执行委托构造函数的主体。</p><p>​委托构造函数的语法非常简单，只需要在委托构造函数的初始化列表中调用代理构造函数即可。<code>X(int a): X(a, 0) {}</code></p><p>​如下面的代码所示，可以看到<code>X()</code>、<code>X(int a)</code>、<code>X(double b)</code>分别作为委托构造函数将控制权交给了代理构造函数<code>X(int a, double b)</code>。这样我们就可以编写一个接受所有初始化值的通用构造函数来初始化变量并执行初始化操作，其他的构造函数通过委托调用这一个通用的构造函数即可，这样就能很大程度的减少代码冗余。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class X&#123;public:    X() : X(0, 0.) &#123;&#125;    X(int a) : X(a, 0.) &#123;&#125;    X(double b) : X(0, b) &#123;&#125;    X(int a, double b) : a_(a), b_(b) &#123; CommonInit(); &#125;private:    void CommonInit()     &#123;        &#x2F;&#x2F;执行初始化操作&#x2F;&#x2F;...    &#125;    int a_;    double b_;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​委托构造函数的执行顺序是：先执行代理构造函数，再执行委托构造函数的函数体。如果是多层的委托，就会像递归那样先调用最底层的代理构造函数，再一层层向上返回执行对应的委托构造函数的函数体。下面用一段代码演示一下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class X2&#123;public:X2() : X2(0)&#123;std::cout &lt;&lt; &quot;Constructor 1&quot; &lt;&lt; std::endl;&#125;X2(int a) : X2(a, 1.0f)&#123;std::cout &lt;&lt; &quot;Constructor 2&quot; &lt;&lt; std::endl;&#125;X2(int a, float b) &#123;std::cout &lt;&lt; &quot;Constructor 3&quot; &lt;&lt; std::endl;&#125;&#125;;int main()&#123;    X2 x;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​这段代码的构造函数委托调用逻辑如下：</p><pre class="mermaid">graph TD    A["X2()"]    A -->|委托| B["X2(int)"]    B -->|委托| C["X2(int, float)"]</pre><p>​最终的输出结果如下，可以看到执行顺序和代理顺序是相反的，类似于递归那种。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Constructor 3Constructor 2Constructor 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h2><p>1．每个构造函数都可以委托另一个构造函数为代理。这个比较好理解，每个构造函数可以委托别的构造函数干活，也可以被其他构造函数委托。简单来说就是你能找别人干活，自己也要帮别人干活才可以。</p><p>2．<strong>不要递归循环委托！</strong>。只能单向的递归委托，否则就会陷入递归循环（这也是编写递归函数要注意的点）。这种递归循环编译器有可能不会报错，最终运行时很可能会出现调用栈内存用完而溢出。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class X3&#123;public:    &#x2F;&#x2F;递归循环委托，X3()委托X3(int)，但是X3(int)又委托X3()，最终无限循环导致栈溢出X3() : X3(0)&#123;std::cout &lt;&lt; &quot;Constructor 1&quot; &lt;&lt; std::endl;&#125;X3(int a) : X3()&#123;std::cout &lt;&lt; &quot;Constructor 2&quot; &lt;&lt; std::endl;&#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="mermaid">graph TD    A["X3()"]    A -->|委托| B["X3(int)"]    B -->|委托| A["X3()"]</pre><p>3．如果一个构造函数为委托构造函数，那么其<strong>初始化列表</strong>里<strong>就不能对数据成员和基类进行初始化</strong>。简单来说，如果委托构造函数委托一个代理构造函数初始化，就说明把初始化操作交给了代理构造函数，对<strong>成员变量和基类的初始化就交给代理构造函数完成</strong>。（这里只是规定了委托构造函数的初始化列表里不能再初始化成员变量了，但是在他的函数体内部仍然可以对成员变量赋值）。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class X4&#123;public:&#x2F;&#x2F;委托构造函数的初始化列表中不能初始化成员变量，因为已经交给代理构造函数了&#x2F;&#x2F;X4() : m_A(0), X4(0)&#x2F;&#x2F;&#123;&#x2F;&#x2F;std::cout &lt;&lt; &quot;Constructor 1&quot; &lt;&lt; std::endl;&#x2F;&#x2F;&#125;&#x2F;&#x2F;虽然初始化列表中不能初始化成员变量，但是函数体内部仍然可以对成员变量赋值X4() : X4(0)&#123;m_A &#x3D; 0;std::cout &lt;&lt; &quot;Constructor 1&quot; &lt;&lt; std::endl;&#125;X4(int a) : m_A(a)&#123;std::cout &lt;&lt; &quot;Constructor 2&quot; &lt;&lt; std::endl;&#125;public:int m_A;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4．委托构造函数的执行顺序是先执行代理构造函数的初始化列表，然后执行代理构造函数的主体，最后执行委托构造函数的主体。这个也好理解，而且前面已经说过了。</p><p>5．如果在<strong>代理构造函数执行完成后</strong>，<strong>委托构造函数主体</strong>抛出了<strong>异常</strong>，则自动<strong>调用该类型的析构函数</strong>。通常情况下在没有完成构造函数的情况下，也就是说构造函数发生异常，此时会认为对象并没有创建完成，所以对象类型的析构函数是不会被调用的。但是<strong>代理构造函数执行完成</strong>后就会<strong>认为对象已经构造完成了</strong>，所以即使委托构造函数中有异常了，也会调用其析构函数。</p><h1 id="函数参数计算顺序"><a href="#函数参数计算顺序" class="headerlink" title="函数参数计算顺序"></a>函数参数计算顺序</h1><p>​在传递调用函数时，我们有时可能会直接传入一个表达式作为函数实参，但是如果我们传入的实参中有多个表达式的形式，那么每个形参赋值的顺序是什么呢？</p><p>​对于下面的示例代码，下面集中情况都有可能：</p><ol><li><p>有可能先计算a + 1赋值给形参，再计算b + 1赋值给形参</p></li><li><p>有可能先计算b + 1赋值给形参，再算a + 1赋值给形参</p></li><li><p>有可能同时计算，再同时赋值给形参</p></li></ol><p>​但实际上我们并不知道，同一编译器在Debug和Release下顺序可能会不一样，不同编译器直接的顺序也可能会不一样，实际上这很大程度上是取决于编译器的计算顺序。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int Sum(int a, int b)&#123;    return a + b;&#125;int main()&#123;    int a &#x3D; 10;    int b &#x3D; 20;    Sum(a + 1, b + 1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​c++并未提供一种规范要求函数参数的求值顺序是什么，主要还是取决于各种编译器的实现决定的，所以不同的编译器的计算顺序有可能是完全不同的，所以实际上我们并不能指定函数形参求值的顺序是什么。</p><h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><p>C++11 引入了 3 个智能指针类型：</p><ol><li><code>std::unique_ptr&lt;T&gt;</code> ：独占资源所有权的指针。</li><li><code>std::shared_ptr&lt;T&gt;</code> ：共享资源所有权的指针。</li><li><code>std::weak_ptr&lt;T&gt;</code> ：共享资源的观察者，需要和 std::shared_ptr 一起使用，不影响资源的生命周期。</li></ol><h2 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h2><p>​在我们使用裸指针的时候，使用<code>new</code>在堆区申请了空间后，非常容易忘记<code>delete</code>释放掉，会造成内存泄漏。当我们相对资源进行独享时，就可以使用<code>std::unique_ptr</code>进行管理，当离开变量的作用域时会自动释放掉资源。是很基本的<strong>RAII</strong>(<strong>Resource Acquisition Is Initialization，资源获取即初始化</strong>)思想，简单来说就是对象创建时获取资源，对象离开作用域被销毁时释放资源，从而保证申请的内存一定会被释放。</p><h3 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h3><p>​首先，<code>std::unique_ptr</code>的定位非常明确，就是独占资源，保证了同时只能有一个指针指向一块内存。为此其内部删除了拷贝构造和拷贝赋值，但可以使用移动构造和移动赋值，也就是说内部的资源<strong>不能复制</strong>，<strong>只能移动</strong>。</p><p>​下面看一下具体用法：</p><p>​<code>std::unique_ptr</code>是只能移动，不可复制的；他重载了<code>*</code>和<code>-&gt;</code>运算符，我们可以像使用原始指针那样使用他；同时也提供了<code>get()</code>函数获取原始指针；使用<code>release()</code>函数放弃自己的拥有权，返回原始指针；使用<code>reset()</code>函数释放自己的资源并置空，也就是手动释放资源。</p><p>​<code>std::unique_ptr</code>也实现了模板特化以支持数组形式，使用时要使用<code>[ ]</code>显示指明，即<code>std::unique_ptr&lt;Data[]&gt;pArr</code>。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct Data&#123;&#x2F;&#x2F;创建unique_ptr数组形式，只能调用默认构造函数，所以必须提供Data()&#123;&#125;    Data(int a):m_Val(a)&#123;&#125;~Data()&#123;std::cout &lt;&lt; &quot;Destory&quot; &lt;&lt; std::endl;&#125;int m_Val &#x3D; 0;&#125;;int main()&#123;    &#x2F;&#x2F;两种写法都可以，但是推荐第一种写法（更安全）std::unique_ptr&lt;Data&gt; p1 &#x3D; std::make_unique&lt;Data&gt;(10); &#x2F;&#x2F;可以直接传递参数调用对应的构造函数std::unique_ptr&lt;Data&gt; p2(new Data(10)); &#x2F;&#x2F;这种写法仍需要手动调用new，不太安全        &#123;        &#x2F;&#x2F;获取原始数据        Data* p &#x3D; p1.get();        &#x2F;&#x2F;这样就是把p1的资源释放并置空（常用）        p1.reset();        &#x2F;&#x2F;危险操作，这样会导致p1和p2释放同一个内存而报错        &#x2F;&#x2F;p1.reset(p2.get());         p1.reset(new Data(10)); &#x2F;&#x2F;释放原有内存，管理新传来的内存        p1.release(); &#x2F;&#x2F;交出管理权，内部置空，返回原始指针（release之后智能指针就不负责释放了，必须记得手动释放）                p1.swap(p2); &#x2F;&#x2F;交换两个unique_ptr的内容    &#125;            &#123;        &#x2F;&#x2F;当创建普通对象时，make_unique的实参会完美转发给对应类型的构造函数        std::unique_ptr&lt;Data&gt; p3 &#x3D; std::make_unique&lt;Data&gt;(10); &#x2F;&#x2F;离开作用域之后会调用Data的析构函数    &#125;        &#x2F;&#x2F;p1 &#x3D; p2; 编译失败，unique_ptr不允许复制p1 &#x3D; std::move(p2); &#x2F;&#x2F;可以移动            &#123;        &#x2F;&#x2F;创建一个Data数组，只能调用默认构造函数，因为make_unique里的实参表面数组的大小        std::unique_ptr&lt;Data[]&gt;pArr &#x3D; std::make_unique&lt;Data[]&gt;(10);        &#x2F;&#x2F;输出的都是默认值        for (int i &#x3D; 0; i &lt; 10; i++)            std::cout &lt;&lt; pArr[i].m_Val &lt;&lt; std::endl;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​除了上述提到的函数，智能指针还允许我们自定义<strong>deleter(删除器)</strong>，并且这个删除器的函数参数一般情况下要是<code>std::unique_ptr</code>所<strong>管理对象类型的指针</strong>（如果是多态的话，即使管理对象是派生类，也可以用<strong>基类指针</strong>作为参数）。当我们指定删除器之后，就不会使用默认删除器释放内存了，所以一定要在<strong>自定义删除器里面释放内存或其他资源</strong>。但是当我们自定义删除器之后，就不能使用<code>make_unique</code>创建了，就必须调用其构造函数直接创建。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;自定义删除器基本语法(T为管理资源的类型,F为构造器的类型)std::unique_ptr&lt;T, F&gt; ptr(raw_ptr, deleter);struct Data&#123;&#x2F;&#x2F;创建unique_ptr数组形式，只能调用默认构造函数，所以必须提供Data()&#123;&#125;Data(int a):m_Val(a)&#123;&#125;~Data()&#123;std::cout &lt;&lt; &quot;Destory&quot; &lt;&lt; std::endl;&#125;int m_Val;&#125;;void f3(Data* d)&#123;std::cout &lt;&lt; &quot;普通函数删除器&quot; &lt;&lt; std::endl;if (d)delete d;&#125;int main()&#123;    &#x2F;&#x2F;使用lambda表达式作为删除器    auto f1 &#x3D; [](Data* d) &#123;        std::cout &lt;&lt; &quot;lambda删除器&quot; &lt;&lt; std::endl;        if(d)delete d; &#x2F;&#x2F;知道了删除器之后，就不会指向默认删除器了，所以内存我们必须手动释放，否则就会内存泄漏    &#125;;    &#x2F;&#x2F;因为模板里传入删除器的类型，可以直接用decltype获取，自定义删除器就不能使用make_unique的方式创建了    std::unique_ptr&lt;Data, decltype(f1)&gt; p1(new Data(10), f1);&#x2F;&#x2F;使用函数对象作为删除器    struct F    &#123;        void operator()(Data* d)        &#123;            std::cout &lt;&lt; &quot;函数对象删除器&quot; &lt;&lt; std::endl;            if (d)delete d;        &#125;    &#125;;    F f2;    &#x2F;&#x2F;使用函数对象的话，模板里可以直接使用类型名，不用decltype    std::unique_ptr&lt;Data, F&gt; p2(new Data(10), f2);    &#x2F;&#x2F;也可以直接使用函数指针作为删除器    std::unique_ptr&lt;Data, decltype(&amp;f3)&gt; p3(new Data(10), &amp;f3);    &#x2F;&#x2F;模板参数也可以用std::function，这样符合条件的可调用对象都能作为参数传进来    std::unique_ptr&lt;Data, std::function&lt;void(Data*)&gt;&gt; p11(new Data(10), f1);    std::unique_ptr&lt;Data, std::function&lt;void(Data*)&gt;&gt; p22(new Data(10), f2);    std::unique_ptr&lt;Data, std::function&lt;void(Data*)&gt;&gt; p33(new Data(10), &amp;f3);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>​<code>std::unique_ptr</code>的实现原理较为简单，只需要记住不可复制，只能移动；每个<code>unique_ptr</code>只能指向一块内存，不允许多个同时指向一块内存。可以看到<code>std::unique_ptr</code>只是按照RAII原则将指针封装起来了，并没有太多额外的开销，所以<code>std::unique_ptr</code>的<strong>开销和原始指针差不多</strong>。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;typename T&gt;class UniquePtr&#123;public:UniquePtr() : m_Raw(nullptr) &#123;&#125;&#x2F;&#x2F;必须显示调用，防止发生隐式转换explicit UniquePtr(T* ptr) : m_Raw(ptr) &#123;&#125;~UniquePtr()&#123;&#x2F;&#x2F;析构时释放内存if (m_Raw) &#123; delete m_Raw; m_Raw &#x3D; nullptr; &#125;&#125;&#x2F;&#x2F;不允许资源拷贝，拷贝构造和赋值运算符都删除UniquePtr(const UniquePtr&amp; other) &#x3D; delete;UniquePtr&amp; operator&#x3D;(const UniquePtr&amp; other) &#x3D; delete;&#x2F;&#x2F;只能通过移动构造或移动赋值实现资源转移UniquePtr(UniquePtr&amp;&amp; other) noexcept&#123;m_Raw &#x3D; other.m_Raw;other.m_Raw &#x3D; nullptr;&#125;UniquePtr&amp; operator &#x3D; (UniquePtr&amp;&amp; other) noexcept&#123;&#x2F;&#x2F;避免自赋值导致误删if (this &#x3D;&#x3D; &amp;other) return *this;if (m_Raw)delete m_Raw;m_Raw &#x3D; other.m_Raw;other.m_Raw &#x3D; nullptr;&#125;&#x2F;&#x2F;外部获取原始指针T* Get() &#123; return m_Raw; &#125;const T* Get() const &#123; return m_Raw; &#125;&#x2F;&#x2F;运算符重载简化操作operator bool() const &#123; return m_Raw !&#x3D; nullptr; &#125;T&amp; operator *() &#123; return *m_Raw; &#125;T* operator -&gt;() &#123; return m_Raw; &#125;private:&#x2F;&#x2F;原始指针T* m_Raw;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a>std::shared_ptr</h2><p>​<code>std::shared_ptr</code>也可以管理资源，被销毁时自动释放管理的空间。但是与<code>unique_ptr</code>的独占资源不同的是，<code>shared_ptr</code>是<strong>允许共享资源</strong>的。其内部维护一个引用计数，表示所指向的内存当前同时有多少人共享。只有当引用计数为0时才能释放所指向的内存，也因此<code>std::shared_ptr</code>是<strong>可复制、可移动</strong>的。</p><h3 id="使用-4"><a href="#使用-4" class="headerlink" title="使用"></a>使用</h3><p>​很多<code>unique_ptr</code>支持的<code>shared_ptr</code>也同样支持。但是后者没有<code>release()</code>函数，有独特的<code>use_count()</code>函数返回引用计数；而且shared_ptr允许复制，并且他的自定义删除器也比<code>unique_ptr</code>写起来要简单，不用在模板中指明构造器的类型，直接把构造器当作形参传进去即可。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;自定义删除器基本语法(T为管理资源的类型)std::unique_ptr&lt;T&gt; ptr(raw_ptr, deleter);int main()&#123;        &#x2F;&#x2F;两种创建方法都可以，但是推荐第二种写法，使用make_shared而不是自己调用new    std::shared_ptr&lt;Data&gt; p1(new Data(10));    std::shared_ptr&lt;Data&gt; p2 &#x3D; std::make_shared&lt;Data&gt;(10); &#x2F;&#x2F;推荐    &#x2F;&#x2F;允许复制，此时p3内和p1内指向同一块内存，且引用计数加一    std::shared_ptr&lt;Data&gt; p3 &#x3D; p1;    &#123;        &#x2F;&#x2F;获取原始指针        Data* temp &#x3D; p3.get();        &#x2F;&#x2F;reset函数和unique_ptr的reset作用一样，什么都不传等于置空并且其内部的引用计数见一        p3.reset();        &#x2F;&#x2F;p3.release(); shared_ptr没有release函数，如果想主动放弃就调用reset函数        &#x2F;&#x2F;交换两个内部的值        p2.swap(p1);        &#x2F;&#x2F;返回引用计数        int count &#x3D; p2.use_count();    &#125;    &#123;        &#x2F;&#x2F;重载了*和-&gt;，也可以像原始指针那样使用        p1-&gt;m_Val &#x3D; 11;        (*p1).m_Val &#x3D; 222;    &#125;    &#123;        auto f &#x3D; [](Data* d) &#123;            if (d)delete d;            &#125;;        std::shared_ptr&lt;Data&gt; p4(new Data(10), f);    &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><p>​使用<code>shared_ptr</code>很容易陷入循环引用问题中，一旦陷入循环引用中，当<code>shared_ptr</code>超出作用域销毁时因为<strong>引用计数不为0</strong>，就不会释放所管理的资源，就造成了<strong>内存泄漏</strong>。为了解决这一问题，<code>std::weak_ptr</code>应运而生，下面会介绍。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct B&#123;~B()&#123;std::cout &lt;&lt; &quot;B的析构&quot; &lt;&lt; std::endl;&#125;std::shared_ptr&lt;A&gt; m_Ptr;&#125;;struct A&#123;~A()&#123;std::cout &lt;&lt; &quot;A的析构&quot; &lt;&lt; std::endl;&#125;std::shared_ptr&lt;B&gt; m_Ptr;&#125;;int main()&#123;    &#x2F;&#x2F;循环引用    &#123;        std::cout &lt;&lt; &quot;相互引用&quot; &lt;&lt; std::endl;        std::shared_ptr&lt;A&gt;a(new A());        std::shared_ptr&lt;B&gt;b(new B());        &#x2F;&#x2F;此时，a和b的引用计数均为1        std::cout &lt;&lt; a.use_count() &lt;&lt; &quot; &quot; &lt;&lt; b.use_count() &lt;&lt; std::endl;        &#x2F;&#x2F;将b复制给a里面的shared_ptr，a复制给b里面的shared_ptr        a-&gt;m_Ptr &#x3D; b;        b-&gt;m_Ptr &#x3D; a;        &#x2F;&#x2F;此时，a和b的引用计数均为2        std::cout &lt;&lt; a.use_count() &lt;&lt; &quot; &quot; &lt;&lt; b.use_count() &lt;&lt; std::endl;    &#125;&#x2F;&#x2F;当a和b退出作用域时，a和b的引用计数都会减一，但减一后仍不为0，所以内存没有被释放，造成内存泄漏&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>​实现和<code>unique_ptr</code>类似，但是需要注意<strong>维护引用计数的值</strong>，每次析构、复制的时候都要注意维护正确的引用计数的值，只有当引用计数为0时才能删除所管理的内存。这里实现的只是简化版本的，只有强引用计数，没有把考虑弱引用进来。由于<code>shared_ptr</code>内部需要维护引用计数和其他的相关数据，所以会<strong>产生一定的开销</strong>。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;typename T&gt;class SimpleSharedPtr&#123;public:SimpleSharedPtr() : m_Raw(nullptr), m_RefCount(nullptr) &#123;&#125;explicit SimpleSharedPtr(T* ptr) : m_Raw(ptr), m_RefCount&#123; new int(1) &#125; &#123;&#125;SimpleSharedPtr(const SimpleSharedPtr&amp; other);SimpleSharedPtr(SimpleSharedPtr&amp;&amp; other);~SimpleSharedPtr();SimpleSharedPtr&lt;T&gt;&amp; operator&#x3D;(const SimpleSharedPtr&amp; other);SimpleSharedPtr&lt;T&gt;&amp; operator&#x3D;(SimpleSharedPtr&amp;&amp; other);inline operator bool() &#123; return m_Raw !&#x3D; nullptr; &#125;inline T* operator-&gt;() &#123; return m_Raw; &#125;inline T&amp; operator*() &#123; return *m_Raw; &#125;inline T* Get() &#123; return m_Raw; &#125;inline const T* Get() const &#123; return m_Raw; &#125;private:void Release();private:T* m_Raw;int* m_RefCount;&#125;;template&lt;typename T&gt;inline SimpleSharedPtr&lt;T&gt;::SimpleSharedPtr(const SimpleSharedPtr&amp; other):m_Raw(other.m_Raw), m_RefCount(other.m_RefCount)&#123;if(m_RefCount)(*m_RefCount)++;&#125;template&lt;typename T&gt;inline SimpleSharedPtr&lt;T&gt;::SimpleSharedPtr(SimpleSharedPtr&amp;&amp; other):m_Raw(other.m_Raw), m_RefCount(other.m_RefCount)&#123;other.m_Raw &#x3D; nullptr;other.m_RefCount &#x3D; nullptr;&#125;template&lt;typename T&gt;inline SimpleSharedPtr&lt;T&gt;::~SimpleSharedPtr()&#123;Release();&#125;template&lt;typename T&gt;inline SimpleSharedPtr&lt;T&gt;&amp; SimpleSharedPtr&lt;T&gt;::operator&#x3D;(const SimpleSharedPtr&amp; other)&#123;if (this !&#x3D; &amp;other)&#123;Release();m_Raw &#x3D; other.m_Raw;m_RefCount &#x3D; other.m_RefCount;if(m_RefCount)(*m_RefCount)++;&#125;return *this;&#125;template&lt;typename T&gt;inline SimpleSharedPtr&lt;T&gt;&amp; SimpleSharedPtr&lt;T&gt;::operator&#x3D;(SimpleSharedPtr&amp;&amp; other)&#123;if (this !&#x3D; &amp;other)&#123;Release();m_Raw &#x3D; other.m_Raw;m_RefCount &#x3D; other.m_RefCount;other.m_Raw &#x3D; nullptr;m_RefCount &#x3D; nullptr;&#125;return *this;&#125;template&lt;typename T&gt;void SimpleSharedPtr&lt;T&gt;::Release()&#123;if (--(*m_RefCount) &#x3D;&#x3D; 0)&#123;delete m_RefCount;m_RefCount &#x3D; nullptr;if (m_Raw) &#123; delete m_Raw; m_Raw &#x3D; nullptr; &#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="std-weak-ptr"><a href="#std-weak-ptr" class="headerlink" title="std::weak_ptr"></a>std::weak_ptr</h2><p>​<code>weak_ptr</code>是专门设计用来解决 <code>shared_ptr</code>的循环引用问题的，他是一个”弱引用”指针，它不拥有对象的所有权，也<strong>不增加引用计数</strong>。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;针对于上面的循环引用情况，只需要把两个类内部的shared_ptr改为weak_ptr即可解决循环引用问题struct B&#123;~B()&#123;std::cout &lt;&lt; &quot;B的析构&quot; &lt;&lt; std::endl;&#125;&#x2F;&#x2F;std::shared_ptr&lt;A&gt; m_Ptr;&#x2F;&#x2F;换为弱引用指针时不会增加shared_ptr的引用计数，可以解决循环引用问题std::weak_ptr&lt;A&gt; m_WeakPtr;&#125;;struct A&#123;~A()&#123;std::cout &lt;&lt; &quot;A的析构&quot; &lt;&lt; std::endl;&#125;&#x2F;&#x2F;std::shared_ptr&lt;B&gt; m_Ptr;std::shared_ptr&lt;B&gt; m_WeakPtr;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​下面看一下具体的使用：</p><p>​<code>weak_ptr</code>没有重载<code>*</code>和<code>-&gt;</code>运算符；他的<code>use_count()</code>返回的是所观察的<code>shared_ptr</code>的引用计数；使用<code>lock()</code>函数可以安全的获得<code>shared_ptr</code>，如果观察的<code>shared_ptr</code>已经被销毁就返回<code>nullptr</code>；使用<code>expired()</code>可以查看所观察的<code>shared_ptr</code>是否还存在，存在就返回<code>true</code>，否则返回<code>false</code>。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main()&#123;        std::shared_ptr&lt;Data&gt; p1 &#x3D; std::make_shared&lt;Data&gt;(10);    std::cout &lt;&lt; p1.use_count() &lt;&lt; std::endl; &#x2F;&#x2F;引用计数为1    std::weak_ptr&lt;Data&gt; pw &#x3D; p1;    std::cout &lt;&lt; p1.use_count() &lt;&lt; std::endl; &#x2F;&#x2F;引用计数还是1        &#123;        std::weak_ptr&lt;Data&gt; pw2;        &#123;            std::shared_ptr&lt;Data&gt; p2 &#x3D; std::make_shared&lt;Data&gt;(10);            pw2 &#x3D; p2;            std::cout &lt;&lt; pw2.expired() &lt;&lt; std::endl; &#x2F;&#x2F;返回false            std::cout &lt;&lt; pw2.use_count() &lt;&lt; std::endl; &#x2F;&#x2F;返回1            std::shared_ptr&lt;Data&gt; p3 &#x3D; pw2.lock(); &#x2F;&#x2F;此时会增加引用计数            std::cout &lt;&lt; (pw2.lock() &#x3D;&#x3D; nullptr) &lt;&lt; std::endl; &#x2F;&#x2F;返回false        &#125;        &#x2F;&#x2F;退出作用域，销毁p2        std::cout &lt;&lt; pw2.expired() &lt;&lt; std::endl; &#x2F;&#x2F;返回true        std::cout &lt;&lt; pw2.use_count() &lt;&lt; std::endl; &#x2F;&#x2F;返回0        std::cout &lt;&lt; (pw2.lock() &#x3D;&#x3D; nullptr) &lt;&lt; std::endl; &#x2F;&#x2F;返回true    &#125;                &#123;        &#x2F;&#x2F;weak_ptr并没有重载*和-&gt;运算符        &#x2F;&#x2F;pw-&gt;m_Val;        &#x2F;&#x2F;(*pw).m_Val;    &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="shared-ptr和weak-ptr"><a href="#shared-ptr和weak-ptr" class="headerlink" title="shared_ptr和weak_ptr"></a>shared_ptr和weak_ptr</h2><p>​现在为了解决循环引用问题引入了<code>weak_ptr</code>，所以<code>shared_ptr</code>就必须能兼容<code>weak_ptr</code>了，下面具体讲一下底层的原理。</p><p>​如下图所示，<code>shared_ptr</code>内有一个指向其管理对象的指针和指向控制块的指针，控制块内目前只关注<strong>强引用计数</strong>和<strong>弱引用计数</strong>。其中<strong>强引用计数</strong>表示当前有多少个 <code>shared_ptr</code>实例拥有该对象的所有权，<strong>弱引用计数</strong>表示当前有多少个 <code>weak_ptr</code>实例正在<strong>观察</strong>该对象，但<strong>不拥有所有权</strong>。</p><p>​当强引用计数为0时，会释放掉所管理对象的内存；如果此时弱引用计数不为0，控制块指针指向的内存不会被释放，只有当弱引用也为0时才会释放控制块指针指向的内存。</p><p>​前面说过的<code>lock()</code>函数和<code>expired()</code>函数就是根据控制块内的强引用计数判断的，如果<strong>强引用计数为0，就表面该对象已经被销毁了</strong>，所以此时<code>lock()</code>会返回<code>nullptr</code>而不会返回一个<code>shared_ptr</code>；<code>expired()</code>函数返回<code>true</code>，表面该对象已经被销毁了。</p><pre class="mermaid">graph TD    %% 更简洁专业的版本    A1[ctrlPtr]:::pointer    A2[objPtr]:::pointer        B[控制块<br/>use_count: 强引用计数<br/>weak_count: 弱引用计数<br/>deleter: 删除器函数<br/>allocator: 内存分配器]:::control        C1[ctrlPtr]:::pointer    D[动态分配的对象<br/>存储实际数据]:::object    %% 虚线框表示智能指针实例    subgraph SP["std::shared_ptr"]        A1        A2    end        subgraph WP["std::weak_ptr"]        C1    end    %% 连接关系    A1 --> B    A2 --> D    C1 --> B    %% 样式定义    classDef pointer fill:#f5f5f5,stroke:#333,stroke-width:1.5px    classDef control fill:#fff3e0,stroke:#ff9800,stroke-width:2px    classDef object fill:#e8f5e8,stroke:#4caf50,stroke-width:2px    classDef shared fill:#e3f2fd,stroke:#2196f3,stroke-width:1px,stroke-dasharray: 3 3,width:280px    classDef weak fill:#f3e5f5,stroke:#9c27b0,stroke-width:1px,stroke-dasharray: 3 3,width:140px        class SP shared    class WP weak    class A1,A2,C1 pointer    class B control    class D object</pre><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><pre class="mermaid">graph TD    A[基类Base]    A --> C[子类Derive1]    A --> D[子类Derive2]</pre><p>​向下转换：基类指针&#x2F;引用向下转换为子类指针&#x2F;引用。</p><p>​向上转换：子类指针&#x2F;引用向上转换为基类指针&#x2F;引用。</p><p>​下面几类类型转换的写法一致：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">static_cast&lt;类型&gt;(变量);dynamic_cast&lt;类型&gt;(变量);const_cast&lt;类型&gt;(变量);reinterpret_cast&lt;类型&gt;(变量);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><p>​<code>static_cast</code>只会在编译时检查，由编译器判断是否能进行转换。主要用于：</p><ul><li>基本数据类型转换（<code>int</code>→ <code>double</code>）。</li><li>父子类指针&#x2F;引用的 <strong>向上转换</strong>（子类 → 基类）。</li><li>父子类指针&#x2F;引用的<strong>向下转换</strong>（基类 → 子类，但 <strong>不安全</strong>）。</li></ul><p>​指针之间不能直接使用<code>static_cast</code>转换，只能通过<code>void*</code> 才能相互转换，因为<code>static_cast</code>只允许指针和<code>void*</code> 相互转换</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;-------------------------1. 基本类型相互转换double d &#x3D; 3.14;char c &#x3D; &#39;a&#39;;int i &#x3D; static_cast&lt;int&gt;(d);int j &#x3D; static_cast&lt;int&gt;(c);&#x2F;&#x2F;-------------------------2. 指针与void*相互转换int value &#x3D; 42;int* intPtr &#x3D; &value;&#x2F;&#x2F; 将int*转换为void*void* voidPtr &#x3D; static_cast&lt;void*&gt;(intPtr);&#x2F;&#x2F; 将void*转换回int*int* newIntPtr &#x3D; static_cast&lt;int*&gt;(voidPtr);&#x2F;&#x2F;指针之间不能之直接转换，只能先转为void*再转为其他类型int a &#x3D; 10;int* aPtr &#x3D; &a;float b &#x3D; 10.0f;float* bPtr &#x3D; &b;bPtr &#x3D; static_cast&lt;float*&gt;(static_cast&lt;void*&gt;(aPtr));&#x2F;&#x2F;-------------------------3. 父类与子类间指针&#x2F;引用向上转换（安全）Derived* derived &#x3D; new Derive();Base* base_ptr &#x3D; static_cast&lt;Base*&gt;(derived);  &#x2F;&#x2F; 向上转换（安全）&#x2F;&#x2F;-------------------------4. 父类与子类间指针&#x2F;引用向下转换（不安全！程序员必须确定父类指针指向的为子类对象）&#x2F;&#x2F;下面两种转换编译器都是允许的，但是第一种情况转换后肯定会出问题，第二种转换是正确的，所以向上转换时要么确定转换一定正确，要么就使用dynamic_cast运行时检查Base* base1 &#x3D; new Base();Derived* derived_ptr1 &#x3D; static_cast&lt;Derived*&gt;(base1);Base* base2 &#x3D; new Derived();Derived* derived_ptr2 &#x3D; static_cast&lt;Derived*&gt;(base2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><p>​<code>dynamic_cast</code>专门用来处理多态（有虚函数的类）的 <strong>向下转换</strong>（基类 → 子类）。该转换会在<strong>运行时检查</strong>，如果转换失败：</p><ul><li>指针 → 返回 <code>nullptr</code>。</li><li>引用 → 抛出 <code>std::bad_cast</code>异常。</li></ul><p>​<code>dynamic_cast</code>也可用来处理<strong>向上转换</strong>（子类 → 基类 ），<strong>向上转换不要求基类有虚函数</strong>，但<strong>向下转换基类必须要有虚函数</strong>（多态）。</p><p>运行时需要 <strong>运行时类型信息（RTTI）</strong>，可能影响性能。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Base&#123;public:Base() &#x3D; default;virtual void Hello()&#123;&#125;&#125;;class Derive : public Base&#123;public:Derive() &#x3D; default;&#125;;int main()&#123;    Derive* derive1 &#x3D; new Derive();Base* base1 &#x3D; new Base();    Base* base2 &#x3D; new Derive();    &#x2F;&#x2F;转换失败，temp1为nullptrDerive* temp1 &#x3D; dynamic_cast&lt;Derive*&gt;(base1);    &#x2F;&#x2F;转换成功，temp2为正常指针    Derive* temp2 &#x3D; dynamic_cast&lt;Derive*&gt;(base2);        &#x2F;&#x2F;向上转换（子类-&gt;基类）是安全的，static_cast和dynamic_cast都可处理    Base* b1 &#x3D; dynamic_cast&lt;Base*&gt;(derive1);Base* b2 &#x3D; static_cast&lt;Base*&gt;(derive1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​<code>static_cast</code>只能在编译时检查，但是<code>Base*</code> 转换为<code>Derive*</code> 操作是被编译器允许的，所以并不能检测出能不能进行转换，因为很可能出现<code>Base*</code>并<strong>不是由多态基类指针指向子类对象而创建的</strong>，就是一个单纯的基类指针，这种转换显然是不合理的。而<code>dynamic_cast</code>可以在允许时检查这种转换是否正确，以此提升安全性。</p><h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h2><p>​<strong><code>const_cast</code></strong> 是 C++ 中专门用于 <strong>常量属性</strong> 的类型转换操作符。它的主要作用是 <strong>移除</strong> 或 <strong>添加</strong> 对象的 <strong><code>const</code></strong> 或 <strong><code>volatile</code></strong> 修饰符。与其他类型转换操作符不同，<strong><code>const_cast</code></strong> <strong>只能用于修改对象的常量性</strong>，而<strong>不能用于在不同类型之间进行转换</strong>。 </p><p>​用法：</p><ul><li><strong>移除 <code>const</code> 限定符</strong>：允许将指向常量的指针或引用转换为指向非常量的指针或引用，以便修改常量对象（注意：修改真正的常量对象会导致未定义行为）。</li><li><strong>添加 <code>const</code> 限定符</strong>：也可以用于给指针或引用添加 <code>const</code> 限定符。</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Modify(int* a)&#123;*a &#x3D; 666;&#125;void ModifyConst(const int* a)&#123;    &#x2F;&#x2F;a指向的内存不能被修改&#x2F;&#x2F;*a &#x3D; 666;&#125;int main()&#123;    &#x2F;&#x2F;-----------------------------------------1. 去除const修饰(直接修改const变量的值可能导致未定义行为，不安全)    const int x &#x3D; 1;const int* ptr &#x3D; &x;    Modify(ptr);&#x2F;&#x2F;编译器报错，因为const int*无法转换为int*Modify(const_cast&lt;int*&gt;(ptr));&#x2F;&#x2F;使用const_cast将const int*转换为int*，即去除掉const修饰std::cout &lt;&lt; x &lt;&lt; std::endl;        &#x2F;&#x2F;-----------------------------------------2. 去除const修饰，修改非const变量(可以安全修改)    int x &#x3D; 1;const int* ptr &#x3D; &x;Modify(const_cast&lt;int*&gt;(ptr));&#x2F;&#x2F;使用const_cast将const int*转换为int*，即去除掉const修饰std::cout &lt;&lt; x &lt;&lt; std::endl;        &#x2F;&#x2F;-----------------------------------------3. 添加const修饰，防止某些函数修改对象    int x &#x3D; 1;int* ptr &#x3D; &x;ModifyConst(const_cast&lt;const int*&gt;(ptr));&#x2F;&#x2F;使用const_cast将int*转换为const int*，即添加const修饰std::cout &lt;&lt; x &lt;&lt; std::endl;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h2><p>​<code>reinterpret_cast</code> 是 C++ 中最强大、但也最危险的类型转换操作符之一。它允许在<strong>不同类型之间进行低级别的类型转换</strong>。与其他类型转换操作符不同，<code>reinterpret_cast</code> 并<strong>不会进行任何类型检查</strong>，它仅仅是<strong>重新解释二进制位的含义</strong>，直接将一个类型的位模式重新解释为另一个类型。<br>​简单来说就是<code>reinterpret_cast</code>转换时不关心二者之间的转换是否合理，不做任何检查，而是强制将一段内存解释为另一种类型。</p><p>​对于下面的例子来说，就是将<code>aPtr</code>所指向的内存重新解释为<code>float</code>类型。转换后<code>aPtr</code>和<code>bPtr</code>都指向同一块内存空间，该空间的内容为<code>0x0000000a</code>，是十六进制表示的数字10。虽然两个指针指向一块内存空间，但是一个是<code>int*</code> ，一个是<code>float*</code> ，两个指针对该内存的解释不同，一个当作<code>int</code>型解释，一个当作<code>float</code>型解释。最后的输出结果也大不相同。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main()&#123;    int a &#x3D; 10;int* aPtr &#x3D; &a;float b &#x3D; 10.0f;float* bPtr &#x3D; &b;std::cout &lt;&lt; *bPtr &lt;&lt; std::endl;&#x2F;&#x2F;输出结果为10.0    bPtr &#x3D; reinterpret_cast&lt;float*&gt;(aPtr);    &#x2F;&#x2F;两个指针指向同一块内存，但是对内存的解释不同，输出结果也不同std::cout &lt;&lt; *bPtr &lt;&lt; std::endl;&#x2F;&#x2F;输出结果为1.4013e-44    std::cout &lt;&lt; *aPtr &lt;&lt; std::endl;&#x2F;&#x2F;输出结果为10&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250928204356691.png" alt="image-20250928204356691"></p><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h2><p>​模板是现代 C++ 的一项强大特性，初衷是为了实现泛型编程。可以编写一次代码，然后使用不同的数据类型，不用为每种类型编写单独的函数或类。现代C++中功能强大的STL就是基于模板实现的，同时模板也是实现静态多态的方法之一。C++中的模板主要分为<strong>类模板</strong>和<strong>函数模板</strong>，这两种类型的模板都很容易理解，运行时编程差异不算大，后面再各自详细介绍一下。</p><p>​如果没有模板的话，我们怎么才能实现一个函数适配各种类型的数据呢？可以使用宏定义来实现。但是正如Effective C++所说的那样，我们应该尽量避免使用宏。宏本质上就是预处理时进行字符串替换，没有类型检查，调试时也不会进入到宏内部，这显然是不行的。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define ADD(T) T add(T a, T b)\&#123;\return a + b;\&#125;ADD(int);ADD(float);int main()&#123;add(1, 2);add(1.0f, 2.0f);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​模板出现后，我们可以很方便的定义接收任意类型的类或函数。使用时需要在对应的函数或者类前面使用<code>template&lt;typename T&gt;</code>或<code>template&lt;class T&gt;</code>加上模板声明，然后在该类或者函数内就能使用<code>T</code>作为数据类型使用。并且参数的类型编译器可以自动推导，也可以在使用时使用<code>&lt;int&gt;</code>的语法显示指明类型。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;模板实现template&lt;typename T&gt;T addTemplate(T a, T b)&#123;return a + b;&#125;int main()&#123;    &#x2F;&#x2F;自动推导模板参数类型    addTemplate(1, 2);addTemplate(1.0f, 2.0f);&#x2F;&#x2F;addTemplate(1.0f, 2); 编译错误，我们这种写法就隐含了两个参数的类型必须相同        &#x2F;&#x2F;显示指明模板参数类型    addTemplate&lt;int&gt;(1, 2);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​模板只有在使用的时候编译器才会<strong>实例化</strong>对应版本的类或者函数，所以模板的实例化是编译期实现的，不会带来运行时的性能损耗。以下面的代码为例，对应<code>add</code>模板函数，我们使用了<code>int, float和double</code>类型的版本，所以编译器只会为我们生成这三个类型的函数版本，参考<strong>C++ Insights得到</strong>的结果如下。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;typename T&gt;T add(T a, T b)&#123; return a + b; &#125;int main()&#123;  add(1, 2);    add(1.0f, 2.0f);  add(1.0, 2.0);&#125;&#x2F;&#x2F;C++ Insights得到的中间代码template&lt;typename T&gt;T add(T a, T b)&#123;  return a + b;&#125;template&lt;&gt;int add&lt;int&gt;(int a, int b)&#123;  return a + b;&#125;template&lt;&gt;float add&lt;float&gt;(float a, float b)&#123;  return a + b;&#125;template&lt;&gt;double add&lt;double&gt;(double a, double b)&#123;  return a + b;&#125;int main()&#123;  add(1, 2);  add(1.0F, 2.0F);  add(1.0, 2.0);  return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="全特化和偏特化"><a href="#全特化和偏特化" class="headerlink" title="全特化和偏特化"></a>全特化和偏特化</h2><p>​<strong>全特化</strong>：一个模板的所有模板参数都被具体化时，称为全特化。它为特定的一组参数提供了一个完全独立的实现。简单来说，全特化就是模板中的参数都是我们指定的，不存在需要编译器推导的模板参数。</p><p>​下面的例子中，我们提供了一个<code>T</code>为<code>double</code>类型时的全特化版本，当函数实参为<code>double</code>类型时，由于<strong>全特化版本优先级</strong> &gt; <strong>普通模板优先级</strong>，所以会优先调用全特化版本。由于全特化模板时，所有的模板参数都是我们明确指定的，模板声明时就不用声明任何模板参数，但是仍然需要使用<code>template&lt;&gt;</code>来声明这是一个模板函数。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;模板实现template&lt;typename T&gt;T addTemplate(T a, T b)&#123;std::cout &lt;&lt; &quot;normal&quot; &lt;&lt; std::endl;return a + b;&#125;&#x2F;&#x2F;全特化template&lt;&gt; &#x2F;&#x2F;虽然没有模板参数，但是仍需要该语句声明这个是一个模板函数double addTemplate(double a, double b)&#123;std::cout &lt;&lt; &quot;all&quot; &lt;&lt; std::endl;return a + b;&#125;int main()&#123;    addTemplate(1, 2); &#x2F;&#x2F;调用的普通模板函数addTemplate(1.0, 2.0); &#x2F;&#x2F;调用的针对double类型的全特化版本&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​<strong>偏特化</strong>：当一个类模板（注意：<strong>函数模板没有偏特化</strong>，只有重载）的<strong>某些模板参数被具体化</strong>，而<strong>另一些仍保持泛型时</strong>，称为偏特化。主要是为一类参数（不是单个具体参数）提供专门的实现。简单来说就是，仍然存在模板参数需要编译器推导，但是我们可以对这些模板参数进行一些限制或者修饰，为符合条件的一类提供实现。</p><p>​下面的例子中，偏特化中仍然存在模板参数<code>T</code>，但是函数的参数列表却变成了<code>T*</code>类型，这就是前面说的对模板参数进行一些限制，这表明这个偏特化版本会接收所有类型的指针。同样，由于<strong>偏特化优先级 &gt; 普通模板</strong>，会有限调用偏特化版本。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;模板实现template&lt;typename T&gt;T addTemplate(T a, T b)&#123;std::cout &lt;&lt; &quot;normal&quot; &lt;&lt; std::endl;return a + b;&#125;&#x2F;&#x2F;在模板类中叫做偏特化，但是模板函数没有偏特化，只有函数重载template&lt;typename T&gt;T addTemplate(T* a, T* b) &#x2F;&#x2F;形参列表为T*，表面这是专门接收各种类型的指针，当接收指针时就调用他&#123;std::cout &lt;&lt; &quot;special&quot; &lt;&lt; std::endl;return *a + *b;&#125;int main()&#123;    int a &#x3D; 2, b &#x3D; 3;addTemplate(a, b); &#x2F;&#x2F;调用的普通模板函数addTemplate(&amp;a, &amp;b); &#x2F;&#x2F;调用的针对所有指针类型的版本&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​这里说明一下，<strong>类模板和函数模板都有全特化</strong>，<strong>只有类模板有偏特化</strong>，模板函数实现偏特化的功能<strong>就是函数重载</strong>。并且主模板、偏特化和全特化的调用优先级如下：</p><p><strong>全特化 &gt; 偏特化 &gt; 主模板</strong></p><p>​可以理解为全特化因为指定了所有模板参数，是特化最强的版本，所以要优先调用。偏特化只是给模板参数添加了一些修饰和现在，是特化弱于全特化的版本，优先级中等。主模板则是最通用、最基础的模板版本，如果找不到特化版本就调用主模板的版本，属于是兜底的下下之策。</p><h2 id="模板参数"><a href="#模板参数" class="headerlink" title="模板参数"></a>模板参数</h2><p>​模板参数是模板进行编译时计算和类型操作的“变量”。分为三种主要类型：类型参数、非类型参数和模板的模板参数三类。</p><h3 id="类型参数"><a href="#类型参数" class="headerlink" title="类型参数"></a>类型参数</h3><p>​这是最常见的模板参数形式，以 <code>typename T</code> 或 <code>class T</code> 定义（模板声明时这两个关键字是等价的）；模板接受任意类型作为参数。模板参数T可以声明类模板的成员变量、函数模板中的函数参数和返回值等。同时也可以像函数形参那样给我们的模板类型参数指定默认类型。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;模板声明的时候typename和class一样，同时也可以给模板参数指定默认类型template&lt;typename T &#x3D; int, class U &#x3D; float&gt;class Test&#123;public:&#x2F;&#x2F;声明函数形参Test(T a, U b):m_A(a), m_B(b)&#123;&#125;Test()&#123;&#125;&#x2F;&#x2F;用作返回值T GetA() &#123; return m_A; &#125;U GetB() &#123; return m_B; &#125;private:&#x2F;&#x2F;声明成员变量T m_A;U m_B;&#125;;int main()&#123;&#x2F;&#x2F;显示指明类型Test&lt;int, float&gt; t1(1, 2.0f);&#x2F;&#x2F;自动推导类型Test t2(1, 2.0f);    &#x2F;&#x2F;没有传值，无法自动推导，使用默认类型Test&lt;&gt;t3();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="非类型参数"><a href="#非类型参数" class="headerlink" title="非类型参数"></a>非类型参数</h3><p>​非类型参数允许模板接受<strong>编译时常量</strong>作为参数，这些参数在<strong>编译时是已知</strong>的，所以可以直接参与编译时计算。经典的使用就是C++标准模板库里的<code>std::array&lt;type, size&gt;</code>，我们可以指定一个类型和一个参数指定数组的大小。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;typename T, int size&gt;class Array&#123;public:Array() &#x3D; default;T Get(uint32_t idx)&#123;if (idx &gt;&#x3D; size)throw std::out_of_range(&quot;索引越界&quot;);return m_Arr[idx];&#125;void Set(uint32_t idx, T val)&#123;if (idx &gt;&#x3D; size)return;m_Arr[idx] &#x3D; val;&#125;private:T m_Arr[size];&#125;;int main()&#123;    &#x2F;&#x2F;Array&lt;int, size&gt; arr1; 编译错误，传入的大小必须是编译器就能确定的常量    int size &#x3D; 5;    &#x2F;&#x2F;编译成功    const int n &#x3D; 5;    Array&lt;int, n&gt; arr1;     &#x2F;&#x2F;指定类型和大小    Array&lt;int, 3&gt; arr;    arr.Set(0, 1);    arr.Set(1, 2);    arr.Set(2, 3);    std::cout &lt;&lt; arr.Get(0) &lt;&lt; std::endl; &#x2F;&#x2F;正常访问    std::cout &lt;&lt; arr.Get(5) &lt;&lt; std::endl; &#x2F;&#x2F;触发索引越界异常&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="模板的模板参数"><a href="#模板的模板参数" class="headerlink" title="模板的模板参数"></a>模板的模板参数</h3><p>​这种参数类型允许一个模板<strong>接受另一个模板作为参数</strong>。这在需要操作或生成其他模板时非常有用，提供了更高层次的抽象和泛化能力。普通的模板参数是一个类型或者值，模板的模板模板参数则是一个<strong>是一个未被实例化的模板类</strong>，而非普通类型或值。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;typename T, int size&gt;class Array&#123;public:Array() &#x3D; default;T Get(uint32_t idx)&#123;if (idx &gt;&#x3D; size)throw std::out_of_range(&quot;索引越界&quot;);return m_Arr[idx];&#125;void Set(uint32_t idx, T val)&#123;if (idx &gt;&#x3D; size)return;m_Arr[idx] &#x3D; val;&#125;private:T m_Arr[size];&#125;;template&lt;typename T, int size&gt;class OtherArray&#123;&#125;;&#x2F;&#x2F;template&lt;typename T,int size, Array&lt;T, size&gt; arr&gt; 这种声明是错误的，听完模板的模板参数可以接收任何符合要求的类模板&#x2F;&#x2F;模板的模板参数的的写法就是声明一个模板类的标准写法，他会接收所以符合该模板参数要求的类模板template&lt;typename T,int size, template&lt;typename, int&gt; class ContainerTemplate &gt;class ArrayContainer&#123;private:ContainerTemplate&lt;T, size&gt; data;&#125;;int main()&#123;    &#x2F;&#x2F;ArrayContainer&lt;int, 5, Test&gt; arrayContainer; 编译错误，因为Test和我们指定的ContainerTemplate不兼容    ArrayContainer&lt;int, 5, Array&gt; arrayContainer;    &#x2F;&#x2F;不止Array能使用，只要模板参数和ContainerTemplate兼容的类模板都可以当作参数传进去    ArrayContainer&lt;int, 5, OtherArray&gt; otherArrayContainer;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h2><p>​前面介绍的模板其模板参数都是固定数量的，也就是我们在<code>&lt;&gt;</code>指定了几个，使用时就需要写上几个。而可变参数模板中的模板参数是不固定的，需要使用特定的语法接收和展开。</p><h2 id="模板中的类型推导"><a href="#模板中的类型推导" class="headerlink" title="模板中的类型推导"></a>模板中的类型推导</h2><h2 id="SFINAE"><a href="#SFINAE" class="headerlink" title="SFINAE"></a>SFINAE</h2><p>​<strong>SFINAE</strong> 的全称是 “<strong>Substitution Failure Is Not An Error</strong>”，直译过来是“<strong>替换失败不是一个错误</strong>”。</p><h2 id="模板元编程（Template-meta-programming，TMP）"><a href="#模板元编程（Template-meta-programming，TMP）" class="headerlink" title="模板元编程（Template meta programming，TMP）"></a>模板元编程（Template meta programming，TMP）</h2>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/11/22/hello-world/"/>
      <url>/2025/11/22/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 测试 </tag>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
