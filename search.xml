<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2025/11/22/C++/"/>
      <url>/2025/11/22/C++/</url>
      
        <content type="html"><![CDATA[<h1 id="C-三-五-零法则"><a href="#C-三-五-零法则" class="headerlink" title="C++三&#x2F;五&#x2F;零法则"></a>C++三&#x2F;五&#x2F;零法则</h1><h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><table><thead><tr><th>特性&#x2F;容器</th><th>set</th><th>map</th><th>unordered_set</th><th>unordered_map</th><th>vector</th></tr></thead><tbody><tr><td>底层数据结构</td><td>红黑树</td><td>红黑树</td><td>哈希表</td><td>哈希表</td><td>动态数组</td></tr><tr><td>元素顺序</td><td>有序</td><td>有序</td><td>无序</td><td>无序</td><td>插入顺序</td></tr><tr><td>查找效率</td><td>O(log n)</td><td>O(log n)</td><td>平均 O(1)，最坏 O(n)</td><td>平均 O(1)，最坏 O(n)</td><td>O(n)</td></tr><tr><td>插入效率</td><td>O(log n)</td><td>O(log n)</td><td>平均 O(1)，最坏 O(n)</td><td>平均 O(1)，最坏 O(n)</td><td>平均 O(1)，最坏 O(n)</td></tr><tr><td>元素唯一性</td><td>是</td><td>键是，值否</td><td>是</td><td>键是，值否</td><td>否</td></tr><tr><td>元素类型</td><td>单一值</td><td>键值对</td><td>单一值</td><td>键值对</td><td>单一值</td></tr><tr><td>支持随机访问</td><td>否</td><td>否</td><td>否</td><td>否</td><td>是</td></tr></tbody></table><h2 id="set系列"><a href="#set系列" class="headerlink" title="set系列"></a>set系列</h2><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>​<code>set</code>是<code>c++</code>标准模板库中的一部分，可以存储<strong>唯一</strong>的元素（即set中的元素不允许重复，都是唯一的）,而这些元素按照<strong>某种顺序排列</strong>（顺序可以自定义，默认是从小到大排列）。<code>set</code>的底层是使用红黑树实现的，所以即使在大量数据面前，操作（如插入、删除、查找）的效率也非常高，时间复杂度保持在 <code>O(log n)</code>。</p><p>​<code>set</code>的应用场景非常广泛，从<strong>数据去重</strong>，到<strong>构建有序元素集</strong>，再到支持<strong>快速查找</strong>操作，<code>set</code> 在很多方面都展示了其独特的价值。当我们想让数据唯一且有序的时候，<code>set</code>是一个很好的选择。</p><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p>​前面已经说过，set的底层是使用红黑树实现的，</p><h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h3 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h3><h2 id="map系列"><a href="#map系列" class="headerlink" title="map系列"></a>map系列</h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><h3 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h3><h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><h2 id="using"><a href="#using" class="headerlink" title="using"></a>using</h2><h2 id="override和final"><a href="#override和final" class="headerlink" title="override和final"></a>override和final</h2><h3 id="重写-override-、重载-overload-和隐藏-overwrite"><a href="#重写-override-、重载-overload-和隐藏-overwrite" class="headerlink" title="重写(override)、重载(overload)和隐藏(overwrite)"></a>重写(override)、重载(overload)和隐藏(overwrite)</h3><p>​首先来区分一下这三个概念，平时如果不注意的话会容易把他们混淆：</p><p>1．重写（override）的意思更接近<strong>覆盖</strong>，而且<strong>只会出现在继承关系</strong>中。在C++中是指<strong>派生类覆盖</strong>了<strong>基类的虚函数</strong>，这里的覆盖必须满足有<strong>相同的函数签名</strong>和<strong>返回类型</strong>，也就是说有<strong>相同的函数名、形参列表以及返回类型</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base\n&quot;</span>; &#125; <span class="comment">// 虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base\n&quot;</span>; &#125; <span class="comment">// 虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//函数名，参数类型，返回值都必须一样才会重写基类的函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived\n&quot;</span>; &#125; <span class="comment">// 重写基类虚函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">double</span> b)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived\n&quot;</span>; &#125; <span class="comment">//没有重写，相当于子类自己增加的函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* obj = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    obj-&gt;<span class="built_in">Show</span>(); <span class="comment">// 输出 &quot;Derived&quot;（动态绑定）</span></span><br><span class="line">    obj-&gt;<span class="built_in">Print</span>(<span class="number">1.0</span>); <span class="comment">// 输出 &quot;Base&quot;，因为子类的为Print(double)和基类的Print(int)，参数列表不同，不是重写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2．重载（overload）指在<strong>同一个作用域</strong>内，定义多个<strong>同名函数</strong>，但它们的<strong>参数列表不同</strong>（参数类型、数量或顺序不同），即它们的<strong>函数名相同</strong>，但是<strong>函数签名不同</strong>。这种情况在类的构造函数中最容易看到，为了让类更方便使用，我们经常会重载多个构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//这都是函数重载</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line">  <span class="comment">//int  Print(int a); //不允许一个作用域出现函数名和参数列表一样，仅仅返回类型不一样的函数，这样会引起二义性导致编译器不知道调用哪一个函数而报错。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span>  <span class="title">Print</span><span class="params">(<span class="type">int</span> a, <span class="type">double</span> b)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>3．隐藏（overwrite）的概念也十分容易与上面的概念混淆，隐藏也是<strong>发生在继承关系</strong>中。简单来说就是当派生类定义了与基类<strong>同名但不符合重写(override)条件</strong>的函数时，基类的所有同名函数会被<strong>隐藏</strong>（即使参数列表不同）。</p><p>​隐藏是指基类成员函数，无论它是否为虚函数，当派生类出现同名函数时，如果派生类函数签名不同于基类函数，则基类函数会被隐藏。如果派生类函数签名与基类函数相同，则需要确定基类函数是否为虚函数，如果是虚函数，则这里的概念就是重写；否则基类函数也会被隐藏。另外，如果还想使用基类函数，可以使用using关键字将其引入派生类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Print Base1\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Print Base1\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Hello</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello Base1\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive1</span> : <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Print Derive1\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Hello</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello Derive1\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* obj = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    obj-&gt;<span class="built_in">Show</span>(); <span class="comment">// 输出 &quot;Derived&quot;（动态绑定）</span></span><br><span class="line">    obj-&gt;<span class="built_in">Print</span>(<span class="number">1.0</span>); <span class="comment">// 输出 &quot;Base&quot;，因为子类的为Print(double)和基类的Print(int)，参数列表不同，不是重写</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Derive1 derive;</span><br><span class="line">  <span class="comment">//derive.Print(); 编译失败，因为子类中出现了同名但是不同参数列表的函数，基类的同名函数不能直接在子类中调用(所以叫隐藏)</span></span><br><span class="line">    derive.Base1::<span class="built_in">Print</span>();<span class="comment">//被隐藏的基类函数，只能通过加上基类作用域Base1::访问</span></span><br><span class="line">    derive.<span class="built_in">Print</span>(<span class="number">10</span>);<span class="comment">//把基类的Print函数隐藏了，只能直接调用子类实现的</span></span><br><span class="line">    derive.<span class="built_in">Show</span>(); <span class="comment">//子类没有实现同名函数，所以可以基类的函数不会被隐藏，子类可以直接调用</span></span><br><span class="line"></span><br><span class="line">    Base1* base = <span class="keyword">new</span> <span class="built_in">Derive1</span>();</span><br><span class="line">    base-&gt;<span class="built_in">Hello</span>(<span class="number">1</span>); <span class="comment">//会输出Hello Base1，虽然子类实现了同名，同参数列表，同返回值的函数，但是由于基类中不是虚函数，所以会隐藏而不是重写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center"></th><th align="center">重载(overload)</th><th align="center">重写 or 覆盖(override)</th><th align="center">隐藏(overwrite)</th></tr></thead><tbody><tr><td align="center">发生场景</td><td align="center">同一作用域下多个重名函数</td><td align="center">只发生在继承关系的虚函数中</td><td align="center">只发生在继承关系中</td></tr><tr><td align="center">条件</td><td align="center">多个<strong>重名</strong>函数<strong>参数列表不同</strong>(参数数量、类型或顺序不同)</td><td align="center">基类为<strong>虚函数</strong>且子类定义<strong>一模一样的函数</strong>(返回值、函数名和参数列表都相同)</td><td align="center">子类实现两种函数：<br />1. 与基类函数重名但参数列表不同<br />2. 与基类函数一模一样，但基类中不是虚函数(如果是虚函数就是重写了)</td></tr></tbody></table><h3 id="override说明符"><a href="#override说明符" class="headerlink" title="override说明符"></a>override说明符</h3><p>​<strong>C++11</strong>标准提供了一个非常实用的<code>override</code>说明符，这个说明符<strong>必须放到虚函数的尾部</strong>，它明确告诉编译器这个虚函数需要覆盖基类的虚函数，一旦编译器发现该虚函数不符合重写规则，就会给出错误提示。也就是让编译器检查使用<code>override</code>修饰的函数是否符合重写的要求，不满足就会编译时报错。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//编译失败，最底层的基类函数不能用override修饰</span></span><br><span class="line">    <span class="comment">//void Print(int a) override</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive2</span> : <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//编译失败，因为基类没有对应的虚函数</span></span><br><span class="line">    <span class="comment">//void Print(int a) override</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="final说明符"><a href="#final说明符" class="headerlink" title="final说明符"></a>final说明符</h3><p>​<strong>C++11</strong>标准引入<code>final</code>说明符，它告诉编译器<strong>该虚函数不能被派生类重写</strong>。<code>final</code>说明符用法和<code>override</code>说明符相同，需要声明在虚函数的尾部。除此之外，<code>final</code>还能用于<strong>修饰类</strong>，表明<strong>该类不能作为基类被继承</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="keyword">final</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive3</span> : <span class="keyword">public</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//编译失败，因为基类中final修饰的虚函数不能被继承</span></span><br><span class="line">    <span class="comment">//void Print() override</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base4</span> <span class="keyword">final</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译失败，final修饰的类不能被继承</span></span><br><span class="line"><span class="comment">//class Derive4 : public Base4</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br></pre></td></tr></table></figure><p>​另外，override和final没有作为像int，const，static那样保留的关键字，也就是说我们可以声明叫override或者final的变量或者类型，编译器不会报错。但是会容易出现错误和后期维护的难度，不建议使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//都是合法的</span></span><br><span class="line"><span class="type">int</span> <span class="keyword">override</span> = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="keyword">final</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">override</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">final</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><p>​<code>auto</code>关键字在C++98标准开始就已经存在了，当时auto是用来声明自动变量的，简单地说，就是拥有自动生命期的变量，显然这是多余的，现在我们几乎不会使用它。<strong>C++11</strong>标准赋予了<code>auto</code><strong>新的含义</strong>：声明变量时根据初始化表达式 自动推断该变量的类型、声明函数时函数返回值的占位符。</p><p>​<code>auto</code>占位符会让<strong>编译器去推导变量类型</strong>，如果我们编写的代码让编译器无法进行推导，那么使用auto会导致编译失败。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译失败，因为i并没有具体的值，所以auto无法推导i的类型</span></span><br><span class="line"><span class="keyword">auto</span> i;</span><br><span class="line">i = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>​根据上面的例子可以看出来，使用<code>auto</code>声明变量时必须要<strong>初始化变量</strong>，否则会编译失败。</p><h3 id="初始化推导规则"><a href="#初始化推导规则" class="headerlink" title="初始化推导规则"></a>初始化推导规则</h3><p>​<strong>1.<strong>如果<code>auto</code>声明的变量是</strong>按值初始化</strong>，则推导出的类型会<strong>忽略cv限定符</strong>。</p><p>​即在使用<code>auto</code>声明变量时，既<strong>没有使用引用</strong>，也<strong>没有使用指针</strong>，那么编译器在推导的时候会<strong>忽略const和volatile</strong>限定符。当然<code>auto</code>本身也可以使用<code>const</code>修饰。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//---------------------------------------------1.初始化仅使用值，auto会忽略cv限定符</span></span><br><span class="line"><span class="keyword">auto</span> tempA = a; <span class="comment">//auto推到为int，没有const</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> tempB = a; <span class="comment">//auto推到为int，但是auto前使用const修饰，最终为const int</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------------------2.初始化是指针或者引用，auto会带上cv限定符(如果原变量有的话)</span></span><br><span class="line"><span class="comment">//auto不能推导出引用，要显式加上引用符</span></span><br><span class="line"><span class="keyword">auto</span>&amp; tempC1 = a; <span class="comment">//声明为引用，会带上const修饰符，最终为const int&amp;</span></span><br><span class="line"><span class="keyword">auto</span>&amp; tempC2 = b; <span class="comment">//声明为引用，但是原变量没有const，所以最终为int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指针类型可以显示声明（auto后面加上*），也可以让auto自动推导</span></span><br><span class="line"><span class="keyword">auto</span>* tempP1 = &amp;a; <span class="comment">//auto推导为const int， 最终为const int*</span></span><br><span class="line"><span class="keyword">auto</span> tempP2 = &amp;a;  <span class="comment">//auto推导为const int*，最终为const int*</span></span><br><span class="line"><span class="keyword">auto</span> tempP3 = &amp;b; <span class="comment">//b没有const修饰，所以最终推导为int*</span></span><br></pre></td></tr></table></figure><p>​根据上面的例子可以总结出：如果<strong>按值初始化</strong>，<code>auto</code>会<strong>忽略原变量的cv限定符</strong>；如果按<strong>引用或者指针</strong>初始化，<code>auto</code>会<strong>带上原变量的cv限定符</strong>（原变量有auto推导出来的就有，反之亦然）。</p><p>​从安全性角度思考，如果变量用<code>const</code>修饰后，肯定不希望被修改。<strong>普通的按值初始化</strong>，就是简单的把值复制给另一个变量，当然可以对这个新变量进行修改，所以<code>auto</code>会忽略对按值初始化的变量的cv限定符。但是使用<strong>引用或者指针初始化</strong>，对这个新变量操作就可能会修改原来的常量，这显然的不安全的，所以<code>auto</code>会对按引用或者指针初始化的变量加上原有的cv限定符。</p><p>​**2. **使用<code>auto</code>声明变量初始化时，目标对象如果是引用，则引用属性会被忽略。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span>&amp; m = i; <span class="comment">//auto推导为int，整体为int&amp;是引用类型</span></span><br><span class="line"><span class="keyword">auto</span> n = m; <span class="comment">//auto会推导为int，而不是int&amp;</span></span><br></pre></td></tr></table></figure><p>​<strong>3.</strong> 使用<code>auto</code>和万能引用声明变量时，对于左值会将<code>auto</code>推导为引用类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; m = i; <span class="comment">//i为左值，auto推导为int&amp;，最终int&amp; &amp;&amp;引用折叠后为int&amp;</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; n = <span class="number">10</span>; <span class="comment">//10为右值，auto推导为int，最终int&amp;&amp;引用折叠后为int&amp;&amp;</span></span><br></pre></td></tr></table></figure><p>​<code>4.</code>使用<code>auto</code>声明变量，如果目标对象是一个数组或者函数，则<code>auto</code>会被推导为对应的指针类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a1 + a2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">auto</span> m = i; <span class="comment">// auto推导类型为int*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> j = sum; <span class="comment">// auto推导类型为int (__cdecl *)(int,int)</span></span><br></pre></td></tr></table></figure><h3 id="函数返回类型推导"><a href="#函数返回类型推导" class="headerlink" title="函数返回类型推导"></a>函数返回类型推导</h3><p>​<strong>C++14</strong>标准支持对返回类型声明为<code>auto</code>的推导。但是如果函数内部有<strong>多个返回值</strong>时（有多个<code>return</code>语句），这些<strong>返回值的类型要统一</strong>，否则会编译不通过。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据返回值推导为int</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a1 + a2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//会报错并提升推到类型int和float冲突，编译无法通过</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> a1 + a2;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1.0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lambda中使用auto推导"><a href="#lambda中使用auto推导" class="headerlink" title="lambda中使用auto推导"></a>lambda中使用auto推导</h3><p>​在<strong>C++14</strong>标准中我们还可以把<code>auto</code>写到<code>lambda</code>表达式的形参中，这样就得到了一个泛型的<code>lambda</code>表达式，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lambda表达式的返回值可以显示给出，也可编译器自己推导</span></span><br><span class="line"><span class="keyword">auto</span> square = [](<span class="type">int</span> x) -&gt; <span class="type">int</span> &#123; <span class="keyword">return</span> x * x; &#125;; <span class="comment">//显示指出</span></span><br><span class="line"><span class="keyword">auto</span> square = [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x * x; &#125;;  <span class="comment">// 自动推导</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//该lambda表达式可以接收任意类型的两个参数，并且能够自动推导返回值类型</span></span><br><span class="line"><span class="keyword">auto</span> l = [](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> x = <span class="built_in">l</span>(<span class="number">1</span>, <span class="number">2.0f</span>); <span class="comment">//传入的为int和float，最后返回类型推导为float</span></span><br><span class="line"><span class="keyword">auto</span> y = <span class="built_in">l</span>(<span class="number">1</span>, <span class="number">2</span>);    <span class="comment">//传入的为int和int，最后返回类型推导为int</span></span><br></pre></td></tr></table></figure><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><h2 id="noexpect"><a href="#noexpect" class="headerlink" title="noexpect"></a>noexpect</h2><h2 id="const-常量-、mutable-可变-和volatile-易变"><a href="#const-常量-、mutable-可变-和volatile-易变" class="headerlink" title="const(常量)、mutable(可变)和volatile(易变)"></a>const(常量)、mutable(可变)和volatile(易变)</h2><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>​<code>const</code> 是 <code>constant</code> 的缩写，本意是不变的，不易改变的意思。在 C++ 中是用来修饰内置类型变量，自定义对象，成员函数，返回值，函数参数。</p><p>​C++ <code>const</code> 允许指定一个语义约束，允许程序员<strong>告诉编译器某值是保持不变的</strong>。如果在编程中确实有某个值保持不变，就应该明确使用<code>const</code>，这样可以获得编译器的帮助。</p><h4 id="const修饰普通变量"><a href="#const修饰普通变量" class="headerlink" title="const修饰普通变量"></a>const修饰普通变量</h4><p>​当const修饰普通变量时，这个变量就会被编译器当作常量，且必须在定义时就给与初始化的值。而且修改一个常量的值是违法操作，编译器不允许常量的值被修改。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//const int t; //不允许，const修饰的变量必须给予初始值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰的变量被编译器视作常量，不允许直接修改</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//a = 1; //const修饰的变量的值不允许被修改</span></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> b = <span class="number">5.0f</span>;</span><br><span class="line"><span class="comment">//b = 1.0f;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//虽然使用指针取地址的方式可以骗过编译器直接修改内存，但是编译器仍然认为变量a的值为原始值，不会被改变</span></span><br><span class="line"><span class="type">int</span>* p = (<span class="type">int</span>*) &amp; a;</span><br><span class="line">*p = <span class="number">99</span>;</span><br><span class="line">std::cout &lt;&lt; *p &lt;&lt; std::endl; <span class="comment">//输出99</span></span><br><span class="line">std::cout &lt;&lt; a &lt;&lt; std::endl;  <span class="comment">//输出10</span></span><br></pre></td></tr></table></figure><p>​对于 <code>const</code>修饰的变量 <code>a</code>，我们取变量的地址并转换赋值给指向 <code>int</code> 的指针，然后利用 <code>*p = 99</code>; 重新对变量 <code>a</code> 地址内的值赋值。虽然地址内的值确实被修改为了<code>99</code>，但是直接输出a的值却仍然是<code>10</code>。</p><p>​虽然我们可以通过指针的实现绕过编译器的限制直接修改内存中的值，但是这<strong>会产生意想不到的后果</strong>，所以<strong>千万不要轻易修改</strong><code>const</code>修饰的变量的值。</p><h4 id="const修饰指针"><a href="#const修饰指针" class="headerlink" title="const修饰指针"></a>const修饰指针</h4><p>​const修饰指针有三种情况：</p><ul><li>const 修饰指针指向的内容，则内容为不可变量，即<strong>不允许修改指针所指向内存的内容</strong>。写法为<code>const int* p</code>。</li><li>const 修饰指针，则指针为不可变量，即<strong>不允许修改指针本身存储的内存地址</strong>。写法为<code>int* const p</code>。</li><li>const 修饰指针和指针指向的内容，则指针和指针指向的内容都为不可变量，即<strong>指针存储的内存地址和该内存地址所在内存的值都不允许修改</strong>。写法为<code>const int* const p</code>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a2 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* cpa2 = &amp;a2;</span><br><span class="line"><span class="comment">//*cpa2 = 12; //不允许修改所指向内存的值</span></span><br><span class="line">cpa2 = &amp;b2;   <span class="comment">//可以修改指针所存储的内存地址</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> pca2 = &amp;a2;</span><br><span class="line">*pca2 = <span class="number">12</span>;   <span class="comment">//可以修改所指向内存的值</span></span><br><span class="line"><span class="comment">//pca2 = &amp;b2; //不允许修改指针所存储的内存地址</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> cpca2 = &amp;a2;</span><br><span class="line"><span class="comment">//*cpca2 = 12;  //不允许修改所指向内存的值</span></span><br><span class="line"><span class="comment">//cpca2 = &amp;b2; //不允许修改指针所存储的内存地址</span></span><br></pre></td></tr></table></figure><h4 id="const与函数"><a href="#const与函数" class="headerlink" title="const与函数"></a>const与函数</h4><p>​<code>const</code>与函数搭配时共有三种情况：</p><ul><li><code>const</code>修饰<strong>函数形参</strong></li><li><code>const</code>修饰<strong>函数返回值</strong></li><li><code>const</code>修饰<strong>类成员函数</strong></li></ul><p>​当函数参数使用const修饰后，函数内部就不能修改该参数的值了。对于基本数据类型(<code>int</code>、<code>float</code>等)不需要使用<code>const</code>修饰，但<strong>对于自定义类型或者类的对象</strong>来说，<strong>常常需要传递其指针或者引用</strong>，为了<strong>防止函数内部修改值</strong>，往往需要用<code>const</code>修饰。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">//a++; //禁止修改，因为a是const类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//(*p)++; //因此指针为const int*，所以不能修改内存值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> temp;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> MyStruct&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//p.temp = 10; //传来的引用也为const，禁止修改内部的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="const修饰函数返回值"><a href="#const修饰函数返回值" class="headerlink" title="const修饰函数返回值"></a>const修饰函数返回值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>​const也可修饰类的成员函数，当成员函数使用<code>const</code>修饰后，那么<strong>函数体内就不能修改类的成员变量</strong>。而且<code>const</code>修饰的类的实例对象只能调用<code>const</code>修饰的成员函数，这是为了保证const修饰的对象不能改变内部成员变量的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MyClass</span>(<span class="type">int</span> a, <span class="type">float</span> b)</span><br><span class="line">:<span class="built_in">m_A</span>(a), <span class="built_in">m_B</span>(b)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetA</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//m_A = 10; //const修饰的成员函数不允许修改成员变量的值</span></span><br><span class="line"><span class="keyword">return</span> m_A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetA</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_A = a; <span class="comment">//没有const修饰的成员函数可以自由修改成员变量的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">GetB</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//m_B = 5.0f; //const修饰的成员函数不允许修改成员变量的值</span></span><br><span class="line"><span class="keyword">return</span> m_B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Print&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintConst</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;PrintConst&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="type">float</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//普通的实例对象任何成员函数都可以调用</span></span><br><span class="line">    <span class="function">MyClass <span class="title">mc1</span><span class="params">(<span class="number">1</span>, <span class="number">1.0f</span>)</span></span>;</span><br><span class="line">mc<span class="number">1.</span><span class="built_in">Print</span>();</span><br><span class="line">mc<span class="number">1.</span><span class="built_in">PrintConst</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//const修饰的实例对象只能调用const修饰的成员函数</span></span><br><span class="line"><span class="function"><span class="type">const</span> MyClass <span class="title">mc2</span><span class="params">(<span class="number">2</span>, <span class="number">2.0f</span>)</span></span>;</span><br><span class="line"><span class="comment">//mc2.Print(); //const修饰的实例对象只能调用const修饰的成员函数</span></span><br><span class="line">mc<span class="number">2.</span><span class="built_in">PrintConst</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="底层const和顶层const"><a href="#底层const和顶层const" class="headerlink" title="底层const和顶层const"></a>底层const和顶层const</h4><table><thead><tr><th align="left">特性</th><th align="left">顶层 <code>const</code></th><th align="left">底层 <code>const</code></th></tr></thead><tbody><tr><td align="left"><strong>核心含义</strong></td><td align="left">对象<strong>本身</strong>存储的值是常量，不可修改。</td><td align="left"><strong>指针或引用</strong>所指向&#x2F;绑定的<strong>对象</strong>是常量，不可通过该指针&#x2F;引用修改。</td></tr><tr><td align="left"><strong>作用对象</strong></td><td align="left">任意类型（内置类型、类、指针等）。</td><td align="left">主要与指针和引用相关。</td></tr><tr><td align="left"><strong>典型示例</strong></td><td align="left"><code>const int a = 10;</code> <code>int *const p = &amp;x;</code>（常量指针）</td><td align="left"><code>const int *p = &amp;a;</code>（指向常量的指针） <code>const int &amp;r = a;</code>（常量引用）</td></tr><tr><td align="left"><strong>拷贝操作影响</strong></td><td align="left"><strong>可忽略</strong>。一个拥有顶层<code>const</code>的对象可以被拷贝给非<code>const</code>对象。（这个变量本身存储的值不可以被改变，但是可以把值赋值给其他变量）</td><td align="left"><strong>不可忽略</strong>。进行拷贝时，双方必须具有相同的底层<code>const</code>资格，或者能将非常量转换为常量。（因为要保证不能通过指针或引用改变指向内容的值，所以拷贝的对象也不能通过指针或引用的方式修改值）</td></tr></tbody></table><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><h2 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h2><h2 id="implicit和explicit"><a href="#implicit和explicit" class="headerlink" title="implicit和explicit"></a>implicit和explicit</h2><p>​在C++中，<code>explicit</code>和<code>implicit</code>关键字控制着类型转换的行为方式。可用于修饰<strong>构造函数</strong>和<strong>类型转换函数</strong>。</p><h3 id="implicit"><a href="#implicit" class="headerlink" title="implicit"></a>implicit</h3><p>​当用户<strong>未标记为explicit</strong>时，<strong>默认为implicit</strong>，编译器会自动执行类型转换。在创建对象时，如果构造函数未标记<code>explicit</code>，那么编译器会自动根据函数参数隐式调用对应的构造函数创建对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyInt</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">MyInt</span><span class="params">(<span class="type">int</span> data, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Create\n&quot;</span>);</span><br><span class="line">m_Data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">MyInt</span><span class="params">(<span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Create\n&quot;</span>);</span><br><span class="line">m_Data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">MyInt</span>(MyInt&amp; data)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Copy\n&quot;</span>);</span><br><span class="line">m_Data = data.m_Data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyInt&amp; <span class="keyword">operator</span>+(<span class="type">const</span> MyInt&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">m_Data += other.m_Data;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当需要将MyInt转换为int时会自动调用该函数实现隐式转换(默认为implicit)</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_Data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_Data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//编译器会隐式调用构造函数MyInt a(1, 2);</span></span><br><span class="line">MyInt a = &#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">    <span class="comment">//编译器会隐式调用构造函数MyInt a(10);</span></span><br><span class="line">MyInt b = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//编译器会把10隐式转换为MyInt</span></span><br><span class="line">    MyInt c = a + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//隐式调用operator int</span></span><br><span class="line">    <span class="type">int</span> temp = b;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h3><p>​当构造函数或者类型转换函数使用<code>explicit</code>关键字修饰后，不允许编译器隐式进行类型转换，必须显示调用才可以。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyInt</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">MyInt</span><span class="params">(<span class="type">int</span> data, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Create\n&quot;</span>);</span><br><span class="line">m_Data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">MyInt</span><span class="params">(<span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Create\n&quot;</span>);</span><br><span class="line">m_Data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">MyInt</span>(MyInt&amp; data)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Copy\n&quot;</span>);</span><br><span class="line">m_Data = data.m_Data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyInt&amp; <span class="keyword">operator</span>+(<span class="type">const</span> MyInt&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">m_Data += other.m_Data;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//必须显示转换才可以，不允许隐式转换为int</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_Data;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_Data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//标记为显示转换后，不允许编译器自动转换，只能手动显示转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//MyInt a = &#123; 1, 2 &#125;;</span></span><br><span class="line">    <span class="function">MyInt <span class="title">a</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//MyInt b = 10;</span></span><br><span class="line">    <span class="function">MyInt <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//MyInt c = a + 10;</span></span><br><span class="line">    MyInt c = a + <span class="built_in">MyInt</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类型转换函数用explicit修饰后必须显示转换，不允许编译器隐式转换</span></span><br><span class="line">    <span class="comment">//int temp = b;</span></span><br><span class="line">    <span class="type">int</span> temp = <span class="built_in">int</span>(b);</span><br><span class="line">    <span class="type">int</span> temp = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类的内存布局"><a href="#类的内存布局" class="headerlink" title="类的内存布局"></a>类的内存布局</h1><h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><p>​首先来看一个例子，<code>Data</code>结构体中有<code>int</code>类型和<code>char</code>类型两个成员变量，其中<code>int</code>类型大小为<strong>4</strong>字节，<code>char</code>类型大小为<strong>1</strong>字节，但是输出的结果却显示<code>Data</code>类型的大小是<strong>8</strong>个字节，显然并不是我们直觉上认为的4 + 1 &#x3D; 5字节，出现这种情况的原因就是<strong>内存对齐</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(X) std::cout &lt;&lt; X &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">LOG</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)); <span class="comment">//4字节</span></span><br><span class="line"><span class="built_in">LOG</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>)); <span class="comment">//1字节</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">LOG</span>(<span class="built_in">sizeof</span>(Data)); <span class="comment">//8字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​虽然计算机内存是按照字节划分的，理论上任何一个内存地址都可以存储数据。但是实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是某个数k的倍数（通常为2、4、8等2的幂次方），这就是所谓的内存对齐。</p><p>​尽管内存按照字节划分，但是CPU并不是按照字节取内存的，现代CPU通常以字长（如4字节或8字节）为块来访问内存。假设CPU一次可以访问4字节内存，如果没有内存对齐的话，一个int类型的数据随意存放，那么访问这个数据就可能需要两次访问，并且两次访问还需要分别取出该数据对应的部分再拼一起，这显然会降低运行效率。如果内存对齐后，int类型的数据都存放在地址为4的整数倍的地方，那么CPU只需要一次就能拿到完整的数据。</p><p>​下面介绍一下对齐规则：</p><ol><li>基本数据类型的对齐值就是sizeof求出来的值，也即自身大小。</li><li>结构体内每个成员的起始地址（偏移量）必须是其类型对齐值的整数倍。为了满足这个要求，编译器会在成员之间自动插入填充字节。</li></ol><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> ch; <span class="comment">// 1字节，偏移量为0</span></span><br><span class="line"><span class="comment">//会在char后面补充3字节的padding，让int类型的偏移量为4的整数倍</span></span><br><span class="line"><span class="type">int</span> val; <span class="comment">// 4字节，偏移量为4</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//所以对齐后Data类型的大小为8字节，其中char类型后面有3个字节的填充，后面就是int的四个字节</span></span><br></pre></td></tr></table></figure><ol start="3"><li>结构体的对齐值是其成员的最大对齐值，也就是说结构体变量的起始地址要是其对齐值的整数倍。</li><li>结构体的总大小必须是其内部最宽成员大小的整数倍。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Data2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> val; <span class="comment">//4字节</span></span><br><span class="line"><span class="type">char</span> ch1; <span class="comment">//1字节</span></span><br><span class="line"><span class="type">char</span> ch2; <span class="comment">//1字节</span></span><br><span class="line"><span class="comment">//结构体内部最大成员为4字节的int，所以结构体大小要为4的倍数，目前为6字节</span></span><br><span class="line"><span class="comment">//尾部填充两个字节</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Data3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> ch; <span class="comment">//1字节</span></span><br><span class="line"><span class="type">char</span> ch1; <span class="comment">//1字节</span></span><br><span class="line"><span class="type">char</span> ch2; <span class="comment">//1字节</span></span><br><span class="line"><span class="comment">//结构体内部最大成员为1字节的char，所以结构体大小要为1的倍数，不用填充</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sizeof</span>(Data2); <span class="comment">//8字节</span></span><br><span class="line"><span class="built_in">sizeof</span>(Data3); <span class="comment">//3字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​前面的介绍是简化版本的，下面详细说明一下：</p><p>​每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数），可以通过预编译命令<code>#pragma pack(n)</code>，n &#x3D; 1,2,4,8,16来改变这一系数。</p><p>​每个类型的对齐值都会和这个对齐系数比较，较小的哪个就是有效对齐值；对于结构体来说，有效对齐值就是结构体中最长成员的长度和对齐系数的最小值。</p><p>​当我们使用<code>#pragma pack(n)</code>后，上面的几条规则都要在这个对齐系数的约束下求出有效对齐值之后再进行对齐。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1) <span class="comment">//因为是取最小值，所以有效对齐值总是会为1</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> ch; <span class="comment">// 1字节，偏移量为0</span></span><br><span class="line"><span class="comment">//有效对齐值 = min(1, 4) == 1，所以val的有效对齐值为1，可以随便放，不会再char后面填充</span></span><br><span class="line"><span class="type">int</span> val; <span class="comment">// 4字节，偏移量为1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">sizeof</span>(Data); <span class="comment">//此时Data大小为5字节</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(2)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> ch; <span class="comment">// 1字节，偏移量为0</span></span><br><span class="line"><span class="comment">//有效对齐值 = min(2, 4) == 2，所以val的有效对齐值为2，偏移量必须为2的整数倍，所以要在char后面填充一个字节</span></span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> val; <span class="comment">// 4字节，偏移量为2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">sizeof</span>(Data); <span class="comment">//此时Data大小为6字节</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(2)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Data4</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> val; <span class="comment">//4字节</span></span><br><span class="line"><span class="type">char</span> ch1; <span class="comment">//1字节</span></span><br><span class="line">    <span class="comment">//有效对齐值 = min(2, 4) == 2，所以Data4的大小要为2的整数倍，所以char后面填充一个字节变为6</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">sizeof</span>(Data4) <span class="comment">//此时Data4是6字节</span></span><br></pre></td></tr></table></figure><p>​一般情况下使用默认的对齐系数即可，无需特别设置<code>#pragram pack(n)</code>。</p><h2 id="RTTI"><a href="#RTTI" class="headerlink" title="RTTI"></a>RTTI</h2><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>​<code>C++</code>的多态有<strong>静态多态</strong>和<strong>动态多态</strong>。静态多态通过<strong>函数重载</strong>和<strong>模板</strong>实现；动态多态通过<strong>虚函数</strong>实现，下面所介绍的多态都是动态多态。下面举个例子说明一些多态的使用（<strong>基类的指针或引用指向子类对象</strong>）。</p><p>​先来看下面的一个案例，三个类都可以执行<code>Say()</code>函数，如果我想让每个类说的内容不一样，就必须在子类中也实现<code>Say()</code>函数才可以，并且只能用符合各自类型的对象、指针或引用才能调用正确的函数。<code>C++</code>中使用<code>virtual</code>关键字声明一个成员函数为虚函数，并且<strong>只能修饰普通的成员函数</strong>，<strong>静态成员函数和友元函数都不能声明为虚函数</strong>。当基类中声明一个虚函数之后，子类可以重写这个虚函数，此时使用<strong>基类的指针或引用指向子类对象</strong>，调用该虚函数时，会自动根据上下文信息找到正确类型的虚函数调用，也就是说一个函数接口在运行时可以有不同的功能。</p><p>​从下面的例子也能看出，只能用<strong>基类的指针</strong>或<strong>引用</strong>指向子类对象，如果直接用一个基类对象接收子类对象，会发生类型阶段，就完全变成了基类对象了。</p><p>​有了多态之后能方便我们实现各种功能，比如下面的<code>Print(Base*)</code>函数，函数只需要接收基类指针类型的形参，而调用该函数时可以传递基类或者子类的指针，并且函数内调用虚函数也会找到各自的实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Base</span>()</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot; Base删除&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用virtual关键字声明为虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Say</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;我是Base&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive1</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Derive1</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Derive1</span>()</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot; Derive1删除&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Say</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;我是Derive1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive2</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Derive2</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Derive2</span>()</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot; Derive2删除&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Say</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;我是Derive2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(Base* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">b-&gt;<span class="built_in">Say</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Say不是虚函数时</span></span><br><span class="line">&#123;</span><br><span class="line">Base* b = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">b-&gt;<span class="built_in">Say</span>(); <span class="comment">//调用Base的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Base* b1 = <span class="keyword">new</span> <span class="built_in">Derive1</span>();</span><br><span class="line">b1-&gt;<span class="built_in">Say</span>(); <span class="comment">//调用Base的</span></span><br><span class="line">Derive1 d1;</span><br><span class="line">Base&amp; b11 = d1;</span><br><span class="line">b<span class="number">11.</span><span class="built_in">Say</span>(); <span class="comment">//调用Base的</span></span><br><span class="line"></span><br><span class="line">Base* b2 = <span class="keyword">new</span> <span class="built_in">Derive2</span>();</span><br><span class="line">b2-&gt;<span class="built_in">Say</span>(); <span class="comment">//调用Base的</span></span><br><span class="line">Derive2 d2;</span><br><span class="line">Base&amp; b22 = d2;</span><br><span class="line">b<span class="number">22.</span><span class="built_in">Say</span>(); <span class="comment">//调用Base的</span></span><br><span class="line"></span><br><span class="line">Base b3 = d1;</span><br><span class="line">b<span class="number">22.</span><span class="built_in">Say</span>(); <span class="comment">//调用Base的</span></span><br><span class="line">Base b4 = d2;</span><br><span class="line">b<span class="number">4.</span><span class="built_in">Say</span>();  <span class="comment">//调用Base的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> b, b1, b2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Say是虚函数时（多态）</span></span><br><span class="line">&#123;</span><br><span class="line">Base* b = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">b-&gt;<span class="built_in">Say</span>(); <span class="comment">//指向Base对象，调用Base的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Base* b1 = <span class="keyword">new</span> <span class="built_in">Derive1</span>();</span><br><span class="line">b1-&gt;<span class="built_in">Say</span>(); <span class="comment">//指向Derive1对象，调用Derive1的</span></span><br><span class="line">Derive1 d1;</span><br><span class="line">Base&amp; b11 = d1;</span><br><span class="line">b<span class="number">11.</span><span class="built_in">Say</span>(); <span class="comment">//Derive1对象引用，调用Derive1的</span></span><br><span class="line"></span><br><span class="line">Base* b2 = <span class="keyword">new</span> <span class="built_in">Derive2</span>();</span><br><span class="line">b2-&gt;<span class="built_in">Say</span>(); <span class="comment">//指向Derive2对象，调用Derive2的</span></span><br><span class="line">Derive2 d2;</span><br><span class="line">Base&amp; b22 = d2;</span><br><span class="line">b<span class="number">22.</span><span class="built_in">Say</span>(); <span class="comment">//Derive2对象的引用，调用Derive2的</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">Base b3 = d1;</span><br><span class="line">b<span class="number">3.</span><span class="built_in">Say</span>(); <span class="comment">//类型截断，调用Base的</span></span><br><span class="line">Base b4 = d2;</span><br><span class="line">b<span class="number">4.</span><span class="built_in">Say</span>(); <span class="comment">//类型截断，调用Base的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> b, b1, b2;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//多态的方式实现函数参数传递</span></span><br><span class="line">&#123;</span><br><span class="line">Base* b = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line"><span class="built_in">Print</span>(b); <span class="comment">//调用Base的</span></span><br><span class="line">Base* b1 = <span class="keyword">new</span> <span class="built_in">Derive1</span>();</span><br><span class="line"><span class="built_in">Print</span>(b1); <span class="comment">//调用Derive1的</span></span><br><span class="line">Base* b2 = <span class="keyword">new</span> <span class="built_in">Derive2</span>();</span><br><span class="line"><span class="built_in">Print</span>(b2); <span class="comment">//调用Derive2的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> b, b1, b2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>​前面已经说过了，多态是利用虚函数来实现的，而虚函数的实现原理就是<strong>虚函数表(vtable)<strong>和</strong>虚函数表指针(vptr)</strong>。</p><p>​<strong>虚函数表（vtable）</strong>：是一个存放该类中所有虚函数地址的数组，每个有虚函数(或继承了有虚函数的基类)的类都会有一张虚函数表，他是C++<strong>运行时多态（动态绑定）</strong> 的核心机制。<strong>虚函数表由编译器在编译时生成（编译时就为该数组分配好了内存，值为每个虚函数的对应地址）</strong>，存放在程序的只读数据段。</p><p>​<strong>虚函数表指针（vptr）</strong>：一个指向虚函数表的指针，每个类的所有实例对象共享一张虚函数表，而每个对象都会有一个指向虚函数表的指针。虚函数表指针位于每个对象内存布局的最前面，由编译器负责创建和初始化。</p><p>​当每次调用虚函数时，会先根据对象内部的虚函数表指针找到该类的虚函数表，查表找到对应虚函数的地址，从而调用正确的虚函数，这都是运行时发生的。</p><p>​如下面的例子所示，一个空类的大小是1字节，但是声明了一个虚函数之后大小变为了8字节（32位机器中为4字节）。首先空类大小为1字节是因为C++要求每个对象的内存地址都要不同，如果空类大小为0的话，那么两个对象就有可能有相同的地址，所以空类大小为1字节。</p><p>​其次可以发现声明了虚函数之后，32为机器中类大小为4字节，64为机器中类大小为8字节，刚好是一个指针的长度。没错，这就是编译器自动为有虚函数的类的实例对象添加的虚函数表指针。通过这种方式也可以证明编译器确实会自动为有虚函数的类的实例对象创建一个虚函数表指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Say</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestVirtual</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Say</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(Test) &lt;&lt; std::endl; <span class="comment">//大小为1</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(TestVirtual) &lt;&lt; std::endl; <span class="comment">//大小为8(32位机器是输出为4)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><h3 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h3><p>​如果子类单继承一个有虚函数的基类的话，编译器会根据基类的虚函数表来创建子类的虚函数表。这并不是简单的复制操作，如果子类重写了基类的虚函数，就把子类虚函数表对应的虚函数地址修改为子类实现的虚函数的地址，如果子类新增了虚函数，就在虚函数表尾部追加新增虚函数的地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Base</span>()</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot; Base删除&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Say</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;我是Base&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Say</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestDerived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(Test) &lt;&lt; std::endl; <span class="comment">//大小为1</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(TestDerived) &lt;&lt; std::endl; <span class="comment">//大小为8(32位机器是输出为4)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>​先看下面一个例子：</p><p>​使用基类指针指向了子类对象，当使用<code>delete</code>删除指针指向的内存时，会发现只调用了<code>Base</code>类的析构函数，并没有调用<code>Derive</code>类的析构函数。如果子类中有申请了一些资源，但并没得到释放，就造成了内存泄漏。为此就需要把<strong>基类的析构函数也声明为虚函数</strong>，这样使用<code>delete</code>删除指针时也会调用子类的析构函数，保证在子类中获取的资源能够正常释放。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~<span class="built_in">Base</span>()</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Base删除&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Base</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Say</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~<span class="built_in">Derive</span>()</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Derive删除&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Derive</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Say</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Base* b = <span class="keyword">new</span> <span class="built_in">Derive</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> b; <span class="comment">//删除后只调用了Base的析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​虚析构函数的原理和普通虚函数一样，都是<strong>通过虚函数表和虚函数表指针实现的</strong>。当基类的析构函数声明为虚析构函数时，子类的析构函数也默认为虚析构函数，此时会在虚函数表中将子类的虚析构函数的函数地址添加到表中。</p><p>​当使用<code>delete</code>关键字删除基类指针时，会首先通过子类的虚函数表指针找到子类的析构函数并调用。子类的析构函数执行完毕之后，编译器会<strong>自动地、隐式地</strong>在代码末尾插入对直接基类析构函数的调用。这是一个<strong>编译期确定的静态调用</strong>，从而形成从派生类到基类的完整析构链。</p><p>​所以一般的多态情况下，一定要把基类的析构函数设置为虚函数。除非<strong>确定不会有通过基类指针删除派生类对象的行为</strong>或者<strong>基类不是为继承而设计的</strong></p><p>，在这些情况下不需要将基类的析构函数设置为虚函数，避免每个对象携带<strong>vptr</strong>的开销。</p><p>​所以<strong>多态中的析构</strong>是<strong>动态</strong>和<strong>静态</strong>两种机制协同工作的：</p><ul><li><strong>动态多态</strong>（通过vtable查找对应子类的析构函数地址）确保了析构的<strong>起点</strong>是正确的。</li><li><strong>静态编译</strong>确保了析构的<strong>链条</strong>是完整且顺序正确的（确定了析构起点后，每个子类都会由编译器自动调用其直接父类的析构函数）。</li></ul><h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>​当某个类中声明了一个纯虚函数时，这个类就叫做抽象类。抽象类不能被实例化，只能被继承，类似<code>Java</code>中的<code>Interface</code>。当某个子类继承了一个抽象类时，就必须重写基类中的纯虚函数，否则子类也会成为一个抽象类无法实例化。抽象类常被用来作为接口，强迫继承自己的子类必须提供相应的函数声明和实现。</p><p>​声明语法和虚函数类似：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//声明虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">Test1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//声明纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">Test2</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​对于<strong>普通的虚函数</strong>来说：子类<strong>可以选择重写</strong>基类的虚函数，也<strong>可以不重写</strong>；但是<strong>基类必须提供虚函数的函数实现</strong>作为默认实现，否则实例化对象时就会编译错误。</p><p>​对于<strong>纯虚函数</strong>来说：子类<strong>必须重写</strong>基类的纯虚函数；基类<strong>可以给普通纯虚函数提供</strong>函数实现也<strong>可以不提供</strong>（因为子类一定重写），但是基类的<strong>纯虚析构函数必须要提供函数实现</strong>，因为编译器会自动调用基类的析构函数，不提供函数实现的话会编译错误。</p><p>​纯虚函数的函数声明要写在类内，定义必须写在类外。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestBase</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//纯虚析构函数必须要在类外提供函数定义</span></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">TestBase</span>() = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">TestBase</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//普通虚函数在基类中必须提供实现，即使函数体内没有内容也要写，是基类提供的默认实现，否则会编译错误</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//纯虚函数可以提供函数实现，也可以不提供</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Say</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//纯虚析构函数必须提供函数实现</span></span><br><span class="line">TestBase::~<span class="built_in">TestBase</span>()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通纯虚可以提供函数实现，也可以不提供</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestBase::Say</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestDerive</span> : <span class="keyword">public</span> TestBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">TestDerive</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">TestDerive</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子类必须重写基类的纯虚函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Say</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">Base* b = <span class="keyword">new</span> <span class="built_in">Derive</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> b; <span class="comment">//删除后只调用了Base的析构函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">TestBase* tb = <span class="keyword">new</span> <span class="built_in">TestDerive</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> tb;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">特性</th><th align="left">普通虚函数</th><th align="left">纯虚函数</th></tr></thead><tbody><tr><td align="left">是否必须有实现</td><td align="left">✅ 必须</td><td align="left">❌ 不需要（普通纯虚函数可写也可不写），纯虚析构函数必须有实现</td></tr><tr><td align="left">子类是否必须实现</td><td align="left">❌ 可选</td><td align="left">✅ 必须</td></tr><tr><td align="left">基类能否实例化</td><td align="left">✅ 可以</td><td align="left">❌ 不行（抽象类）</td></tr><tr><td align="left">用途</td><td align="left">提供默认行为，子类可选覆盖</td><td align="left">定义接口规范，强制子类实现</td></tr></tbody></table><h3 id="为什么构造函数不能声明为虚函数？"><a href="#为什么构造函数不能声明为虚函数？" class="headerlink" title="为什么构造函数不能声明为虚函数？"></a>为什么构造函数不能声明为虚函数？</h3><p>​从逻辑上来说：多态是通过基类指针或引用指向子类对象来实现多态的，必须是对象创建完成以后才能使用多态特性的。而构造函数就是用来初始化对象的，在对象构造之前并没有对象产生，因此无法使用多态特性，这是矛盾的。</p><p>​从内存空间上来说：虚函数的调用需要虚函数表指针，虚函数表指针会存放在对象的内存空间中，而且虚函数表指针的初始化是在构造函数内部实现的。所以会陷入鸡生蛋蛋生鸡的矛盾中，所以构造函数不能声明为虚函数。</p><h3 id="为什么内联-inline-成员函数不能声明为虚函数？"><a href="#为什么内联-inline-成员函数不能声明为虚函数？" class="headerlink" title="为什么内联(inline)成员函数不能声明为虚函数？"></a>为什么内联(inline)成员函数不能声明为虚函数？</h3><p>​内联函数可以在编译时把函数调用展开为函数体，减少函数调用的开销，显然这是编译时由编译器完成的。但是多态是运行时绑定的，运行时才知道要调用的是哪一个函数。显然内联函数和多态的特性是相违背的，自然无法将内联的成员函数声明为虚函数。</p><h3 id="类成员函数（包括构造和析构）内调用虚函数"><a href="#类成员函数（包括构造和析构）内调用虚函数" class="headerlink" title="类成员函数（包括构造和析构）内调用虚函数"></a>类成员函数（包括构造和析构）内调用虚函数</h3><p>​首先说一下结论，在<strong>普通成员函数内调用虚成员函数是多态</strong>，在<strong>构造函数或析构函数中调用虚成员函数不是多态</strong>。</p><p>​首先，对象创建时调用的构造函数是从基类到派生类按顺序层层调用的，而他的虚函数表指针也是在构造过程中层层设置的。当基类的构造函数执行时，整个对象还只是一个基类的对象（子类的那部分还没有开始创建），此时虚函数表指针也只知道基类的虚函数表，所以只会调用当前知道的基类的虚函数，而不会如期的调用你想要的子类的虚函数。</p><p>​析构函数中调用虚函数也是同理。</p><p>​而普通的成员函数调用肯定是对象创建完成之后才能调用的，此时虚函数表指针正确的指向了子类的虚函数表，可以正确的调用虚函数。</p><h1 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h1><h1 id="运算符重载（operator）"><a href="#运算符重载（operator）" class="headerlink" title="运算符重载（operator）"></a>运算符重载（operator）</h1><h1 id="new和delete关键字"><a href="#new和delete关键字" class="headerlink" title="new和delete关键字"></a>new和delete关键字</h1><p>​<strong>C++<strong>中的<code>new</code>和<code>delete</code>是关键字，同时也是</strong>操作符</strong>，用于管理内存控件。<code>new</code>可以在堆区申请一块内存空间，而<code>delete</code>则负责释放某一指针指向的内存空间。说到这里就不得不提一下<strong>C语言</strong>中的<code>malloc()</code>和<code>free()</code><strong>函数</strong>了，他们是<strong>C语言</strong>中申请和释放内存的工具，这两个函数在**C++**中也是支持的。但要注意一点，这两套管理内存的工具要配套使用，即使用<code>new</code>申请的内存必须要使用<code>delete</code>释放，使用<code>malloc()</code>函数申请的内存必须要使用<code>free()</code>函数释放。不能混着用，更不能只申请而不释放内存，这样会造成内存泄漏。所以切记，申请了内存后，一定要使用对应的方式释放的那块内存。</p><p>​首先来详细说一下<strong>C语言</strong>的<code>malloc()</code>和<code>free()</code>函数，因为<code>new</code>和<code>delete</code>是<strong>C++<strong>的</strong>关键字</strong>，而<strong>C语言</strong>的<code>malloc()</code>和<code>free()</code><strong>是函数</strong>，所以会在函数后面加上<code>()</code>，以清晰的表面这是一个函数。</p><h2 id="C里的malloc-和free"><a href="#C里的malloc-和free" class="headerlink" title="C里的malloc( )和free( )"></a>C里的malloc( )和free( )</h2><p>​<strong>C语言</strong>申请空间都是在<strong>堆区</strong>上开辟的，而申请的方式有3种；<code>malloc()</code>、<code>calloc()</code>和<code>realloc()</code>，但是下面主要介绍的是<code>malloc()</code>函数。</p><ol><li><code>malloc</code>：函数原型<code>void* malloc(size_t size);</code> ，参数<code>size</code>为要分配的字节数，返回值是<code>void*</code>,通常要强转为我们需要申请空间的类型，开辟成功回返回空间首地址；<strong>失败会返回NULL</strong>。但是申请成功后并<strong>不进行初始化</strong>，每个数据都是随机值。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在堆区申请一块连续内存作为数组int a[5]，但是里面的值没有初始化</span></span><br><span class="line"><span class="type">int</span>* a = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * <span class="number">5</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li><code>calloc</code>：函数原型<code>void* calloc(size_t count, size_t size);</code>， 参数<code>count</code>为要申请的个数；<code>size</code>为每一个数据的大小，返回值是<code>void*</code>,通常要强转为我们需要申请空间的类型，开辟成功回返回空间首地址；<strong>失败会返回NULL</strong>。但是申请成功会对空间<strong>进行初始化</strong>，且<strong>初始为0</strong>。可以把函数的第一个字母c理解为<code>count</code>，表面可以指定个数。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//效果和上面使用malloc的等价，但是里面的值会初始化为0</span></span><br><span class="line"><span class="type">int</span>* b = (<span class="type">int</span>*)<span class="built_in">calloc</span>(<span class="number">5</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure><ol start="3"><li><code>realloc</code>：函数原型 <code>void* realloc(void * ptr, size_t size);</code> 参数<code>ptr</code>为要扩展调整的空间首地址，参数<code>size</code>为调整为多少字节的空间，返回值是<code>void*</code>，通常要强转为我们需要申请空间的类型，调整成功回返回调整后的空间首地址；<strong>调整失败会返回NULL，原内存不会被改变</strong>。但是申请成功后并<strong>不进行初始化</strong>，每个数据都是随机值。简单来说，这个函数会<strong>尝试重新调整</strong><code>ptr</code>所指向的内存块大小为<code>size</code>。如果<code>ptr</code>为空指针的话，会申请一个<code>size</code>字节大小的空间并返回指向该空间的指针，也就是说第一个参数为<code>NULL</code>时，作用就和<code>malloc</code>函数一样了。注意，使用该函数后，我们只需要负责释放掉返回的地址即可（如果返回值不为<code>NULL</code>的话），原先的内存函数内会帮我们调整，多余的会释放掉，不足的话会重新申请更大的内存空间释放旧内存空间或者在后面拓展内存。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* temp = (<span class="type">int</span>*)<span class="built_in">calloc</span>(<span class="number">5</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="comment">//将temp指向的内存空间大小调整为1字节，返回的新地址有可能与temp相等，有可能不等</span></span><br><span class="line"><span class="type">int</span>* c = (<span class="type">int</span>*)<span class="built_in">realloc</span>(temp, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>​释放内存就比较简单了，只需要调用<code>free()</code>函数即可，其函数原型为free(void* ptr)，<code>ptr</code>参数是一个指向先前分配的内存块的指针。如果<code>ptr</code>为<code>NULL</code>，则<code>free</code>函数不执行任何操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* a = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * <span class="number">5</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* b = (<span class="type">int</span>*)<span class="built_in">calloc</span>(<span class="number">5</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* temp = (<span class="type">int</span>*)<span class="built_in">calloc</span>(<span class="number">5</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="type">int</span>* c = (<span class="type">int</span>*)<span class="built_in">realloc</span>(temp, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">free</span>(c); <span class="comment">//使用ralloc函数调整内存后，只需要对返回的地址调用free函数即可，不需要再释放temp（返回值不为NULL的情况下）</span></span><br></pre></td></tr></table></figure><h2 id="new-和-delete"><a href="#new-和-delete" class="headerlink" title="new 和 delete"></a>new 和 delete</h2><h3 id="new-operator-new和placement-new"><a href="#new-operator-new和placement-new" class="headerlink" title="new,operator new和placement new"></a>new,operator new和placement new</h3><p>​1. 首先要明确一点，<code>new</code>是<strong>C++<strong>里面的</strong>运算符</strong>，是一个关键字，类似于<code>sizeof</code>那种，我们无法改变其行为。<code>new</code>运算符要干的就是固定的三件事：<strong>1.<strong>调用名为<code>operator new</code>（或者<code>operator new[ ]</code>）的</strong>标准库函数</strong>，分配一块未初始化的、未命名的、足够大的内存空间以便我们存储指定的对象或者数组。**2.**编译器调用相应的构造函数创建对象并初始化。**3.**经过前两步的操作，对象以及分配了空间并初始化完成，返回一个指向该对象的指针。</p><p>​<code>new</code>运算符的具体使用如下，可以看到，我们不需要显示的给出所需内存的大小，<code>new</code>运算符会自动推导空间大小传递给对应的<code>operator new</code>函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type* ptr1 = <span class="keyword">new</span> type;</span><br><span class="line">type* ptr2 = <span class="keyword">new</span> <span class="built_in">type</span>(初始值);</span><br><span class="line">type* ptr3 = <span class="keyword">new</span> type[n];</span><br></pre></td></tr></table></figure><p>​2. <code>operator new</code>是一个全局的标准库函数，可以被重载，让用户自定义内存分配的行为，默认行为就是简单地分配指定字节的未初始化的原始内存，其底层调用的仍然是<code>malloc</code>函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义全局的operator new函数，会隐藏掉默认的全局operator new函数，而调用我们的，所以我们必须实现内存的分配</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当new单个对象时，size为单个对象的内存大小</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;分配了&quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot;字节的数据&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当new一个数组时，size为整个数组所需的内存大小</span></span><br><span class="line"><span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;operator new[] : 分配了&quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot;字节的数据&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用我们实现的全局operaotr new函数</span></span><br><span class="line">    <span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>); <span class="comment">//分配4字节</span></span><br><span class="line">    <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]; <span class="comment">//分配40字节</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> a;</span><br><span class="line">    <span class="keyword">delete</span>[] arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​我们也可以在类内重载<code>operator new</code>函数，以此实现每个类都可以有专属于自己的内存分配方式。可以看到，如果自定义类型内部重载了operator new函数之后，使用new创建该自定义对象时，会优先执行类内的重载版本。所以对于自定义类型，编译器<strong>会首先查找该类或者基类中是否有重载版本</strong>，如果有就调用；如果没有<strong>就到全局作用域查找</strong>，如果全局作用域有我们重载的，就会调用我们重载的版本；如果都<strong>没找到用户自定义的重载版本，就调用标准库的默认实现版本</strong>。</p><p>​还要一个需要注意的就是，类内重载的<code>operator new</code>函数必须为静态共有函数才可以正常使用，否则<code>new Test()</code>会编译错误。但是不用担心，类内重载的<code>operator new</code>函数是<strong>隐式静态</strong>的，我们<strong>无须显示声明它为静态函数</strong>，只需要设置为<code>public</code>即可。</p><p>​我们也可以使用 <code>::new Test()</code> 来<strong>指明在全局作用域内搜索operator new函数</strong>，而不是调用内类的重载版本。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本语法，返回值必须为void*，第一个参数为size_t</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//具体实现</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//具体实现</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Test</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Test</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//使用new构造单个Test对象时调用</span></span><br><span class="line"><span class="type">void</span>* <span class="keyword">operator</span> <span class="built_in">new</span>(<span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Test::operator new : 分配了&quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot;字节的数据&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//使用new构造Test对象数组时调用</span></span><br><span class="line"><span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Test::operator new[] : 分配了&quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot;字节的数据&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test* t1 = <span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//调用有参构造</span></span><br><span class="line">Test* t2 = <span class="keyword">new</span> <span class="built_in">Test</span>(); <span class="comment">//调用无参构造,即使调用无参构造也必须带上()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//必须要有无参构造函数才可以编译通过，因为数组形式不能传递参数</span></span><br><span class="line">Test* tArr = <span class="keyword">new</span> Test[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 ::new 显示调用全局的operator new，而不是调用类内重载的</span></span><br><span class="line">Test* tArr2 = ::<span class="keyword">new</span> Test[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> t1, t2;</span><br><span class="line"><span class="keyword">delete</span>[] tArr;</span><br><span class="line"><span class="keyword">delete</span>[] tArr2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​3. <code>placement new</code>是<code>operator new</code>的特殊的重载版本，<strong>不可以被重载</strong>，它允许在一块已经分配好的内存上调用构造函数来构造对象，不会分配内存，只是对已分配好的内存调用构造函数构造对象进行初始化。定位new对应的是一个特殊的，不可被重载的operator new函数，它不会在内部分配内存，只是简单的返回传入的指针ptr。随后编译器就在该指针指向的内存空间上调用构造函数构造对象来初始化内存空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//placement new专属的operator new版本，不可被重载</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>, <span class="type">void</span>* ptr)</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> ptr; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定位new的写法</span></span><br><span class="line"><span class="keyword">new</span>(ptr) type;</span><br><span class="line"><span class="keyword">new</span>(ptr) <span class="built_in">type</span>(初始值);</span><br><span class="line"><span class="keyword">new</span>(ptr) type&#123;初始化值&#125;;</span><br><span class="line"><span class="keyword">new</span>(ptr) type[n];</span><br><span class="line"><span class="keyword">new</span>(ptr) type[n]&#123;初始化值&#125;;</span><br></pre></td></tr></table></figure><p>​下面看一下具体使用的例子：</p><p>​可以看到下面四条<code>placement new</code>的语句中，指针的地址都没有发生变化，只是指向的内存空间中对象的值发生了变化，这就是<code>placement new</code>的用法。并且<code>placement new</code>不是普通的<code>new</code>，所以创建出来的对象不能使用<code>delete</code>释放，所以我们必须手动调用析构函数释放对象内的资源，防止内存泄漏。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Test</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">:<span class="built_in">val</span>(a)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Test::operator new : 分配了&quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot;字节的数据&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Test::operator new[] : 分配了&quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot;字节的数据&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test* t = (Test*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Test));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为Test内部重载了operator new，但是定位new的是不能被重载的，所以要使用::new显示调用全局的，不然会编译错误</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//都会调用无参默认构造函数</span></span><br><span class="line">    ::<span class="keyword">new</span>(t) Test; <span class="comment">//val初始化为默认值0      t的地址为：0x0000020296ab2640</span></span><br><span class="line">    ::<span class="keyword">new</span>(t) <span class="built_in">Test</span>(); <span class="comment">//val初始化为默认值0    t的地址为：0x0000020296ab2640</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//传参调用对应构造函数，使用()和&#123;&#125;都可以 </span></span><br><span class="line">    ::<span class="keyword">new</span>(t) <span class="built_in">Test</span>(<span class="number">10</span>, <span class="number">11</span>);  <span class="comment">//val初始化为10  t的地址为：0x0000020296ab2640</span></span><br><span class="line">    ::<span class="keyword">new</span>(t) Test&#123;<span class="number">99</span>, <span class="number">11</span>&#125;;  <span class="comment">//val初始化为99  t的地址为：0x0000020296ab2640</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为不是使用new创建的，所以不能使用delete释放，所以必须手动调用析构函数以释放资源</span></span><br><span class="line">    t-&gt;~<span class="built_in">Test</span>();</span><br><span class="line">    <span class="built_in">free</span>(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="delete和operator-delete"><a href="#delete和operator-delete" class="headerlink" title="delete和operator delete"></a>delete和operator delete</h3><p>​首先，<code>delete</code>和<code>new</code>一样是一个运算符，也是一个关键字，我们无法对其进行修改，<code>delete</code>的行为总是固定的两件事：**1.**对指针所指向的对象或者数组内的对象调用对应的析构函数销毁对象。**2.**调用名为<code>operator delete</code>（或者<code>operator delete[ ]</code>）的全局标准库函数释放内存空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="type">int</span>* b = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> a;</span><br><span class="line"><span class="keyword">delete</span>[] b;</span><br></pre></td></tr></table></figure><p>​和<code>operator new</code>一样，我们也可以自定义我们的<code>operator delete</code>，这样编译器会优先调用我们实现的版本，同样我们也可以使用<code>::delete</code>显示调用<strong>全局作用域内</strong>的<code>operator delete</code>，就不会调用类内的重载版本。并且<code>operator delete</code>的返回值是<code>void</code>，且<strong>不允许抛出异常</strong>，所以必须使用<code>noexcept</code>声明不会出现异常。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本写法，返回值必须为void，第一个参数为void*</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* ptr)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//释放内存操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span>* ptr) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//释放内存操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> a;</span><br><span class="line">    <span class="keyword">delete</span>[] arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​下面是标准库中（不包括<code>placement new</code>的）的<code>operator new</code>和<code>operator delete</code>，其中最下面四个是<code>nothrow</code>版本，会保证不抛出异常，主要是针对<code>operator new</code>来说的，因为<code>operator delete</code>不允许抛出异常。这几个函数我们都可以自定义，实现自己的版本，但是函数签名要和下面的一致，这样才能符合重载的要求。</p><table><thead><tr><th align="left">函数原型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>void* operator new(std::size_t size)</code></td><td align="left">基本的单个对象内存分配函数。分配失败时抛出 <code>std::bad_alloc</code>异常。</td></tr><tr><td align="left"><code>void* operator new[](std::size_t size)</code></td><td align="left">基本的数组对象内存分配函数。分配失败时抛出 <code>std::bad_alloc</code>异常。</td></tr><tr><td align="left"><code>void operator delete(void* ptr) noexcept</code></td><td align="left">基本的单个对象内存释放函数。</td></tr><tr><td align="left"><code>void operator delete[](void* ptr) noexcept</code></td><td align="left">基本的数组对象内存释放函数。</td></tr><tr><td align="left"><strong>函数原型（这里的operator new不会抛出异常）</strong></td><td align="left"><strong>说明</strong></td></tr><tr><td align="left"><code>void* operator new(std::size_t size, const std::nothrow_t&amp;) noexcept</code></td><td align="left"><strong>不抛出异常</strong>的单个对象分配版本。分配失败时返回空指针。</td></tr><tr><td align="left"><code>void* operator new[](std::size_t size, const std::nothrow_t&amp;) noexcept</code></td><td align="left"><strong>不抛出异常</strong>的数组对象分配版本。分配失败时返回空指针。</td></tr><tr><td align="left"><code>void operator delete(void* ptr, const std::nothrow_t&amp;) noexcept</code></td><td align="left">与 <code>nothrow new</code>对应的释放函数。</td></tr><tr><td align="left"><code>void operator delete[](void* ptr, const std::nothrow_t&amp;) noexcept</code></td><td align="left">与 <code>nothrow new[]</code>对应的释放函数。</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用nothrow版本的operator new，分配失败时返回空指针</span></span><br><span class="line"><span class="type">int</span>* t1 = <span class="built_in">new</span>(std::nothrow) <span class="type">int</span>[<span class="number">100000000000000</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用普通版本的operator new，分配失败时抛出std::bad_alloc异常</span></span><br><span class="line"><span class="type">int</span>* t2 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100000000000000</span>];</span><br></pre></td></tr></table></figure><h2 id="std-new-handler"><a href="#std-new-handler" class="headerlink" title="std::new_handler"></a>std::new_handler</h2><p>​前面介绍过，当<code>operator new</code>无法分配所需内存时，会抛出<code>std::bad_alloc</code>异常，这个说法并不完全正确。实际上，在抛出异常之前，会先调用一个由客户指定的处理函数：<code>new_hanlder</code>，如果没有指定这个函数才会抛出异常。</p><p>​<code>new_handler</code>类型较为简单，就是一个返回值为<code>void</code>，函数参数为空的函数指针。</p><p>​我们可以使用<code>std::set_new_handler</code>传递一个函数指针来设置我们的全局错误处理函数，并且会返回之前的全局错误处理函数的函数指针。也可以使用<code>std::get_new_handler</code>获取当前的全局错误处理函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> new_handler = <span class="built_in">void</span>(*)();</span><br><span class="line"></span><br><span class="line"><span class="function">new_handler <span class="title">set_new_handler</span><span class="params">(new_handler)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">new_handler <span class="title">get_new_handler</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br></pre></td></tr></table></figure><p>​如果我们设置了全局错误处理函数，分配失败时就会一直调用错误处理函数并再次尝试分配内存，直到它能找到足够的内存或者错误处理内函数内抛出异常或终止程序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyNewHandler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;MyNewHandler&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//设置自定义的全局错误处理函数</span></span><br><span class="line">    std::<span class="built_in">set_new_handler</span>(&amp;MyNewHandler);</span><br><span class="line">    <span class="comment">//分配失败时会调用我们的错误处理函数</span></span><br><span class="line">    <span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100000000000000</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将全局错误处理函数设置为空</span></span><br><span class="line">    std::<span class="built_in">set_new_handler</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//分配失败时抛出异常</span></span><br><span class="line">    <span class="type">int</span>* b = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100000000000000</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="new-delete和malloc-free的区别"><a href="#new-delete和malloc-free的区别" class="headerlink" title="new,delete和malloc,free的区别"></a>new,delete和malloc,free的区别</h2><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="size-t"><a href="#size-t" class="headerlink" title="size_t"></a>size_t</h2><p>​<code>size_t</code>是C++标准中定义的<strong>与平台相关的无符号整数类型</strong>，通常<strong>用于表示内存大小、数组索引</strong>等。其<strong>大小与平台相关</strong>，在64位平台上为64位(8字节)，而在32位平台上位32字节(4字节)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在32位平台上byteNum为4，是4字节大小</span></span><br><span class="line"><span class="comment">//在64位平台上byteNum为8，是8字节大小</span></span><br><span class="line"><span class="type">int</span> byteNum = <span class="built_in">sizeof</span>(<span class="type">size_t</span>);</span><br></pre></td></tr></table></figure><p>使用场景：</p><ul><li>表示<strong>内存大小、数组索引、字符串长度</strong>等与“数量”相关的场景。</li><li>C++标准库中广泛使用（如 <code>std::vector::size()</code> 返回 <code>size_t</code>）。</li><li>示例：遍历数组时的循环变量、动态内存分配的字节数（<code>malloc(size_t)</code>）。</li></ul><h2 id="uint32-t"><a href="#uint32-t" class="headerlink" title="uint32_t"></a>uint32_t</h2><p>​<code>uint32_t</code>是C++11标准中定义的<strong>固定宽度无符号整数类型</strong>，明确表示<strong>32位无符号整数</strong>。其<strong>大小与平台无关</strong>，不论在32位平台还是64位平台，<code>uint32_t</code>始终占用4个字节。</p><p>使用场景：</p><ul><li>需要<strong>精确控制数据宽度</strong>的场景（如网络协议、文件格式、嵌入式开发）。</li><li>要求<strong>跨平台一致性</strong>的数值计算（避免因平台差异导致数据溢出）。</li><li>示例：存储IP地址（32位）、编码格式中的字段长度（如HTTP头部字段）。</li></ul><h2 id="int32-t"><a href="#int32-t" class="headerlink" title="int32_t"></a>int32_t</h2><p>​<code>int32_t</code>是C99标准引入的<strong>固定宽度整数类型</strong>，明确表示<strong>32位有符号整数</strong>，其<strong>大小与平台无关</strong>，不论在32位平台还是64位平台，<code>int32_t</code>始终占用4个字节。只是相比于<code>uint32_t</code>来说，<code>int32_t</code>是有符号整数，可以表示正负。</p><h1 id="左值、右值和移动语义"><a href="#左值、右值和移动语义" class="headerlink" title="左值、右值和移动语义"></a>左值、右值和移动语义</h1><p>​在大部分情况下，我们可以<strong>简单理解</strong>为赋值操作中，<code>=</code>左侧的为左值，<code>=</code>右侧的为右值。例如<code>int i = 10;</code>中左侧的<code>i</code>就是左值，右侧的<code>10</code>就是右值，下面就详细说明一下二者的区别。</p><h2 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h2><h3 id="左值"><a href="#左值" class="headerlink" title="左值"></a>左值</h3><p>​<strong>左值（lvalue）<strong>指表达式结束后</strong>仍然持久存在</strong>的对象（有明确的内存地址）,可以简单理解为左值是一块内存空间的标识，可以对其使用<code>&amp;</code>取地址，而不是一个用完即销毁的临时变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x 是左值</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回左值引用的函数调用是左值</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">GetRef</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> m_Val;&#125;</span><br><span class="line"><span class="built_in">GetRef</span>() = <span class="number">10</span>;   </span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[0] 是左值</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">99</span>;</span><br></pre></td></tr></table></figure><h3 id="右值"><a href="#右值" class="headerlink" title="右值"></a>右值</h3><p>​<strong>右值（rvalue）<strong>指表达式结束后</strong>即将被销毁</strong>的临时值，不能用<code>&amp;</code>进行取地址操作，通常代表<strong>值（value）本身</strong>，就是一个数字或一个字面值或一个常量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 42 是右值（rvalue）</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回右值的函数调用仍是右值，因为返回的是一个临时变量，用完就被销毁了</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetVal</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> m_Val;&#125;</span><br><span class="line"><span class="type">int</span> x = <span class="built_in">GetVal</span>(); </span><br></pre></td></tr></table></figure><h3 id="左值和右值的区别"><a href="#左值和右值的区别" class="headerlink" title="左值和右值的区别"></a>左值和右值的区别</h3><p>​在赋值操作中，因为右值仅表示一个值，所以只能出现在<code>=</code>右边。但是左值本身也存储了一个数值，除了可以出现在<code>=</code>左边接收一个值外，也可以出现在<code>=</code>右边（相当于把x存储的数值拿出来拷贝再赋值给别人，但x本身还是一个左值）。简单来说就是<strong>右值只能当作右值用</strong>，而<strong>左值也可以被当作右值使用</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//x有内存空间，可以取地址，可以长期存在，是一个左值</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//y也是左值，虽然x出现在=右侧，但x仍是左值</span></span><br><span class="line"><span class="type">int</span> y = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">//z显然是左值，但是x + y会创建一个临时变量存在结果，所以表达式x + y是右值</span></span><br><span class="line"><span class="type">int</span> z = x + y;</span><br></pre></td></tr></table></figure><p>​下面看一下左值引用和右值引用用作函数参数的形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_Val = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为参数是引用形式，右值只是一个临时变量，没有持久的存储空间，该函数只能接收左值引用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetValue</span><span class="params">(<span class="type">int</span>&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Non const&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    m_Val = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加入const修饰后，函数可以接收左值和右值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Const&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    m_Val = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">SetValue</span>(i);<span class="comment">//传入左值，会自动匹配第一个函数</span></span><br><span class="line">    <span class="built_in">SetValue</span>(<span class="number">10</span>);<span class="comment">//传入的是右值，会自动匹配第二个函数</span></span><br><span class="line">    <span class="built_in">SetValue</span>(i + <span class="number">10</span>);<span class="comment">//传入的是右值，会自动匹配第二个函数</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">SetValue</span>(i + j);<span class="comment">//传入的是右值，会自动匹配第二个函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​知道了这些后，再回顾一下函数参数为<code>std::string</code>的形式，函数接收字符串引用，外面调用时直接传入<code>str1 + str2</code>组成的字符串，这是比较场景的场景，但是这样会报错。因为函数接收的是左值引用的形式，但是<code>str1 + str2</code>是一个右值，所以会报错。这也是为什么函数参数为字符串时都会加入<code>const</code>修饰符的原因。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左值引用只能接收左值，下面的调用会报错</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintString</span><span class="params">(std::string&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰后可以接收右值,下面可以正常调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintString</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// &quot;hmy&quot;是字符串字面量，是一个左值，但是const char*类型</span></span><br><span class="line">    <span class="comment">// 因为函数形参为std::string类型，传递时会将const char*转为std::string的临时变量，这个临时变量是右值，所以无法编译通关</span></span><br><span class="line">    <span class="built_in">PrintString</span>(<span class="string">&quot;hmy&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​c++中对于一个<code>&quot;hmy&quot;</code>形式的字符串字面量来说，也是一个左值，因为该字符串会被存储在<strong>静态存储区</strong>，生命周期会伴随整个应用程序，我们可以使用<code>&amp;</code>直接对字符串<code>&quot;hmy&quot;</code><strong>取地址</strong>，所以这样的<strong>字符串字面量是一个左值</strong>。</p><p>​但是为什么这样的字符串是一个左值，却无法正确被接收左值引用的函数所使用呢？</p><p>​因为字符串字面量<code>&quot;hmy&quot;</code>是<code>const char*</code>类型的左值，传参时会隐式转换，创建一个<code>std::string</code>类型的<strong>临时变量</strong>，这个<strong>临时变量是右值，所以无法传参</strong>。但是函数参数加入const修饰后，可以接收右值参数，此时才可以正常传参。</p><h3 id="i和i"><a href="#i和i" class="headerlink" title="++i和i++"></a>++i和i++</h3><p>​这两个在日常使用中很常见，但是就左值右值来说却不一样。首先说一下结论，<code>++i</code>是一个<strong>左值</strong>，<code>i++</code>是一个<strong>右值</strong>。下面来分析一下具体的过程。</p><p>​<code>++i</code>操作会先将<code>i</code>加一后返回<code>i</code>，因此执行<code>++i</code>返回的就是加一后的<code>i</code>本身。所以<code>++i</code>是一个<strong>左值</strong>。</p><p>​<code>i++</code>操作会先将<code>i</code>的值复制一份存到<strong>栈里的临时变量</strong>中，然后再将i加一，最后<strong>返回的是栈中的临时变量</strong>。所以<code>i++</code>是一个<strong>右值</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* p1 = &amp;(++i); <span class="comment">//因为++i返回的是自增后的i本身，是一个右值，可以取地址</span></span><br><span class="line"><span class="comment">//因为++i执行后返回的是i本身，所以p1和&amp;i的地址是一样的</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;i:  &quot;</span> &lt;&lt; &amp;i &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;++i:&quot;</span> &lt;&lt; p1 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int* p2 = &amp;(i++); 因为i++返回的是右值，所以不能取地址</span></span><br></pre></td></tr></table></figure><p>​最后从汇编代码看一下底层原理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>; </span><br><span class="line"><span class="comment">//使用const int&amp;接收返回的值，更准确的看出返回的到的是什么</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; j = ++i;</span><br><span class="line"><span class="comment">//首先，将i中的值加载到寄存器中执行递增(加一)操作</span></span><br><span class="line"><span class="number">00007</span>FF69CDE250D  mov         eax,dword ptr [i]  </span><br><span class="line"><span class="number">00007</span>FF69CDE2513  inc         eax  </span><br><span class="line"><span class="comment">//然后，将寄存器中递增后的值放回i中</span></span><br><span class="line"><span class="number">00007</span>FF69CDE2515  mov         dword ptr [i],eax  </span><br><span class="line"><span class="comment">//最后，获取变量i的内存地址，绑定到引用j</span></span><br><span class="line"><span class="number">00007</span>FF69CDE251B  lea         rax,[i]  </span><br><span class="line"><span class="number">00007</span>FF69CDE2522  mov         qword ptr [j],rax  </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; k = i++;</span><br><span class="line"><span class="comment">//首先，将i中的值(旧值)加载到寄存器中</span></span><br><span class="line"><span class="number">00007</span>FF69CDE2529  mov         eax,dword ptr [i]  </span><br><span class="line"><span class="comment">//再将寄存器中的值(旧值)保存到栈上的临时变量中</span></span><br><span class="line"><span class="number">00007</span>FF69CDE252F  mov         dword ptr [rbp<span class="number">+274</span>h],eax</span><br><span class="line"><span class="comment">//然后再对i中的值执行递增(加一)操作</span></span><br><span class="line"><span class="number">00007</span>FF69CDE2535  mov         eax,dword ptr [i]  </span><br><span class="line"><span class="number">00007</span>FF69CDE253B  inc         eax  </span><br><span class="line"><span class="comment">//将递增后的新值保存到i中</span></span><br><span class="line"><span class="number">00007</span>FF69CDE253D  mov         dword ptr [i],eax  </span><br><span class="line"><span class="comment">//从临时变量中获取旧值，最后将临时变量的地址绑定到引用k</span></span><br><span class="line"><span class="number">00007</span>FF69CDE2543  mov         eax,dword ptr [rbp<span class="number">+274</span>h]  </span><br><span class="line"><span class="number">00007</span>FF69CDE2549  mov         dword ptr [rbp<span class="number">+164</span>h],eax  </span><br><span class="line"><span class="number">00007</span>FF69CDE254F  lea         rax,[rbp<span class="number">+164</span>h]  </span><br><span class="line"><span class="number">00007</span>FF69CDE2556  mov         qword ptr [k],rax  </span><br></pre></td></tr></table></figure><h2 id="左值引用和右值引用"><a href="#左值引用和右值引用" class="headerlink" title="左值引用和右值引用"></a>左值引用和右值引用</h2><h3 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h3><p>​左值引用就是平时使用的那种引用，形式为<code>T&amp;</code>（如<code>int&amp;</code>，<code>std::string&amp;</code>等），只能绑定到 <strong>左值</strong>（有持久内存地址的对象）。</p><p>​其实每个变量可以看做是地址的别名，高级语言进行了封装，对该变量进行操作就等同于对该内存操作。而左值引用就相当于又给该地址起了另一个别名，对这两个别名操作都等同于对一块内存操作，所以一改俱改。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//右侧是对应的汇编代码</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>; <span class="comment">// dword ptr [a],0Ah</span></span><br><span class="line">a = <span class="number">20</span>;     <span class="comment">// dword ptr [a],14h</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span>&amp; b = a;</span><br><span class="line"><span class="type">int</span>&amp; c = a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最终输出的地址都是一样的</span></span><br><span class="line">std::cout &lt;&lt; &amp;a &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; &amp;b &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; &amp;c &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>​前面说过，普通的左值引用<code>T&amp;</code>不能绑定右值只能绑定左值，但是常左值引用<code>const T&amp;</code>就能够绑定到右值。前面说过，右值一般都是没有内存地址的字面量或者用完即毁的临时变量。</p><p>​底层在实现时会先<strong>在栈上创建一个临时变量</strong>，再把该临时变量的地址给d，而且<strong>临时变量的生命周期和对应的引用一致</strong>，当该引用销毁时才会销毁该临时变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int&amp; d = 10; //普通的左值引用不能绑定右值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; d = <span class="number">10</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//该行代码对应的汇编代码</span></span><br><span class="line">dword ptr [rbp<span class="number">+0E4</span>h],<span class="number">0</span>Ah  <span class="comment">//从栈上创建一个临时变量，值为10</span></span><br><span class="line">rax,[rbp<span class="number">+0E4</span>h]  </span><br><span class="line">qword ptr [d],rax <span class="comment">//将栈上临时变量的地址给d，并且该临时变量的生命周期变为和引用d一样</span></span><br></pre></td></tr></table></figure><p>​那这样做的理由在哪里呢？</p><ul><li>C++早期（C++98）没有右值引用（<code>T&amp;&amp;</code>），但需要一种方式让函数接受临时对象（右值）作为参数，<code>const T&amp;</code>的引入解决了这一问题。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span>; <span class="comment">// 可接受左值或右值</span></span><br><span class="line">std::string s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">print</span>(s) <span class="comment">//传入左值也可以</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">//传入右值也可以</span></span><br></pre></td></tr></table></figure><ul><li>同时使用<code>const T&amp;</code>也能保证安全性。右值通常是临时对象，允许引用修改它们无意义且危险，使用const修饰后，可以避免该引用修改临时变量的值。</li></ul><h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>​我们也可以使用<code>&amp;&amp;</code>表面函数参数为一个<strong>右值引用</strong>，表面该函数只接受右值作为函数参数。现在分别有了只接受左值和只接受右值的函数，我们可以利用这两中函数更准确的区分左值和右值。能被第一个函数使用的就是左值，能被第二个函数使用的就是右值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左值引用只接收非左值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintString</span><span class="params">(std::string&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//右值引用只接收右值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintString</span><span class="params">(std::string&amp;&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string str1 = <span class="string">&quot;hmy&quot;</span>;</span><br><span class="line">    std::string str2 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">PrintString</span>(str1);<span class="comment">//传入左值，调用第一个函数</span></span><br><span class="line">    <span class="built_in">PrintString</span>(str1 + str2);<span class="comment">//传入右值，调用第二个函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="移动语义-std-move"><a href="#移动语义-std-move" class="headerlink" title="移动语义(std::move)"></a>移动语义(std::move)</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>​对于下面的例子来说，创建了一个<code>Entity</code>对象<code>e</code>，并传入了一个<code>String</code>对象，首先会调用<code>String</code>类的构造函数创建一个临时变量，然后该临时变量会赋值给<code>Entity</code>构造函数的形参，其形参也是一个<code>String</code>类，所以会触发<code>String</code>的拷贝构造函数。</p><p>​可以看到这一个简单的过程调用了<code>String</code>的普通构造函数和拷贝构造函数，使用new在堆区创建了两次内存。但是我们明明都在栈区创建了一个对象了，传到函数里却还要再进行一次深拷贝，这种开销是没有必要的。</p><p>​所以c++11引入了移动语义，可以解决这一问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//默认构造函数</span></span><br><span class="line"><span class="built_in">String</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="comment">//一般的构造函数</span></span><br><span class="line"><span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* data)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Create\n&quot;</span>);</span><br><span class="line">m_Size = <span class="built_in">strlen</span>(data);</span><br><span class="line">m_Data = <span class="keyword">new</span> <span class="type">char</span>[m_Size];</span><br><span class="line"><span class="built_in">memcpy</span>(m_Data, data, m_Size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造函数(接收左值引用和右值)</span></span><br><span class="line"><span class="built_in">String</span>(<span class="type">const</span> String&amp; other)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Copy\n&quot;</span>);</span><br><span class="line">m_Size = other.m_Size;</span><br><span class="line">m_Data = <span class="keyword">new</span> <span class="type">char</span>[m_Size];</span><br><span class="line"><span class="built_in">memcpy</span>(m_Data, other.m_Data, m_Size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">~<span class="built_in">String</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Destory\n&quot;</span>);</span><br><span class="line"><span class="keyword">delete</span>[] m_Data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">puts</span>(m_Data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">uint32_t</span> m_Size;</span><br><span class="line"><span class="type">char</span>* m_Data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Entity</span>(<span class="type">const</span> String&amp; name)</span><br><span class="line">:<span class="built_in">m_Name</span>(name)</span><br><span class="line">&#123;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">puts</span>(m_Name.m_Data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">String m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//String(&quot;hmy&quot;)创建一个临时对象，临时对象赋值给函数形参</span></span><br><span class="line">    <span class="comment">//这一个过程调用了String的普通构造函数和拷贝构造函数，使用new在堆区创建了两次内存</span></span><br><span class="line"><span class="function">Entity <span class="title">e</span><span class="params">(String(<span class="string">&quot;hmy&quot;</span>))</span></span>;</span><br><span class="line">e.<span class="built_in">Print</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h3><p>​移动语义是 C++11 引入的一项重要特性，它允许资源的<strong>高效转移而非复制</strong>，显著提高了程序的性能。C++11之前，对象的资源转移只能通过复制（拷贝）完成，创建一个临时变量传入拷贝构造函数，对象再进行资源拷贝。</p><p>​有了移动语义之后，允许我们直接对<strong>资源进行窃取</strong>而非复制。简单来说就是我们不必再通过先创建临时变量，再从临时变量那里复制一份数据，而是<strong>直接把临时变量里面的数据拿过来占为己有</strong>。</p><p>​为此我们需要<code>Entity</code>的构造函数支持右值引用，允许接收一个临时变量，这样再给<code>m_Name</code>赋值时可以调用<code>String</code>的<strong>移动构造函数</strong>而<strong>不是拷贝构造函数</strong>。</p><p>​修改后的代码执行后，执行了一次普通构造函数和一次移动构造函数，而且数据只在堆区创建了一次。所以对于那些需要被转移走数据的变量，我们通常会将他强转为<code>(Type&amp;&amp;)</code>，明确表示其为右值引用类型，数据是可以被转移的。</p><p>​在一个移动构造函数中，如果当一个对象的资源移动到另一个对象时发生了异常，也就是说对象的一部分发生了转移而另一部分没有，这就会造成源对象和目标对象都不完整的情况发生，这种情况的后果是无法预测的。所以在<strong>编写移动语义的函数时建议确保函数不会抛出异常</strong>，与此同时，如果无法保证移动构造函数不会抛出异常，可以使用<code>noexcept</code>说明符限制该函数。这样当函数抛出异常的时候，程序不会再继续执行而是调用<code>std::terminate</code>中止执行以免造成其他不良影响。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//默认构造函数</span></span><br><span class="line"><span class="built_in">String</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="comment">//一般的构造函数</span></span><br><span class="line"><span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* data)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Create\n&quot;</span>);</span><br><span class="line">m_Size = <span class="built_in">strlen</span>(data);</span><br><span class="line">m_Data = <span class="keyword">new</span> <span class="type">char</span>[m_Size];</span><br><span class="line"><span class="built_in">memcpy</span>(m_Data, data, m_Size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造函数(接收左值引用和右值)</span></span><br><span class="line"><span class="built_in">String</span>(<span class="type">const</span> String&amp; other)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Copy\n&quot;</span>);</span><br><span class="line">m_Size = other.m_Size;</span><br><span class="line">m_Data = <span class="keyword">new</span> <span class="type">char</span>[m_Size];</span><br><span class="line"><span class="built_in">memcpy</span>(m_Data, other.m_Data, m_Size);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//移动构造函数(接收右值引用)</span></span><br><span class="line">    <span class="comment">//使用移动语义的函数要加入noexcept修饰，告诉编译器这是不会出现错误的，否则编译器会认为移动数据可能有危险，会出现警告</span></span><br><span class="line"><span class="built_in">String</span>(<span class="type">const</span> String&amp; other) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Copy\n&quot;</span>);</span><br><span class="line">        <span class="comment">//将临时变量的数据占为己有</span></span><br><span class="line">m_Size = other.m_Size;</span><br><span class="line">m_Data = other.m_Data;</span><br><span class="line">        <span class="comment">//临时变量的数据已经被占有，自己没有任何数据了，要把他的指针置为空，否则销毁时会把原先的数据释放掉</span></span><br><span class="line">        other.m_Size = <span class="number">0</span>;</span><br><span class="line">        other.m_Data = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">~<span class="built_in">String</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Destory\n&quot;</span>);</span><br><span class="line"><span class="keyword">delete</span>[] m_Data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">puts</span>(m_Data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">uint32_t</span> m_Size;</span><br><span class="line"><span class="type">char</span>* m_Data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Entity</span>(<span class="type">const</span> String&amp; name)</span><br><span class="line">:<span class="built_in">m_Name</span>(name)</span><br><span class="line">&#123;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//函数参数为右值引用，表面允许接收一个临时变量，讲临时变量传递给m_Name时调用他的移动构造函数而非拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Entity</span>(String&amp;&amp; name)</span><br><span class="line">:<span class="built_in">m_Name</span>((String&amp;&amp;)name)</span><br><span class="line">&#123;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">puts</span>(m_Name.m_Data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">String m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//String(&quot;hmy&quot;)创建一个临时对象，临时对象赋值给函数形参</span></span><br><span class="line">    <span class="comment">//由于Entity增加了支持右值引用的构造函数，会优先调用该右值引用构造函数，再创建m_Name时会调用String的移动构造函数而非拷贝构造函数</span></span><br><span class="line"><span class="function">Entity <span class="title">e1</span><span class="params">(String(<span class="string">&quot;hmy&quot;</span>))</span></span>;</span><br><span class="line">e<span class="number">1.</span><span class="built_in">Print</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​参考下面一个例子，如果我们希望将str1的数据移动到str2，如果直接将str1赋值给str2，会触发拷贝构造函数。必须显式的将str2转换为(String&amp;&amp;)类型才可以。但是这样手动转换是很不方便的，而且有时数据类型我们不一定能明确知道，可以使用<code>std::move()</code>，其作用就是<strong>将传进来的参数转为右值引用</strong>，并且会自动推到类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    String str1 = <span class="string">&quot;hmy&quot;</span>;</span><br><span class="line">    <span class="comment">//触发拷贝构造函数</span></span><br><span class="line">    String str2 = str1;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//触发移动构造函数</span></span><br><span class="line">    String str2 = (String&amp;&amp;)str1;</span><br><span class="line"><span class="comment">//触发移动构造函数(和第二种写法等价)</span></span><br><span class="line">    String str2 = std::<span class="built_in">move</span>(str1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="移动构造函数和赋值运算符"><a href="#移动构造函数和赋值运算符" class="headerlink" title="移动构造函数和赋值运算符"></a>移动构造函数和赋值运算符</h3><p>​可以看到，情况1和情况2都是调用的构造函数，但是情况3调用的是赋值运算符。那是因为情况三在赋值操作的时候str2已经调用默认构造函数创建完成了，一个已经创建完成的对象，所以再赋值时会调用赋值运算符。</p><p>​为了能执行，我们必须给String类添加支持右值移动的赋值运算符重载，但是赋值运算符会出现<code>str2 = std::move(str2)</code>操作，此时执行的话会导致自己的数据被删除。所以必须要判断二者是否为一个对象，确认二者不是一个对象才可以删除数据，否则会出大问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给String类添加支持右值移动的赋值运算符重载</span></span><br><span class="line"></span><br><span class="line">String&amp; <span class="keyword">operator</span>=(String&amp;&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//因为赋值运算符有可能出现str2 = std::move(str2)的情况，如果是一个对象要直接返回，否则会自己的删除数据</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Moved\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//先删除自己的数据</span></span><br><span class="line">    <span class="keyword">delete</span>[]m_Data;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将其他对象的数据占为己有</span></span><br><span class="line">    m_Size = other.m_Size;</span><br><span class="line">    m_Data = other.m_Data;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//其他对象的数据已经被占有，自己没有任何数据了</span></span><br><span class="line">    other.m_Size = <span class="number">0</span>;</span><br><span class="line">    other.m_Data = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    String str1 = <span class="string">&quot;hmy&quot;</span>;</span><br><span class="line">    <span class="comment">//情况1.触发拷贝构造函数</span></span><br><span class="line">    String str2 = str1;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//情况2.触发移动构造函数</span></span><br><span class="line">    String str2 = std::<span class="built_in">move</span>(str1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//情况3.触发赋值运算符</span></span><br><span class="line">    String str2;</span><br><span class="line">    str2 = std::<span class="built_in">move</span>(str1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​所以为了能支持移动语义，类里面必须要由<strong>移动构造函数</strong>和<strong>移动赋值运算符重载</strong>。所以<code>std::move</code>所干的事情并<strong>不是实现资源移动</strong>，而是将某个<strong>左值转变为右值</strong>(临时变量)，从而<strong>触发移动构造函数</strong>或<strong>移动赋值运算符重载</strong>，<strong>避免深拷贝</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::move底层实现如下(简化版)</span></span><br><span class="line"><span class="comment">// _Ty&amp;&amp;是通用引用,可以绑定到左值或右值</span></span><br><span class="line"><span class="comment">// remove_reference_t能移除_Ty身上所有的引用修饰符(例如int&amp;,int&amp;&amp;都能转为int)</span></span><br><span class="line"><span class="comment">// 使用static_cast和remove_reference_t&lt;_Ty&gt;&amp;&amp;，将类型强制转换为右值引用的形式，最后一定为type&amp;&amp;的形式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">remove_reference_t</span>&lt;_Ty&gt;&amp;&amp; <span class="title">move</span><span class="params">(_Ty&amp;&amp; _Arg)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="type">remove_reference_t</span>&lt;_Ty&gt;&amp;&amp;&gt;(_Arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="万能引用"><a href="#万能引用" class="headerlink" title="万能引用"></a>万能引用</h2><p>​在有了右值引用后，我们在编写函数时也会编写一个函数版本能够接收右值引用，但是这样会导致函数需要写多个版本，太过冗余。此时就可以使用模板+万能引用解决这个问题。</p><p>​模板函数中参数为<code>T&amp;&amp;</code>以后：</p><ul><li><p>如果传入的是<strong>左值</strong>，T会被推到为<code>type&amp;</code>，此时函数参数为<code>type&amp; &amp;&amp;</code>，<strong>引用折叠后</strong>为<code>type&amp;</code>，最终为左值引用。</p></li><li><p>如果为<strong>右值</strong>，T会被推导为<code>type</code>，此时函数参数为<code>type&amp;&amp;</code>，最终为右值引用。</p></li></ul><p>​如果不希望传入左值引用被函数内部修改，可以在外部将该右值变量定义为<code>const</code>，这样T会推到为<code>const type&amp;</code>，函数内部就无法修改值了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//针对每个参数都要有接收左值引用和右值引用的情况，显然过于麻烦</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span>&amp;&amp; a, <span class="type">float</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span>&amp;&amp; a, <span class="type">float</span>&amp;&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">float</span>&amp;&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">float</span>&amp;&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用模板＋T&amp;&amp;万能引用，能够自动推导T是左值还是右值</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(T &amp;&amp;val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">Print</span>(a); <span class="comment">//推导T为int&amp;，int&amp; &amp;&amp;引用折叠后为int&amp;</span></span><br><span class="line"><span class="built_in">Print</span>(<span class="number">1</span>); <span class="comment">//推导T为int，int&amp;&amp;就是int&amp;&amp;</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">Print</span>(b); <span class="comment">//推导T为const int&amp;，const int&amp; &amp;&amp;引用折叠后为const int&amp;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​万能引用的形式必须为<code>T&amp;&amp;</code>或者<code>auto&amp;&amp;</code>，也就是说必须在初始化的时候可以直接推导出来，写作其他形式的都不是万能引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只有T&amp;&amp;写法的才算万能引用，std::vector&lt;T&gt; &amp;&amp;不是万能引用，知识一个右值引用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print1</span><span class="params">(std::vector&lt;T&gt; &amp;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//只有严格为 T&amp;&amp; 写法的才算万能引用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print2</span><span class="params">(T&amp;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Print1不是万能引用，只能接收右值引用</span></span><br><span class="line"><span class="built_in">Print1</span>(std::vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">1</span>&#125;);</span><br><span class="line"><span class="comment">//Print1(v); 编译错误，因为Print1不是万能引用，只能接收右值引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Print2是万能引用，能自己推导</span></span><br><span class="line"><span class="built_in">Print2</span>(std::vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">1</span>&#125;);</span><br><span class="line"><span class="built_in">Print2</span>(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h2><p>​引用折叠是 C++11 引入的一个规则，用于处理模板和类型推导中引用类型的组合情况。它在<strong>完美转发</strong>(perfect forwarding)和<strong>模板元编程</strong>中非常重要。</p><table><thead><tr><th align="left">第一种引用</th><th align="left">第二种引用</th><th align="left">折叠结果</th></tr></thead><tbody><tr><td align="left"><code>T&amp;</code></td><td align="left"><code>&amp;</code></td><td align="left"><code>T&amp;</code></td></tr><tr><td align="left"><code>T&amp;</code></td><td align="left"><code>&amp;&amp;</code></td><td align="left"><code>T&amp;</code></td></tr><tr><td align="left"><code>T&amp;&amp;</code></td><td align="left"><code>&amp;</code></td><td align="left"><code>T&amp;</code></td></tr><tr><td align="left"><code>T&amp;&amp;</code></td><td align="left"><code>&amp;&amp;</code></td><td align="left"><code>T&amp;&amp;</code></td></tr></tbody></table><p>​简单来说就是<strong>有左为左</strong>，<strong>全右才右</strong>。即只要出现左值引用和其他引用混合，一律折叠为左值引用；只有两个都是右值引用时才会折叠为右值引用。</p><h2 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h2><p>​完美转发是C++11引入的一项重要特性，它允许函数模板将其参数<strong>原封不动</strong>地转发给其他函数，保持参数的<strong>值类别</strong>（左值&#x2F;右值）和<strong>类型</strong>不变。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Hello</span><span class="params">(<span class="type">int</span>&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;右值引用函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Hello</span><span class="params">(<span class="type">int</span>&amp;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;左值引用函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Say</span><span class="params">(T&amp;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//传入右值时T&amp;&amp; a--&gt;变为int&amp;&amp; a，而右值引用a本身是一个左值，传递给Hello函数时会当作左值传递</span></span><br><span class="line"><span class="comment">//Hello(a);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.向下传递参数之前使用万能引用将参数强转为正确类型</span></span><br><span class="line"><span class="comment">//Hello(static_cast&lt;T&amp;&amp;&gt;(a));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 使用std::forward&lt;T&gt;(a)向下传递(1,2等价)</span></span><br><span class="line"><span class="built_in">Hello</span>(std::forward&lt;T&gt;(a));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> f = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//T推断为int&amp;，引用折叠后为int&amp; a，a是一个左值引用，调用左值引用的函数</span></span><br><span class="line"><span class="built_in">Say</span>(f);</span><br><span class="line"></span><br><span class="line"><span class="comment">//T推断为int，引用折叠后为int&amp;&amp; a，a是一个右值引用，但是右值引用本身是一个左值(会在栈上创建一个临时变量),所以将a传递给下一个函数时会被当作左值传递，所以调用了左值函数</span></span><br><span class="line"><span class="built_in">Say</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​在向下传递参数时，可以先使用<code>static_cast&lt;T&amp;&amp;&gt;</code>将参数强转为正确的类型再向下传递，也可以直接使用<code>std::forward&lt; T &gt;</code>实现完美转发，这两种操作其实是等价的，都能将参数按照正确类型传递。</p><p>​<code>std::forward</code>的底层原理如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个重载版本接收的是左值引用类型的参数（T为引用时说明是一个左值，调用该函数）</span></span><br><span class="line"><span class="comment">//remove_reference_t&lt;T&gt;会去除T的所有引用修饰，变为一个原始类型(例如int、float或自定义类型的原始类型)，所以remove_reference_t&lt;T&gt;&amp; 会得到一个原始类型的左值引用(int&amp;，float&amp;等)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="type">remove_reference_t</span>&lt;T&gt;&amp; _Arg)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(_Arg);<span class="comment">//使用static_cast&lt;T&amp;&amp;&gt;强转为正确的类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个重载版本接收的是右值引用类型的参数（T为非引用时说明是一个右值，调用该函数）</span></span><br><span class="line"><span class="comment">//同理remove_reference_t&lt;T&gt;&amp;&amp; 会得到原始类型的右值引用(int&amp;&amp;, float&amp;&amp;等)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="type">remove_reference_t</span>&lt;T&gt;&amp;&amp; _Arg)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(!is_lvalue_reference_v&lt;T&gt;, <span class="string">&quot;bad forward call&quot;</span>);<span class="comment">//安全性保证，这个函数只用来处理右值引用类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(_Arg);<span class="comment">//使用static_cast&lt;T&amp;&amp;&gt;强转为正确的类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数指针、Lambda表达式和std-functional、std-bind"><a href="#函数指针、Lambda表达式和std-functional、std-bind" class="headerlink" title="函数指针、Lambda表达式和std::functional、std::bind"></a>函数指针、Lambda表达式和std::functional、std::bind</h1><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>​<strong>函数指针</strong>是<strong>指向函数的指针</strong>，它可以保存某个函数的地址，使得程序可以通过函数指针调用对应的函数。尤其在回调函数，事件处理函数等场景中会经常用到。或者将函数作为返回值，或者在不同的上下文中动态地调用不同的函数。</p><p>​计算机中，所有高级语言的代码最终都会编译转换为CPU可以执行的机器语言的指令。函数由一系列的指令组成，这些指令告诉CPU该如何执行该函数的任务。<strong>这些指令序列必须存储在内存中</strong>，以便CPU可以按照程序的流程来执行它们。<strong>函数的内存地址</strong>就是<strong>这些指令序列在存中开始的地方</strong>。</p><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>​声明一个函数指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">返回类型(* 函数指针名)(参数类型)</span><br><span class="line"><span class="comment">//返回int类型，指针名叫addPtr，接受两个为int类型的参数</span></span><br><span class="line"><span class="built_in">int</span>(* addPtr)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    addPtr = &amp;f1;<span class="comment">//对函数名取地址拿到函数的地址</span></span><br><span class="line">    <span class="comment">//拿到函数地址以后可以直接用()调用函数</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">addPtr</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; std::endl;</span><br><span class="line">addPtr = f1;<span class="comment">//直接用函数名赋值会隐式转换</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">addPtr</span>(<span class="number">2</span>, <span class="number">2</span>) &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">//addPtr = &amp;f2; //返回类型和参数列表必须一致</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​函数指针作为函数参数传递：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数指针可以作为函数参数传递，在函数体里可以直接调用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span>(*fPtr)(<span class="type">int</span>, <span class="type">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">fPtr</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">int</span>(* addPtr)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line">    addPtr = &amp;f1;</span><br><span class="line">    <span class="comment">//将函数指针当早函数参数传递，函数体内可以直接调用函数指针</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">6</span>, addPtr) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​函数指针作为返回值：根据我们以往编写函数的经验来看，返回函数指针的语法应该为</p><p><code>int(*)(int, int) getFunPtr(int choice)</code>，但是<strong>这样并不能通过编译</strong>。正确的语法为</p><p><code>int(* getFunPtr(int choice))(int, int)</code>，这样的写法非常反直觉，后面可以简化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout&lt;&lt; <span class="string">&quot;f1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f3</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;f3&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数指针作为函数返回值,(*函数声明)，可以看到与一般的函数写法不同</span></span><br><span class="line"><span class="built_in">int</span> (*<span class="built_in">getFuncPtr</span>(<span class="type">int</span> choice))(<span class="type">int</span>, <span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (choice == <span class="number">1</span>)<span class="keyword">return</span> &amp;f1;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (choice == <span class="number">3</span>)<span class="keyword">return</span> &amp;f3;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">int</span>(* addPtr)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line">    </span><br><span class="line">    addPtr = <span class="built_in">getFuncPtr</span>(<span class="number">1</span>); <span class="comment">//拿到函数指针</span></span><br><span class="line"><span class="built_in">addPtr</span>(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">//调用函数f1</span></span><br><span class="line"><span class="built_in">getFuncPtr</span>(<span class="number">3</span>)(<span class="number">2</span>,<span class="number">3</span>); <span class="comment">//也可以直接调用，最终调用f3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​函数指针的简化：</p><p>​可以看到，如果我们用<code>int(* addPtr)(int, int);</code>的语法声明一个函数指针，不仅可读性不强，而且作为函数返回值返回时更不方便。而且这样只能声明一个变量名为<code>addPtr</code>的函数指针变量，想声明多个还要写这样的代码。</p><p>​值得高兴的是，我们可以使用<code>typedef</code>或者<code>using</code>关键字简化函数指针的声明。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout&lt;&lt; <span class="string">&quot;f1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f3</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;f3&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这样就相当于声明了一个函数指针的类型AddFunPtr，可以用这个类型去声明函数指针变量</span></span><br><span class="line"><span class="comment">//下面两种写法是等价的</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*AddFunPtr)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>; <span class="comment">//使用typedef只能写(*name)</span></span><br><span class="line"><span class="keyword">using</span> AddFunPtr2 = <span class="built_in">int</span> (*)(<span class="type">int</span>, <span class="type">int</span>); <span class="comment">//使用using的话只能写(*)，这样写(*name)会编译失败</span></span><br><span class="line"><span class="comment">//AddFunPtr类型可以作为函数返回值</span></span><br><span class="line"><span class="function">AddFunPtr <span class="title">getFuncPtr2</span><span class="params">(<span class="type">int</span> choice)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (choice == <span class="number">1</span>)<span class="keyword">return</span> &amp;f1;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (choice == <span class="number">3</span>)<span class="keyword">return</span> &amp;f3;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//AddFunPtr类型可以作为参数类型</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, AddFunPtr fPtr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">fPtr</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//使用AddFunPtr类型声明其他函数指针变量</span></span><br><span class="line">    AddFunPtr p1 = &amp;f1;</span><br><span class="line"><span class="built_in">sum2</span>(<span class="number">1</span>, <span class="number">2</span>, p1);</span><br><span class="line">AddFunPtr p2 = <span class="built_in">getFuncPtr2</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="仿函数（函数对象）"><a href="#仿函数（函数对象）" class="headerlink" title="仿函数（函数对象）"></a>仿函数（函数对象）</h2><p>​仿函数本质上是通过重载<code>operator()</code>的类实现的函数对象。所以仿函数在作为函数参数或者返回值时传递或者返回的都是这个对象。而且由于我们是通过实现运算符重载，本质上还是一个对象，所以我们也可以在对象内部定义一下成员变量，使用成员变量记录一下状态。而且当该调用的性能接近普通函数调用，并且比直接声明函数指针要方便。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SF</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">SF</span>(<span class="type">int</span> v):<span class="built_in">x</span>(v) &#123;&#125;</span><br><span class="line">    <span class="comment">//每次调用会让x加一</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x++;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//传递的就是该类型的对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showSF</span><span class="params">(<span class="type">int</span> x, SF&amp; sf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sf</span>(x, x) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回的也是该类型的对象</span></span><br><span class="line"><span class="function">SF <span class="title">getSF</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">SF</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">SF <span class="title">sf1</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">//每次调用都让导致sf1的成员变量x加一</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sf1</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; sf<span class="number">1.</span>x &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sf1</span>(<span class="number">2</span>, <span class="number">2</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; sf<span class="number">1.</span>x &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sf1</span>(<span class="number">3</span>, <span class="number">2</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; sf<span class="number">1.</span>x &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sf1</span>(<span class="number">4</span>, <span class="number">2</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; sf<span class="number">1.</span>x &lt;&lt; std::endl; <span class="comment">//最终输出sf1.x为4</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">showSF</span>(<span class="number">1</span>, sf1);</span><br><span class="line">SF sf2 = <span class="built_in">getSF</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">sf2</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>​<code>Lambda</code>表达式是<strong>C++11</strong>引入的一种<strong>创建匿名函数对象</strong>的简洁方式，它极大地简化了函数对象的创建和使用。基本语法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其中[]里面是捕获列表；()里面是参数列表，如果没有参数可以省略；-&gt;后面的是返回类型，可以省略编译器自动推导；&#123;&#125;里面就是函数体</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//没有参数时可以省略()</span></span><br><span class="line">[capture]-&gt; return_type &#123; </span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用后置返回类型指明返回类型</span></span><br><span class="line">[capture](parameters) -&gt; return_type &#123; </span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不指明返回类型，编译器自动推导</span></span><br><span class="line">[capture](parameters)&#123; </span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最简单的lambda表达式(返回值省略，参数列表省略)</span></span><br><span class="line">[capture]&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//lambda简单使用</span></span><br><span class="line">    <span class="keyword">auto</span> lAdd = [](<span class="type">int</span> a, <span class="type">int</span> b)&#123;</span><br><span class="line">    std::cout &lt;&lt; a + b &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">//其他执行代码</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">lAdd</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="捕获列表"><a href="#捕获列表" class="headerlink" title="捕获列表"></a>捕获列表</h3><p>​捕获列表位于方括号 <code>[]</code> 中，决定了<code>lambda</code>表达式如何访问外部变量。捕获方式可以是值捕获、引用捕获，标准还规定能<strong>捕获的变量</strong>必须是一个<strong>自动存储类型</strong>。简单来说就是<strong>非静态的局部变量</strong>。</p><table><thead><tr><th align="left">捕获方式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>[]</code></td><td align="left">不捕获任何外部变量</td></tr><tr><td align="left"><code>[=]</code></td><td align="left">按值捕获所有外部变量</td></tr><tr><td align="left"><code>[&amp;]</code></td><td align="left">按引用捕获所有外部变量</td></tr><tr><td align="left"><code>[x, &amp;y]</code></td><td align="left">按值捕获x，按<strong>引用捕获y</strong></td></tr><tr><td align="left"><code>[=, &amp;x]</code></td><td align="left">默认按值捕获外部变量，但<strong>x按引用</strong>捕获</td></tr><tr><td align="left"><code>[&amp;, x]</code></td><td align="left">默认按引用捕获外部变量，但x按值捕获</td></tr><tr><td align="left"><code>[this]</code></td><td align="left">捕获当前类的this指针</td></tr></tbody></table><p>​捕获列表中的变量存在于两个作用域——<strong>lambda表达式定义的函数作用域</strong>以及lambda 表达式<strong>函数体的作用域</strong>，简单来说就是和这个lambda表达式定义时的同一个作用域和lambda函数体内部的作用域。</p><p>​根据上面的规则来说，如果我们将一个<strong>lambda表达式定义在全局作用域</strong>，那么lambda表达式的<strong>捕获列表必须为空</strong>。因为根据上面提到的规则，捕获列表的变量必须是一个自动存储类型，但是全局作用域并没有这样的类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> globalNum = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//捕获列表必须为空，因为全局作用域下的变量不符合捕获变量的要求</span></span><br><span class="line"><span class="keyword">auto</span> globalLambad = []() &#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> sNum = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> lam1 = [num]() &#123;&#125;;</span><br><span class="line">    <span class="comment">//下面写法否编译失败</span></span><br><span class="line"><span class="comment">//auto lam2 = [sNum]() &#123;&#125;; //sNum是静态变量，不符合要求</span></span><br><span class="line"><span class="comment">//auto lam3 = [globalNum]() &#123;&#125;; //1.globalNum不是局部变量；2.globalNum位于全局作用域，和lambad定义时不在同一个作用域</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//但是我们可以像普通函数那样在函数体内部直接使用全局变量或者可见的静态变量</span></span><br><span class="line">    <span class="keyword">auto</span> lam4 = [num]() &#123;</span><br><span class="line"><span class="type">int</span> a = sNum;</span><br><span class="line"><span class="type">int</span> b = globalNum;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//但非静态局部变量不能直接在函数体内部使用，必须通过捕获才可以</span></span><br><span class="line">    <span class="comment">//auto ff = [] &#123;</span></span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; b &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">//&#125;;</span></span><br><span class="line">    <span class="keyword">auto</span> ff1 = [b] &#123;</span><br><span class="line">    std::cout &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​前面已经说过，捕获列表可以按值捕获和按值捕获，如果捕获多个变量，变量之间使用逗号隔开即可。</p><p>​捕获的变量时默认lambda是一个常量函数（类似于<code>const</code>修饰的成员函数，捕获的变量类似于类的成员变量），所以<strong>按值捕获时****不能在内部修改这些变量的值</strong>，所以编译会失败。</p><p>​但是按<strong>引用捕获</strong>时，捕获变量实际上是一个引用，我们在函数体内改变的并不是引用本身，而是引用的值，所以<strong>编译会通过</strong>。因为捕获的是外部变量的引用，所以<code>lambda</code>函数体内修改值也会影响外部变量的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">111</span>, <span class="type">int</span> y = <span class="number">222</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//按值捕获，把x和y的值复制一份到lambda内部的变量中</span></span><br><span class="line">    <span class="keyword">auto</span> f1 = [x, y] &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="comment">//按引用捕获，把x和y的引用给lambda内部的变量中</span></span><br><span class="line">    <span class="keyword">auto</span> f2 = [&amp;x, &amp;y] &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//捕获的变量时默认lambda是一个常量函数，类似于const修饰的成员函数，不能在内部修改内部变量的值，所以编译会失败</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    auto f3 = [x, y] &#123;</span></span><br><span class="line"><span class="comment">        x++;</span></span><br><span class="line"><span class="comment">        y++;</span></span><br><span class="line"><span class="comment">        &#125;;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//按引用捕获时，捕获变量实际上是一个引用，我们在函数体内改变的并不是引用本身，而是引用的值，所以编译会通过</span></span><br><span class="line">    <span class="keyword">auto</span> f4 = [&amp;x, &amp;y] &#123;</span><br><span class="line">        x++;</span><br><span class="line">        y++;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​虽然<code>lambda</code>默认为一个常量函数，但是使用<code>mutable</code>说明符可以<strong>移除<code>lambda</code>表达式的常量性</strong>。也就是说<code>lambda</code>使用<code>mutable</code>修饰后，就能在内部修改按值捕获的变量的值。但由于按值捕获的实际上就是复制了一份，所以内部的修改并不会影响外部的值。但是要注意<code>lambda</code>表达式使用说明符修饰以后，参数列表必须写上，也就是<code>()</code>必须加上，哪怕没有参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = <span class="number">111</span>, y = <span class="number">222</span>;</span><br><span class="line">    <span class="comment">//使用mutable修饰后可以修改捕获的值了，但参数列表的()必须写上，且由于是复制的数据，内部修改无法影响外部</span></span><br><span class="line">    <span class="keyword">auto</span> f5 = [x, y]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">        x++;</span><br><span class="line">        y++;</span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="comment">//引用捕获时，内部的修改会影响外部的值</span></span><br><span class="line">    <span class="keyword">auto</span> f5 = [&amp;x, &amp;y]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">        x++;</span><br><span class="line">        y++;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>​不难发现，<code>lambda</code>表达式与<strong>函数对象（仿函数）<strong>非常相似，但事实上<code>lambda</code>的实现原理也正是</strong>通过函数对象来实现</strong>的。</p><p>​首先创建一个简单的按值捕获的<code>lambda</code>表达式为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">10</span>, j = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//按值捕获</span></span><br><span class="line"><span class="keyword">auto</span> foo1 = [i, j]() &#123;</span><br><span class="line">    <span class="keyword">return</span> i + j;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>​最后编译器处理后产生的中间代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">  <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">  <span class="type">int</span> j = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//按值捕获</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">__lambda_6_15</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">//如果lambda使用utable修饰，const会去掉</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="comment">/*constexpr */</span> <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> i + j;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    __lambda_6_15(<span class="type">int</span> &amp; _i, <span class="type">int</span> &amp; _j)</span><br><span class="line">    :i&#123;_i&#125;,j&#123;_j&#125;</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">  &#125;;</span><br><span class="line"><span class="comment">//按引用捕获</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">__lambda_6_15</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">     <span class="comment">//如果lambda使用utable修饰，const会去掉</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="comment">/*constexpr */</span> <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> i + j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//引用捕获时，内部的成员变量变为了引用类型</span></span><br><span class="line">    <span class="type">int</span> &amp; i;</span><br><span class="line">    <span class="type">int</span> &amp; j;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    __lambda_6_15(<span class="type">int</span> &amp; _i, <span class="type">int</span> &amp; _j)</span><br><span class="line">    : i&#123;_i&#125;</span><br><span class="line">    , j&#123;_j&#125;</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  __lambda_6_15 foo1 = __lambda_6_15&#123;i, j&#125;;</span><br></pre></td></tr></table></figure><p>​通过中间代码不难发现，我们创建<code>lambda</code>表达式的语句，编译器自动替换为了<strong>创建一个函数对象</strong>，而我们最终拿到的<code>foo1</code>也就是一个函数对象。</p><p>​并且可以看到我们捕<strong>获的值</strong>都会在函数对象内部创建<strong>相应的成员变量接收</strong>，并且重载运算符<code>()</code>函数也被标记为了<code>const</code>，这就是为什么不能在函数体内部修改按值捕获的变量的原因。</p><p>​所以流程如下，首先会创建一个函数对象，内部的成员变量跟捕获列表的一一对应（如果按值捕获成员变量就是对于应的普通类型，按引用捕获就是对应的引用类型）。然后使用外部的捕获变量创建并初始化一个函数对象，函数体内部对捕获变量的读取和修改操作都是对函数对象内部的成员变量做的，所以普通的按值捕获变量无法在函数体内被修改，即使用mutable修饰后修改的值也无法影响外部的变量，因为修改的只是函数对象内部的成员变量。（按引用捕获的变量则不受这些限制）。</p><p>​所以，在某种程度上来说，<code>lambda</code>表达式是<strong>C++11</strong>给我们提供的一块<strong>语法糖</strong>而已，可以让我们更方便的创建一个匿名的函数对象。</p><h2 id="std-function"><a href="#std-function" class="headerlink" title="std::function"></a>std::function</h2><p>​<code>std::function</code>是 <strong>C++11</strong>引入的一个通用函数包装器，定义在 <code>&lt;functional&gt;</code>头文件中。它可以存储、复制和调用任何可调用对象（Callable Object），包括：</p><ul><li><strong>普通函数</strong></li><li><strong>Lambda 表达式</strong></li><li><strong>仿函数（Functor，即重载了 <code>operator()</code>的类）</strong></li><li><strong>成员函数（需结合 <code>std::bind</code>使用）</strong></li><li><strong>函数指针</strong></li></ul><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//lambda表达式</span></span><br><span class="line"><span class="keyword">auto</span> add = [](<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//仿函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">adder</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">math</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">multi</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//接收普通函数</span></span><br><span class="line">    std::function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f1 = print;</span><br><span class="line">    <span class="built_in">f1</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//接收一个函数指针</span></span><br><span class="line">    <span class="keyword">auto</span> ff = &amp;print;</span><br><span class="line">    std::function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;ff1 = ff;</span><br><span class="line">    <span class="built_in">ff1</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//接收lambda表达式</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f2 = add;</span><br><span class="line">    <span class="built_in">f2</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//接收仿函数</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f3 = <span class="built_in">adder</span>();</span><br><span class="line">    <span class="built_in">f3</span>(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//接受类成员函数(要使用std::bind才可以接收)</span></span><br><span class="line">    math m;</span><br><span class="line">    std::function&lt;<span class="type">float</span>(<span class="type">float</span>, <span class="type">float</span>)&gt; f4 = </span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;math::multi, &amp;m, std::placeholders::_1, std::placeholders::_2);</span><br><span class="line">    <span class="built_in">f4</span>(<span class="number">1.0f</span>, <span class="number">2.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​不难发现和函数指针很类似，但是函数指针无法接收仿函数、捕获状态的<code>lambda</code>表达式，而<code>std::function</code>却都可以接受。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">addfn</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没有状态的lambda表达式() (没有捕获外部的变量)</span></span><br><span class="line"><span class="keyword">auto</span> add = [](<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//有状态的lambda表达式() (设置了捕获列表，有可能捕获外部变量)</span></span><br><span class="line"><span class="keyword">auto</span> addc = [=](<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//仿函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">adder</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个函数指针</span></span><br><span class="line"><span class="keyword">auto</span> ffptr = &amp;addfn;</span><br><span class="line"></span><br><span class="line"><span class="comment">//没有状态的lambda，函数指针可以接收</span></span><br><span class="line">ffptr = add;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有状态的lambda，函数指针无法接收，会编译错误</span></span><br><span class="line"><span class="comment">//ffptr = addc;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数指针无法接收仿函数</span></span><br><span class="line">    adder aer;</span><br><span class="line"><span class="comment">//ffptr = aer;</span></span><br><span class="line"><span class="comment">//ffptr = &amp;aer;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​可以看到<code>std::function</code>的功能非常强大，我们只需要指定要接受的函数的返回值和参数列表即可接收任何符合要求的可调用对象。语法也较为简单<code>std::function&lt;返回类型(参数类型列表)&gt; 变量名;</code> 那么代价是什么呢？虽然std::function功能强大，但由于内部的实现，所以会带来一些开销。</p><p>​使用了<code>std::function</code>作为参数可以很方便的让我们使用回调函数，因为不论是什么可调用对象，都能够被接收。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handle</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;APP:&quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//使用std::function实现回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handle</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; callback)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> res = a + b;</span><br><span class="line"><span class="built_in">callback</span>(res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Handler</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//回调可以是类的成员函数</span></span><br><span class="line">    App app;</span><br><span class="line">    <span class="built_in">handle</span>(<span class="number">1</span>, <span class="number">2</span>, std::<span class="built_in">bind</span>(&amp;App::handle, &amp;app, std::placeholders::_1));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回调可以是一个仿函数</span></span><br><span class="line">    Handler h;</span><br><span class="line">    <span class="built_in">handle</span>(<span class="number">3</span>, <span class="number">3</span>, h);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回调可以是一个lambda表达式</span></span><br><span class="line">    <span class="built_in">handle</span>(<span class="number">2</span>, <span class="number">2</span>, [](<span class="type">int</span> a) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Lambda:&quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回调可以是一个函数指针</span></span><br><span class="line">    <span class="built_in">handle</span>(<span class="number">2</span>, <span class="number">3</span>, show);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><h4 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h4><h4 id="小对象优化-Small-Object-Optimization，SOO"><a href="#小对象优化-Small-Object-Optimization，SOO" class="headerlink" title="小对象优化(Small Object Optimization，SOO)"></a>小对象优化(Small Object Optimization，SOO)</h4><h4 id="关键成员函数"><a href="#关键成员函数" class="headerlink" title="关键成员函数"></a>关键成员函数</h4><h2 id="std-bind"><a href="#std-bind" class="headerlink" title="std::bind"></a>std::bind</h2><h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><p>​<code>std::bind</code>是 <strong>C++11</strong> 引入的一个函数适配器，定义在 <code>&lt;functional&gt;</code>头文件中，用于 <strong>绑定函数参数</strong> 或 <strong>调整函数调用方式</strong>。它可以将一个可调用对象（函数、<code>Lambda</code>、成员函数等）与<strong>部分参数绑定</strong>，返回一个新的可调用对象。</p><p>​<code>std::bind</code>将可调用对象与其参数一起进行绑定，绑定后的结果可以使用<code>std::function</code>保存。<code>std::bind</code>主要有以下两个作用：</p><ul><li>将可调用对象和其参数绑定成一个仿函数；</li><li>只绑定部分参数，减少可调用对象传入的参数。</li></ul><p>基本语法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> bound_func = std::<span class="built_in">bind</span>(</span><br><span class="line">    original_function,    <span class="comment">// 要绑定的函数（或成员函数、函数对象）</span></span><br><span class="line">    bound_arguments...    <span class="comment">// 绑定的参数（可以是值、占位符或嵌套绑定）</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><ol><li>绑定普通函数</li></ol><p>​绑定普通函数时，<strong>第一个参数为要绑定的函数</strong>，当传递一个函数名作为实参时，会转换为函数指针，所以第一个参数写<code>sum</code>和<code>&amp;sum</code>是等价的。后面的参数就是我们要绑定的参数，如果填入变量或者具体的值，<strong>该位置就会和对应位置的形参绑定</strong>，也可以用<code>std::placeholders::_i</code>占位符，等待外界调用的时候传入参数到占位符位置。（绑定的参数连同占位符的数量要和绑定的函数一致，否则调用返回的可调用对象时会报错）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//auto f1 = std::bind(sum, 10, std::placeholders::_1); 这两种写法是等价的</span></span><br><span class="line">    <span class="keyword">auto</span> f1 = std::<span class="built_in">bind</span>(&amp;show, <span class="number">10</span>, std::placeholders::_1);</span><br><span class="line">    <span class="built_in">f1</span>(<span class="number">2</span>); <span class="comment">//输出a:10 b:2</span></span><br><span class="line">    <span class="keyword">auto</span> f2 = std::<span class="built_in">bind</span>(&amp;show, std::placeholders::_1, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">f2</span>(<span class="number">2</span>); <span class="comment">//输出a:2 b:10</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> f3 = std::<span class="built_in">bind</span>(&amp;sum, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>); <span class="comment">//这样写会编译通过</span></span><br><span class="line">    <span class="comment">//f3(); //调用这个返回的可调用对象时会报错，因为参数列表和绑定的函数不匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>绑定一个成员函数</li></ol><p>​<code>std::bind</code>绑定<strong>类成员函数</strong>时，第一个参数表示对象的成员函数（公有成员函数）的指针，第二个参数表示该实例化对象的地址，后面的就是要绑定的参数。其中绑定成员函数时，第一个参数要显示指明<code>&amp;Base::fun</code>，因为编译器<strong>不会将对象的成员函数隐式转换成函数指针</strong>，这一步可以理解为要绑定的是哪个类里面的哪个函数。第二个参数是说明具体是哪一个对象的函数，把该对象的地址传进来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PublicShow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Base a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">StaticShow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Base Static a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//只有公有的成员函数才能被绑定</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrivateShow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Base a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base b1;</span><br><span class="line">    <span class="comment">//Base::PublicShow前没有显示加上&amp;，直接编译失败</span></span><br><span class="line">    <span class="comment">//auto f4 = std::bind(Base::PublicShow, &amp;b1, 666, std::placeholders::_1);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//没有传入实例对象的地址，调用f4时编译失败</span></span><br><span class="line">    <span class="comment">//auto f4 = std::bind(&amp;Base::PublicShow, 666, std::placeholders::_1);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> f4 = std::<span class="built_in">bind</span>(&amp;Base::PublicShow, &amp;b1, <span class="number">666</span>, std::placeholders::_1);</span><br><span class="line">    <span class="built_in">f4</span>(<span class="number">111</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//静态成员函数也可以绑定，但是由于是静态函数，绑定时不能传入实例化对象的地址了</span></span><br><span class="line">    <span class="keyword">auto</span> f5 = std::<span class="built_in">bind</span>(&amp;Base::StaticShow, <span class="number">666</span>, std::placeholders::_1);</span><br><span class="line">    <span class="built_in">f5</span>(<span class="number">111</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>绑定引用参数</li></ol><p>​std::bind绑定参数默认都是按值绑定的，也就是会把值复制到可调用对象里。如果向绑定一个引用的话，必须使用**使用 <code>std::ref</code>(可变引用)或 <code>std::cref</code>(常量引用)**显示绑定引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span>&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a = <span class="number">999</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> v = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//默认按值绑定，调用f6后不会影响v的值</span></span><br><span class="line">    <span class="keyword">auto</span> f6 = std::<span class="built_in">bind</span>(modify, v);</span><br><span class="line">    <span class="built_in">f6</span>();</span><br><span class="line">    std::cout &lt;&lt; v &lt;&lt; std::endl; <span class="comment">//输出还是10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用f7会提示编译失败，因此cref表面为常量引用，不可修改</span></span><br><span class="line">    <span class="comment">//auto f7 = std::bind(modify, std::cref(v));</span></span><br><span class="line">    <span class="comment">//f7();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用std::ref显示引用绑定，调用f8后会修改v的值</span></span><br><span class="line">    <span class="keyword">auto</span> f8 = std::<span class="built_in">bind</span>(modify, std::<span class="built_in">ref</span>(v));</span><br><span class="line">    <span class="built_in">f8</span>();</span><br><span class="line">    std::cout &lt;&lt; v &lt;&lt; std::endl; <span class="comment">//输出为999</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><code>std::placeholder::_i</code>占位符</li></ol><p>​使用<code>std::bind</code>绑定参数时，可以直接绑定一个变量或值，也可以使用<code>std::placeholder::_i</code>占位符表面该位置的形参等外界调用时传入，其中<code>_i</code>表示该位置的值为调用时传入的实参的第<code>i</code>个参数的值。这样就说明了，我们调用时传入的实参至少要为<code>i</code>个，否则会编译失败。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">showAll</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; c:&quot;</span> &lt;&lt; c &lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> f = std::<span class="built_in">bind</span>(showAll, <span class="number">1</span>, <span class="number">2</span>, std::placeholders::_3);</span><br><span class="line">    <span class="comment">//f(10); 编译失败，因为std::placeholders::_3指明了接收实参列表的第三个，但是只传入了一个</span></span><br><span class="line">    <span class="comment">//f(10, 20); 编译失败，因为std::placeholders::_3指明了接收实参列表的第三个，但是只传入了两个</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//编译成功，最终std::placeholders::_3占位符位置的值为3</span></span><br><span class="line">    <span class="built_in">f</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">3</span>); <span class="comment">//输出为a:1 b:2 c:3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​知道了占位符的作用后，我们也可以调用时改变传入实参的顺序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">showAll</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; c:&quot;</span> &lt;&lt; c &lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//第一个占位符表示为传入的第二个实参，第二个表示传入的第一个实参，迪桑表示传入的第三个实参</span></span><br><span class="line">    <span class="keyword">auto</span> f1 = std::<span class="built_in">bind</span>(showAll, std::placeholders::_2, std::placeholders::_1, std::placeholders::_3);</span><br><span class="line">    <span class="comment">//经过这样处理后，相当于调用的是showAll(2, 1, 3)</span></span><br><span class="line">    <span class="built_in">f1</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">//输出为a:2 b:1 c:3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="std-initializer-list"><a href="#std-initializer-list" class="headerlink" title="std::initializer_list"></a>std::initializer_list</h1><h2 id="变量初始化方法"><a href="#变量初始化方法" class="headerlink" title="变量初始化方法"></a>变量初始化方法</h2><p>​在没有列表初始化之前，在C++中可以使用 <code>()</code> 和 <code>=</code> 对变量进行初始化操作。可以看到使用等号和小括号的效果是一样的，因为使用等号初始化时也是隐式调用了对应的构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">C</span>(<span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(C temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a1 = <span class="number">10</span>; <span class="comment">//使用等号拷贝初始化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">a2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//使用小括号直接初始化</span></span><br><span class="line"></span><br><span class="line">C c1 = <span class="number">10</span>; <span class="comment">//使用等号拷贝初始化</span></span><br><span class="line"><span class="function">C <span class="title">c2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//使用小括号直接初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">8</span>); <span class="comment">//拷贝初始化，传入8，隐式调用构造函数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用列表初始化"><a href="#使用列表初始化" class="headerlink" title="使用列表初始化"></a>使用列表初始化</h2><p>​C++11标准引入了列表初始化，它使用大括号<code>{}</code>对变量进行初始化。列表初始化在支持隐式调用多参数的构造函数，所以**{1, 2}<strong>可以</strong>隐式调用<strong>构造函数<code>B(int a, int b)</code>创建了</strong>B**的实例对象。如果不希望隐式调用，可以给对应构造函数前加上关键字<code>explicit</code>，表面该构造函数不能隐式调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">C</span>(<span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">B</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(B temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t1 = &#123; <span class="number">10</span> &#125;; <span class="comment">//拷贝初始化</span></span><br><span class="line"><span class="type">int</span> t2&#123; <span class="number">10</span> &#125;; <span class="comment">//直接初始化</span></span><br><span class="line"></span><br><span class="line">C cc1 = &#123; <span class="number">10</span> &#125;; <span class="comment">//拷贝初始化</span></span><br><span class="line">C cc2&#123; <span class="number">10</span> &#125;; <span class="comment">//直接初始化</span></span><br><span class="line"></span><br><span class="line">B b1 = &#123; <span class="number">1</span>, <span class="number">2</span> &#125;; <span class="comment">//拷贝初始化</span></span><br><span class="line">B b2&#123; <span class="number">1</span>, <span class="number">2</span> &#125;; <span class="comment">//直接初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">foo</span>(&#123;<span class="number">1</span>,<span class="number">2</span>&#125;); <span class="comment">//传入&#123;1, 2&#125;，隐式调用B(1,2)构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​在初始化列表出现之前，我们可以使用大括号对数组初始化，但无法对vector，list，map这些标准库容器使用大括号初始化，只能遍历一个个赋值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用大括号对数组初始化</span></span><br><span class="line"><span class="type">int</span> arr1[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">int</span> arr2[][<span class="number">2</span>] = &#123; &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="comment">//c++11之前不允许大括号对标准库容器初始化</span></span><br><span class="line"><span class="comment">//std::vector&lt;int&gt;v = &#123; 1, 2, 3 &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化列表出现以后，可以使用大括号对标准库容器初始化</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;v1 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="comment">//std::vector&lt;int&gt;v2&#123; 1, 2, 3 &#125;;</span></span><br><span class="line"></span><br><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt;m1 = &#123; &#123;<span class="string">&quot;string&quot;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&quot;sss&quot;</span>, <span class="number">2</span>&#125; &#125;;</span><br><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt;m2&#123; &#123;<span class="string">&quot;string&quot;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&quot;sss&quot;</span>, <span class="number">2</span>&#125; &#125;;</span><br></pre></td></tr></table></figure><h2 id="std-initializer-list详解"><a href="#std-initializer-list详解" class="headerlink" title="std::initializer_list详解"></a>std::initializer_list详解</h2><p>​标准容器之所以能够支持列表初始化，离不开编译器支持的同时，它们自己也必须满足一个条件：支持<code>std::initializer_list</code>为<strong>形参的构造函数</strong>。</p><p>​下面是<code>std::initializer_list</code>的简化实现代码：</p><p>​可以看到，其构造函数是传入两个指针，一个指向起始位置，一个指向结束位置，而<code>begin</code>和<code>end</code>函数返回的也都是**<code>const</code>修饰的原始指针**。标准库容器提供一个形参为<code>std::initializer_list</code>的构造函数，这样使用大括号赋值时就会调用该构造函数，容器内部再使用初始化列表的<code>begin</code>和<code>end</code>函数拿到指针进行初始化赋值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Elem</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">initializer_list</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> value_type      = _Elem;</span><br><span class="line">    <span class="keyword">using</span> size_type       = <span class="type">size_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">initializer_list</span><span class="params">()</span> <span class="keyword">noexcept</span> : _First(nullptr), _Last(nullptr) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">initializer_list</span><span class="params">(<span class="type">const</span> _Elem* _First_arg, <span class="type">const</span> _Elem* _Last_arg)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">        : _First(_First_arg), _Last(_Last_arg) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">const</span> _Elem* <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _First;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">const</span> _Elem* <span class="title">end</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _Last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(_Last - _First);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> _Elem* _First;</span><br><span class="line">    <span class="type">const</span> _Elem* _Last;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​我们的自定义类在实现一个接收形参为<code>std::initializer_list</code>的构造函数后，也可以直接使用大括号进行初始化，并且可以接收任意数量的同类型参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">C</span>(<span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C(std::initializer_list&lt;int&gt; list)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">//返回的是const 原始指针</span></span><br><span class="line"><span class="comment">for (const int* item = list.begin(); item != list.end();++item) &#123;</span></span><br><span class="line"><span class="comment">std::cout &lt;&lt; *item &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">std::cout &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">C</span>(std::initializer_list&lt;<span class="type">int</span>&gt; list)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//返回的是const 原始指针</span></span><br><span class="line">        <span class="comment">//输出每个地址之间的间隔（以字节为单位）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span>* item = list.<span class="built_in">begin</span>(); item != list.<span class="built_in">end</span>();++item) &#123;</span><br><span class="line"><span class="keyword">if</span> (pre == <span class="literal">nullptr</span>)pre = item;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">                <span class="comment">//最后输出的都为4字节，表示一个int类型的大小，说明地址都是连续的</span></span><br><span class="line">std::cout &lt;&lt; (<span class="type">uint8_t</span>)item - (<span class="type">uint8_t</span>)pre &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">pre = item;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    C c = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​最后执行代码后发现形参中接收到的初始化列表里各个地址都是连续的，这说明当我们使用大括号初始化时，编译器很可能先创建了一个数组，然后再用这个数组创建<code>std::initializer_list</code>，最后调用对用的构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先根据&#123;&#125;里面的值创建一个数组</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> __a[<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="comment">//再把数组的起始指针传递给initializer_list构造一个初始化列表对象传递给对应的构造函数</span></span><br><span class="line"><span class="function">C <span class="title">c</span><span class="params">(std::initializer_list&lt;<span class="type">int</span>&gt;(__a, __a<span class="number">+3</span>))</span></span>;</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="隐式缩窄转换"><a href="#隐式缩窄转换" class="headerlink" title="隐式缩窄转换"></a>隐式缩窄转换</h3><p>​在 C++ 中，<strong>隐式缩窄转换</strong>（implicit narrowing conversion）指的是在隐式类型转换过程中，目标类型无法完全容纳源类型的值，可能导致数据丢失或精度损失的情况。简单来说就是从一个<strong>范围较大或精度较高</strong>的类型<strong>转换</strong>为<strong>范围较小或精度较低</strong>的类型。</p><p>​隐式缩窄转换在传统变量初始化时是没有问题的，编译器不会报错，最多是给出一个转换可能会损失精度的警告。但是如果使用<strong>初始化列表的形式是不允许隐式缩窄转换</strong>的，会在<strong>编译时就报错</strong>。下面是出现隐式缩窄转换的操作。</p><p>​符合转换的转换源<strong>首先一定是常量或者常量表达式</strong>，然后接受的<strong>目标类型要能准确表示这个值</strong>，其次就是这<strong>两种类型对于这个值能够相互准确的转换(整形转浮点型才会出现这种问题)</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//--------------------------------------1.从浮点类型转换整数类型(浮点数可表示范围比整型大)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> f1 = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="type">int</span> x1 = f1; <span class="comment">// 编译成功，传统变量初始化支持隐式缩窄转换</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//int x2&#123; f1 &#125;; //编译失败，列表初始化不支持支持隐式缩窄转换</span></span><br><span class="line">    <span class="type">int</span> x3&#123; (<span class="type">int</span>)f1 &#125;; <span class="comment">//这种写法也可以通过编译</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> d1 = <span class="number">1.0</span>;</span><br><span class="line">    <span class="type">int</span> x1 = d1; <span class="comment">// 编译成功</span></span><br><span class="line">    <span class="comment">//int x2&#123; d1 &#125;; // 编译失败</span></span><br><span class="line">    <span class="type">int</span> x3&#123; (<span class="type">int</span>)d1 &#125;; <span class="comment">// 编译成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------------------2.从long double转换到double或float；或者从double转换到float。(但是当转换源是一个常量表达式且转换后的值在目标类型的可表示范围内，就允许列表初始化进行隐式缩窄转换)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> ld = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> d1 = ld;</span><br><span class="line">    <span class="comment">//double d2&#123; ld &#125;; //编译不通过</span></span><br><span class="line">    <span class="type">float</span> f1 = ld;</span><br><span class="line">    <span class="comment">//float f2&#123; ld &#125;; //编译不通过</span></span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> d3 = <span class="number">1.0</span>;</span><br><span class="line">    <span class="type">float</span> f3 = d3;</span><br><span class="line">    <span class="comment">//float f3&#123; d3 &#125;; //编译不通过</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> cd1 = <span class="number">1.0</span>;</span><br><span class="line">    <span class="type">float</span> f4 = cd1;</span><br><span class="line">    <span class="type">float</span> f5&#123; cd1 &#125;; <span class="comment">//编译通过，因为cd是常量，且1.0 在float可表示范围内</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> cd2 = std::numeric_limits&lt;<span class="type">double</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">    <span class="type">float</span> f6 = cd2; <span class="comment">//虽然对于float溢出了，但是会截断，编译仍然通过</span></span><br><span class="line">    <span class="comment">//float f7&#123; cd2 &#125;; //编译不通过，虽然cd是常量，但是显然double的最大值不在float可表示范围内</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------------------3.从整数类型或非强枚举类型转换到浮点类型(但是当转换源是一个常量表达式且转换后的值在目标类型的可表示范围内，且这个值能够再从目标值转换回原始类型的原始值时，就允许列表初始化进行隐式缩窄转换)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x1 = <span class="number">16777217</span>; </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x2 = <span class="number">100</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//float f&#123; x &#125;; //编译失败，要想列表初始化转换为float，首先要是常量或者常量表达式</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//float f1&#123; x1 &#125;; //编译失败，这个数在float中无法准确存储，如果转为float后再转回int是不相等的</span></span><br><span class="line">    <span class="type">float</span> f2&#123; x2 &#125;; <span class="comment">//编译成功，这个数在float中可以准确存储，转为float后再转回int是相等的</span></span><br><span class="line">    <span class="comment">//float f3&#123; 16777217 &#125;; //编译失败，这个数在float中无法准确存储，如果存入float后再转回int是不相等的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------------------4.从整数类型或非强枚举类型转换到不能代表所有原始类型值的整数类型(long-&gt;int,int-&gt;unsigned int等)。但是如果转换源是一个常量表达式，其值在转换之后能够适合目标类型，就允许列表初始化进行隐式缩窄转换</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x1 = <span class="number">1</span> &lt;&lt; <span class="number">10</span>; <span class="comment">// 1左移十位，也就是2^10</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x2 = <span class="number">10</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x3 = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//char c1&#123; x1 &#125;; //编译失败,char类型八位，无法表示1024</span></span><br><span class="line">    <span class="type">char</span> c2&#123; x2 &#125;; <span class="comment">//编译成功,可以表示10</span></span><br><span class="line">    <span class="type">char</span> c3&#123; x3 &#125;; <span class="comment">//编译成功,可以表示-1</span></span><br><span class="line">    <span class="comment">//unsigned char c4&#123; x3 &#125;; //编译失败,unsigned char无法表示负数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ui1&#123; x1 &#125;; <span class="comment">//编译成功,unsigned int可以表示1024</span></span><br><span class="line">    <span class="comment">//unsigned int ui2&#123; x3 &#125;; //编译失败,unsigned int无法表示负数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="列表初始化优先级"><a href="#列表初始化优先级" class="headerlink" title="列表初始化优先级"></a>列表初始化优先级</h3><p>​当类的构造函数接受一个<code>initializer_list</code>为形参时，那么他的<strong>优先级就会大于</strong>能匹配上的普通的构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> a)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">float</span> a, <span class="type">float</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> std::string&amp; a)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(std::initializer_list&lt;<span class="type">int</span>&gt; lists)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;initializer_list&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t = &#123; <span class="number">1</span>, <span class="number">2</span> &#125;; <span class="comment">//隐式调用列表初始化构造函数</span></span><br><span class="line">    Test t2 = &#123; <span class="number">1</span> &#125;; <span class="comment">//隐式调用列表初始化构造函数</span></span><br><span class="line">    </span><br><span class="line">    Test t3 = std::<span class="built_in">string</span>(<span class="string">&quot;123&quot;</span>); <span class="comment">//隐式普通构造函数</span></span><br><span class="line">    <span class="comment">//虽然我们传入的是float类型，显然想让他隐式调用Test(float a, float b)，但是他却调用初始化列表的，而且想进行隐式转换，但是这属于隐式缩窄转换，是不允许的，所以会报错</span></span><br><span class="line">    <span class="comment">//Test t3 = &#123;1.0f, 1.0f&#125;; 隐式调用列表初始化构造函数，但是不允许隐式缩窄转换，所以会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h1><h2 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h2><p>​对于一个有多个参数的类来说，我们可以需要编写不同版本的构造函数，以适应各种初始化参数的情况，像下面的代码那样。而且这么多构造函数的初始化操作的代码也都一样，虽然我们可以编写一个<code>CommonInit</code>来执行最终的成员初始化和初始化逻辑，但是这样仍然也会存在大量的代码冗余，不便于后期的维护。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">X1</span>() &#123; <span class="built_in">CommonInit</span>(<span class="number">0</span>, <span class="number">0.</span>); &#125;</span><br><span class="line"><span class="built_in">X1</span>(<span class="type">int</span> a) &#123; <span class="built_in">CommonInit</span>(a, <span class="number">0.</span>); &#125;</span><br><span class="line"><span class="built_in">X1</span>(<span class="type">double</span> b) &#123; <span class="built_in">CommonInit</span>(<span class="number">0</span>, b); &#125;</span><br><span class="line"><span class="built_in">X1</span>(<span class="type">int</span> a, <span class="type">double</span> b) &#123; <span class="built_in">CommonInit</span>(a, b); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CommonInit</span><span class="params">(<span class="type">int</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_A = a;</span><br><span class="line">m_B = b;</span><br><span class="line"><span class="comment">//执行初始化操作</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="type">double</span> m_B;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​为了合理复用构造函数来减少代码冗余，<strong>C++11</strong>标准支持了<strong>委托构造函数</strong>：某个类型的<strong>一个构造函数（委托构造函数）<strong>可以</strong>委托同类型的另一个构造函数（代理构造函数）<strong>对对象</strong>进行初始化</strong>。也就是说委托构造函数可以作为一个老板，雇佣另一个构造函数执行初始化。委托构造函数会将控制权交给代理构造函数，在代理构造函数执行完之后，再执行委托构造函数的主体。</p><p>​委托构造函数的语法非常简单，只需要在委托构造函数的初始化列表中调用代理构造函数即可。<code>X(int a): X(a, 0) {}</code></p><p>​如下面的代码所示，可以看到<code>X()</code>、<code>X(int a)</code>、<code>X(double b)</code>分别作为委托构造函数将控制权交给了代理构造函数<code>X(int a, double b)</code>。这样我们就可以编写一个接受所有初始化值的通用构造函数来初始化变量并执行初始化操作，其他的构造函数通过委托调用这一个通用的构造函数即可，这样就能很大程度的减少代码冗余。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>() : <span class="built_in">X</span>(<span class="number">0</span>, <span class="number">0.</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">X</span>(<span class="type">int</span> a) : <span class="built_in">X</span>(a, <span class="number">0.</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">X</span>(<span class="type">double</span> b) : <span class="built_in">X</span>(<span class="number">0</span>, b) &#123;&#125;</span><br><span class="line">    <span class="built_in">X</span>(<span class="type">int</span> a, <span class="type">double</span> b) : <span class="built_in">a_</span>(a), <span class="built_in">b_</span>(b) &#123; <span class="built_in">CommonInit</span>(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CommonInit</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//执行初始化操作</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> a_;</span><br><span class="line">    <span class="type">double</span> b_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​委托构造函数的执行顺序是：先执行代理构造函数，再执行委托构造函数的函数体。如果是多层的委托，就会像递归那样先调用最底层的代理构造函数，再一层层向上返回执行对应的委托构造函数的函数体。下面用一段代码演示一下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">X2</span>() : <span class="built_in">X2</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Constructor 1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">X2</span>(<span class="type">int</span> a) : <span class="built_in">X2</span>(a, <span class="number">1.0f</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Constructor 2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">X2</span>(<span class="type">int</span> a, <span class="type">float</span> b) </span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Constructor 3&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X2 x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​这段代码的构造函数委托调用逻辑如下：</p><pre class="mermaid">graph TD    A["X2()"]    A -->|委托| B["X2(int)"]    B -->|委托| C["X2(int, float)"]</pre><p>​最终的输出结果如下，可以看到执行顺序和代理顺序是相反的，类似于递归那种。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Constructor <span class="number">3</span></span><br><span class="line">Constructor <span class="number">2</span></span><br><span class="line">Constructor <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h2><p>1．每个构造函数都可以委托另一个构造函数为代理。这个比较好理解，每个构造函数可以委托别的构造函数干活，也可以被其他构造函数委托。简单来说就是你能找别人干活，自己也要帮别人干活才可以。</p><p>2．<strong>不要递归循环委托！</strong>。只能单向的递归委托，否则就会陷入递归循环（这也是编写递归函数要注意的点）。这种递归循环编译器有可能不会报错，最终运行时很可能会出现调用栈内存用完而溢出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//递归循环委托，X3()委托X3(int)，但是X3(int)又委托X3()，最终无限循环导致栈溢出</span></span><br><span class="line"><span class="built_in">X3</span>() : <span class="built_in">X3</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Constructor 1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">X3</span>(<span class="type">int</span> a) : <span class="built_in">X3</span>()</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Constructor 2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><pre class="mermaid">graph TD    A["X3()"]    A -->|委托| B["X3(int)"]    B -->|委托| A["X3()"]</pre><p>3．如果一个构造函数为委托构造函数，那么其<strong>初始化列表</strong>里<strong>就不能对数据成员和基类进行初始化</strong>。简单来说，如果委托构造函数委托一个代理构造函数初始化，就说明把初始化操作交给了代理构造函数，对<strong>成员变量和基类的初始化就交给代理构造函数完成</strong>。（这里只是规定了委托构造函数的初始化列表里不能再初始化成员变量了，但是在他的函数体内部仍然可以对成员变量赋值）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X4</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//委托构造函数的初始化列表中不能初始化成员变量，因为已经交给代理构造函数了</span></span><br><span class="line"><span class="comment">//X4() : m_A(0), X4(0)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//std::cout &lt;&lt; &quot;Constructor 1&quot; &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//虽然初始化列表中不能初始化成员变量，但是函数体内部仍然可以对成员变量赋值</span></span><br><span class="line"><span class="built_in">X4</span>() : <span class="built_in">X4</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">0</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Constructor 1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">X4</span>(<span class="type">int</span> a) : <span class="built_in">m_A</span>(a)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Constructor 2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>4．委托构造函数的执行顺序是先执行代理构造函数的初始化列表，然后执行代理构造函数的主体，最后执行委托构造函数的主体。这个也好理解，而且前面已经说过了。</p><p>5．如果在<strong>代理构造函数执行完成后</strong>，<strong>委托构造函数主体</strong>抛出了<strong>异常</strong>，则自动<strong>调用该类型的析构函数</strong>。通常情况下在没有完成构造函数的情况下，也就是说构造函数发生异常，此时会认为对象并没有创建完成，所以对象类型的析构函数是不会被调用的。但是<strong>代理构造函数执行完成</strong>后就会<strong>认为对象已经构造完成了</strong>，所以即使委托构造函数中有异常了，也会调用其析构函数。</p><h1 id="函数参数计算顺序"><a href="#函数参数计算顺序" class="headerlink" title="函数参数计算顺序"></a>函数参数计算顺序</h1><p>​在传递调用函数时，我们有时可能会直接传入一个表达式作为函数实参，但是如果我们传入的实参中有多个表达式的形式，那么每个形参赋值的顺序是什么呢？</p><p>​对于下面的示例代码，下面集中情况都有可能：</p><ol><li><p>有可能先计算a + 1赋值给形参，再计算b + 1赋值给形参</p></li><li><p>有可能先计算b + 1赋值给形参，再算a + 1赋值给形参</p></li><li><p>有可能同时计算，再同时赋值给形参</p></li></ol><p>​但实际上我们并不知道，同一编译器在Debug和Release下顺序可能会不一样，不同编译器直接的顺序也可能会不一样，实际上这很大程度上是取决于编译器的计算顺序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">Sum</span>(a + <span class="number">1</span>, b + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​c++并未提供一种规范要求函数参数的求值顺序是什么，主要还是取决于各种编译器的实现决定的，所以不同的编译器的计算顺序有可能是完全不同的，所以实际上我们并不能指定函数形参求值的顺序是什么。</p><h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><p>C++11 引入了 3 个智能指针类型：</p><ol><li><code>std::unique_ptr&lt;T&gt;</code> ：独占资源所有权的指针。</li><li><code>std::shared_ptr&lt;T&gt;</code> ：共享资源所有权的指针。</li><li><code>std::weak_ptr&lt;T&gt;</code> ：共享资源的观察者，需要和 std::shared_ptr 一起使用，不影响资源的生命周期。</li></ol><h2 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h2><p>​在我们使用裸指针的时候，使用<code>new</code>在堆区申请了空间后，非常容易忘记<code>delete</code>释放掉，会造成内存泄漏。当我们相对资源进行独享时，就可以使用<code>std::unique_ptr</code>进行管理，当离开变量的作用域时会自动释放掉资源。是很基本的<strong>RAII</strong>(<strong>Resource Acquisition Is Initialization，资源获取即初始化</strong>)思想，简单来说就是对象创建时获取资源，对象离开作用域被销毁时释放资源，从而保证申请的内存一定会被释放。</p><h3 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h3><p>​首先，<code>std::unique_ptr</code>的定位非常明确，就是独占资源，保证了同时只能有一个指针指向一块内存。为此其内部删除了拷贝构造和拷贝赋值，但可以使用移动构造和移动赋值，也就是说内部的资源<strong>不能复制</strong>，<strong>只能移动</strong>。</p><p>​下面看一下具体用法：</p><p>​<code>std::unique_ptr</code>是只能移动，不可复制的；他重载了<code>*</code>和<code>-&gt;</code>运算符，我们可以像使用原始指针那样使用他；同时也提供了<code>get()</code>函数获取原始指针；使用<code>release()</code>函数放弃自己的拥有权，返回原始指针；使用<code>reset()</code>函数释放自己的资源并置空，也就是手动释放资源。</p><p>​<code>std::unique_ptr</code>也实现了模板特化以支持数组形式，使用时要使用<code>[ ]</code>显示指明，即<code>std::unique_ptr&lt;Data[]&gt;pArr</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//创建unique_ptr数组形式，只能调用默认构造函数，所以必须提供</span></span><br><span class="line"><span class="built_in">Data</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">Data</span>(<span class="type">int</span> a)</span><br><span class="line">:<span class="built_in">m_Val</span>(a)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Data</span>()</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Destory&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m_Val = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//两种写法都可以，但是推荐第一种写法（更安全）</span></span><br><span class="line">std::unique_ptr&lt;Data&gt; p1 = std::<span class="built_in">make_unique</span>&lt;Data&gt;(<span class="number">10</span>); <span class="comment">//可以直接传递参数调用对应的构造函数</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;Data&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> Data(<span class="number">10</span>))</span></span>; <span class="comment">//这种写法仍需要手动调用new，不太安全</span></span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取原始数据</span></span><br><span class="line">        Data* p = p<span class="number">1.</span><span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这样就是把p1的资源释放并置空（常用）</span></span><br><span class="line">        p<span class="number">1.</span><span class="built_in">reset</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//危险操作，这样会导致p1和p2释放同一个内存而报错</span></span><br><span class="line">        <span class="comment">//p1.reset(p2.get()); </span></span><br><span class="line">        p<span class="number">1.</span><span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Data</span>(<span class="number">10</span>)); <span class="comment">//释放原有内存，管理新传来的内存</span></span><br><span class="line"></span><br><span class="line">        p<span class="number">1.</span><span class="built_in">release</span>(); <span class="comment">//交出管理权，内部置空，返回原始指针（release之后智能指针就不负责释放了，必须记得手动释放）</span></span><br><span class="line">        </span><br><span class="line">        p<span class="number">1.</span><span class="built_in">swap</span>(p2); <span class="comment">//交换两个unique_ptr的内容</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当创建普通对象时，make_unique的实参会完美转发给对应类型的构造函数</span></span><br><span class="line">        std::unique_ptr&lt;Data&gt; p3 = std::<span class="built_in">make_unique</span>&lt;Data&gt;(<span class="number">10</span>); <span class="comment">//离开作用域之后会调用Data的析构函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//p1 = p2; 编译失败，unique_ptr不允许复制</span></span><br><span class="line">p1 = std::<span class="built_in">move</span>(p2); <span class="comment">//可以移动</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建一个Data数组，只能调用默认构造函数，因为make_unique里的实参表面数组的大小</span></span><br><span class="line">        std::unique_ptr&lt;Data[]&gt;pArr = std::<span class="built_in">make_unique</span>&lt;Data[]&gt;(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//输出的都是默认值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">            std::cout &lt;&lt; pArr[i].m_Val &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​除了上述提到的函数，智能指针还允许我们自定义<strong>deleter(删除器)</strong>，并且这个删除器的函数参数一般情况下要是<code>std::unique_ptr</code>所<strong>管理对象类型的指针</strong>（如果是多态的话，即使管理对象是派生类，也可以用<strong>基类指针</strong>作为参数）。当我们指定删除器之后，就不会使用默认删除器释放内存了，所以一定要在<strong>自定义删除器里面释放内存或其他资源</strong>。但是当我们自定义删除器之后，就不能使用<code>make_unique</code>创建了，就必须调用其构造函数直接创建。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义删除器基本语法(T为管理资源的类型,F为构造器的类型)</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;T, F&gt; <span class="title">ptr</span><span class="params">(raw_ptr, deleter)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//创建unique_ptr数组形式，只能调用默认构造函数，所以必须提供</span></span><br><span class="line"><span class="built_in">Data</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Data</span>(<span class="type">int</span> a)</span><br><span class="line">:<span class="built_in">m_Val</span>(a)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Data</span>()</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Destory&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m_Val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">(Data* d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;普通函数删除器&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">if</span> (d)<span class="keyword">delete</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//使用lambda表达式作为删除器</span></span><br><span class="line">    <span class="keyword">auto</span> f1 = [](Data* d) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;lambda删除器&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">if</span>(d)<span class="keyword">delete</span> d; <span class="comment">//知道了删除器之后，就不会指向默认删除器了，所以内存我们必须手动释放，否则就会内存泄漏</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//因为模板里传入删除器的类型，可以直接用decltype获取，自定义删除器就不能使用make_unique的方式创建了</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;Data, <span class="title">decltype</span><span class="params">(f1)</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> Data(<span class="number">10</span>), f1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用函数对象作为删除器</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">F</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Data* d)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;函数对象删除器&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">if</span> (d)<span class="keyword">delete</span> d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    F f2;</span><br><span class="line">    <span class="comment">//使用函数对象的话，模板里可以直接使用类型名，不用decltype</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;Data, F&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> Data(<span class="number">10</span>), f2)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//也可以直接使用函数指针作为删除器</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;Data, <span class="title">decltype</span><span class="params">(&amp;f3)</span>&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> Data(<span class="number">10</span>), &amp;f3)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//模板参数也可以用std::function，这样符合条件的可调用对象都能作为参数传进来</span></span><br><span class="line">    std::unique_ptr&lt;Data, std::function&lt;<span class="type">void</span>(Data*)&gt;&gt; <span class="built_in">p11</span>(<span class="keyword">new</span> <span class="built_in">Data</span>(<span class="number">10</span>), f1);</span><br><span class="line">    std::unique_ptr&lt;Data, std::function&lt;<span class="type">void</span>(Data*)&gt;&gt; <span class="built_in">p22</span>(<span class="keyword">new</span> <span class="built_in">Data</span>(<span class="number">10</span>), f2);</span><br><span class="line">    std::unique_ptr&lt;Data, std::function&lt;<span class="type">void</span>(Data*)&gt;&gt; <span class="built_in">p33</span>(<span class="keyword">new</span> <span class="built_in">Data</span>(<span class="number">10</span>), &amp;f3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>​<code>std::unique_ptr</code>的实现原理较为简单，只需要记住不可复制，只能移动；每个<code>unique_ptr</code>只能指向一块内存，不允许多个同时指向一块内存。可以看到<code>std::unique_ptr</code>只是按照RAII原则将指针封装起来了，并没有太多额外的开销，所以<code>std::unique_ptr</code>的<strong>开销和原始指针差不多</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UniquePtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">UniquePtr</span>() : <span class="built_in">m_Raw</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"><span class="comment">//必须显示调用，防止发生隐式转换</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">UniquePtr</span><span class="params">(T* ptr)</span> : m_Raw(ptr) &#123;</span>&#125;</span><br><span class="line">~<span class="built_in">UniquePtr</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//析构时释放内存</span></span><br><span class="line"><span class="keyword">if</span> (m_Raw) &#123; <span class="keyword">delete</span> m_Raw; m_Raw = <span class="literal">nullptr</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不允许资源拷贝，拷贝构造和赋值运算符都删除</span></span><br><span class="line"><span class="built_in">UniquePtr</span>(<span class="type">const</span> UniquePtr&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">UniquePtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> UniquePtr&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只能通过移动构造或移动赋值实现资源转移</span></span><br><span class="line"><span class="built_in">UniquePtr</span>(UniquePtr&amp;&amp; other) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">m_Raw = other.m_Raw;</span><br><span class="line">other.m_Raw = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">UniquePtr&amp; <span class="keyword">operator</span> = (UniquePtr&amp;&amp; other) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//避免自赋值导致误删</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">if</span> (m_Raw)<span class="keyword">delete</span> m_Raw;</span><br><span class="line">m_Raw = other.m_Raw;</span><br><span class="line">other.m_Raw = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//外部获取原始指针</span></span><br><span class="line"><span class="function">T* <span class="title">Get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_Raw; &#125;</span><br><span class="line"><span class="function"><span class="type">const</span> T* <span class="title">Get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Raw; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运算符重载简化操作</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Raw != <span class="literal">nullptr</span>; &#125;</span><br><span class="line">T&amp; <span class="keyword">operator</span> *() &#123; <span class="keyword">return</span> *m_Raw; &#125;</span><br><span class="line">T* <span class="keyword">operator</span> -&gt;() &#123; <span class="keyword">return</span> m_Raw; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//原始指针</span></span><br><span class="line">T* m_Raw;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a>std::shared_ptr</h2><p>​<code>std::shared_ptr</code>也可以管理资源，被销毁时自动释放管理的空间。但是与<code>unique_ptr</code>的独占资源不同的是，<code>shared_ptr</code>是<strong>允许共享资源</strong>的。其内部维护一个引用计数，表示所指向的内存当前同时有多少人共享。只有当引用计数为0时才能释放所指向的内存，也因此<code>std::shared_ptr</code>是<strong>可复制、可移动</strong>的。</p><h3 id="使用-4"><a href="#使用-4" class="headerlink" title="使用"></a>使用</h3><p>​很多<code>unique_ptr</code>支持的<code>shared_ptr</code>也同样支持。但是后者没有<code>release()</code>函数，有独特的<code>use_count()</code>函数返回引用计数；而且shared_ptr允许复制，并且他的自定义删除器也比<code>unique_ptr</code>写起来要简单，不用在模板中指明构造器的类型，直接把构造器当作形参传进去即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义删除器基本语法(T为管理资源的类型)</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;T&gt; <span class="title">ptr</span><span class="params">(raw_ptr, deleter)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//两种创建方法都可以，但是推荐第二种写法，使用make_shared而不是自己调用new</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;Data&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> Data(<span class="number">10</span>))</span></span>;</span><br><span class="line">    std::shared_ptr&lt;Data&gt; p2 = std::<span class="built_in">make_shared</span>&lt;Data&gt;(<span class="number">10</span>); <span class="comment">//推荐</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//允许复制，此时p3内和p1内指向同一块内存，且引用计数加一</span></span><br><span class="line">    std::shared_ptr&lt;Data&gt; p3 = p1;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取原始指针</span></span><br><span class="line">        Data* temp = p<span class="number">3.</span><span class="built_in">get</span>();</span><br><span class="line">        <span class="comment">//reset函数和unique_ptr的reset作用一样，什么都不传等于置空并且其内部的引用计数见一</span></span><br><span class="line">        p<span class="number">3.</span><span class="built_in">reset</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//p3.release(); shared_ptr没有release函数，如果想主动放弃就调用reset函数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//交换两个内部的值</span></span><br><span class="line">        p<span class="number">2.</span><span class="built_in">swap</span>(p1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回引用计数</span></span><br><span class="line">        <span class="type">int</span> count = p<span class="number">2.</span><span class="built_in">use_count</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//重载了*和-&gt;，也可以像原始指针那样使用</span></span><br><span class="line">        p1-&gt;m_Val = <span class="number">11</span>;</span><br><span class="line">        (*p1).m_Val = <span class="number">222</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> f = [](Data* d) &#123;</span><br><span class="line">            <span class="keyword">if</span> (d)<span class="keyword">delete</span> d;</span><br><span class="line">            &#125;;</span><br><span class="line">        <span class="function">std::shared_ptr&lt;Data&gt; <span class="title">p4</span><span class="params">(<span class="keyword">new</span> Data(<span class="number">10</span>), f)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><p>​使用<code>shared_ptr</code>很容易陷入循环引用问题中，一旦陷入循环引用中，当<code>shared_ptr</code>超出作用域销毁时因为<strong>引用计数不为0</strong>，就不会释放所管理的资源，就造成了<strong>内存泄漏</strong>。为了解决这一问题，<code>std::weak_ptr</code>应运而生，下面会介绍。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">~<span class="built_in">B</span>()</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;B的析构&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">std::shared_ptr&lt;A&gt; m_Ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">~<span class="built_in">A</span>()</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;A的析构&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">std::shared_ptr&lt;B&gt; m_Ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//循环引用</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;相互引用&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::shared_ptr&lt;A&gt;<span class="built_in">a</span>(<span class="keyword">new</span> <span class="built_in">A</span>());</span><br><span class="line">        std::shared_ptr&lt;B&gt;<span class="built_in">b</span>(<span class="keyword">new</span> <span class="built_in">B</span>());</span><br><span class="line">        <span class="comment">//此时，a和b的引用计数均为1</span></span><br><span class="line">        std::cout &lt;&lt; a.<span class="built_in">use_count</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将b复制给a里面的shared_ptr，a复制给b里面的shared_ptr</span></span><br><span class="line">        a-&gt;m_Ptr = b;</span><br><span class="line">        b-&gt;m_Ptr = a;</span><br><span class="line">        <span class="comment">//此时，a和b的引用计数均为2</span></span><br><span class="line">        std::cout &lt;&lt; a.<span class="built_in">use_count</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;<span class="comment">//当a和b退出作用域时，a和b的引用计数都会减一，但减一后仍不为0，所以内存没有被释放，造成内存泄漏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>​实现和<code>unique_ptr</code>类似，但是需要注意<strong>维护引用计数的值</strong>，每次析构、复制的时候都要注意维护正确的引用计数的值，只有当引用计数为0时才能删除所管理的内存。这里实现的只是简化版本的，只有强引用计数，没有把考虑弱引用进来。由于<code>shared_ptr</code>内部需要维护引用计数和其他的相关数据，所以会<strong>产生一定的开销</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleSharedPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">SimpleSharedPtr</span>() : <span class="built_in">m_Raw</span>(<span class="literal">nullptr</span>), <span class="built_in">m_RefCount</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">SimpleSharedPtr</span><span class="params">(T* ptr)</span> : m_Raw(ptr), m_RefCount&#123;</span> <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>) &#125; &#123;&#125;</span><br><span class="line"><span class="built_in">SimpleSharedPtr</span>(<span class="type">const</span> SimpleSharedPtr&amp; other);</span><br><span class="line"><span class="built_in">SimpleSharedPtr</span>(SimpleSharedPtr&amp;&amp; other);</span><br><span class="line">~<span class="built_in">SimpleSharedPtr</span>();</span><br><span class="line"></span><br><span class="line">SimpleSharedPtr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SimpleSharedPtr&amp; other);</span><br><span class="line">SimpleSharedPtr&lt;T&gt;&amp; <span class="keyword">operator</span>=(SimpleSharedPtr&amp;&amp; other);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_Raw != <span class="literal">nullptr</span>; &#125;</span><br><span class="line"><span class="keyword">inline</span> T* <span class="keyword">operator</span>-&gt;() &#123; <span class="keyword">return</span> m_Raw; &#125;</span><br><span class="line"><span class="keyword">inline</span> T&amp; <span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> *m_Raw; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> T* <span class="title">Get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_Raw; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> T* <span class="title">Get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Raw; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Release</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* m_Raw;</span><br><span class="line"><span class="type">int</span>* m_RefCount;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> SimpleSharedPtr&lt;T&gt;::<span class="built_in">SimpleSharedPtr</span>(<span class="type">const</span> SimpleSharedPtr&amp; other)</span><br><span class="line">:<span class="built_in">m_Raw</span>(other.m_Raw), <span class="built_in">m_RefCount</span>(other.m_RefCount)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(m_RefCount)(*m_RefCount)++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> SimpleSharedPtr&lt;T&gt;::<span class="built_in">SimpleSharedPtr</span>(SimpleSharedPtr&amp;&amp; other)</span><br><span class="line">:<span class="built_in">m_Raw</span>(other.m_Raw), <span class="built_in">m_RefCount</span>(other.m_RefCount)</span><br><span class="line">&#123;</span><br><span class="line">other.m_Raw = <span class="literal">nullptr</span>;</span><br><span class="line">other.m_RefCount = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> SimpleSharedPtr&lt;T&gt;::~<span class="built_in">SimpleSharedPtr</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> SimpleSharedPtr&lt;T&gt;&amp; SimpleSharedPtr&lt;T&gt;::<span class="keyword">operator</span>=(<span class="type">const</span> SimpleSharedPtr&amp; other)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Release</span>();</span><br><span class="line">m_Raw = other.m_Raw;</span><br><span class="line">m_RefCount = other.m_RefCount;</span><br><span class="line"><span class="keyword">if</span>(m_RefCount)(*m_RefCount)++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> SimpleSharedPtr&lt;T&gt;&amp; SimpleSharedPtr&lt;T&gt;::<span class="keyword">operator</span>=(SimpleSharedPtr&amp;&amp; other)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Release</span>();</span><br><span class="line">m_Raw = other.m_Raw;</span><br><span class="line">m_RefCount = other.m_RefCount;</span><br><span class="line"></span><br><span class="line">other.m_Raw = <span class="literal">nullptr</span>;</span><br><span class="line">m_RefCount = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> SimpleSharedPtr&lt;T&gt;::<span class="built_in">Release</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (--(*m_RefCount) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_RefCount;</span><br><span class="line">m_RefCount = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span> (m_Raw) &#123; <span class="keyword">delete</span> m_Raw; m_Raw = <span class="literal">nullptr</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="std-weak-ptr"><a href="#std-weak-ptr" class="headerlink" title="std::weak_ptr"></a>std::weak_ptr</h2><p>​<code>weak_ptr</code>是专门设计用来解决 <code>shared_ptr</code>的循环引用问题的，他是一个”弱引用”指针，它不拥有对象的所有权，也<strong>不增加引用计数</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//针对于上面的循环引用情况，只需要把两个类内部的shared_ptr改为weak_ptr即可解决循环引用问题</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">~<span class="built_in">B</span>()</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;B的析构&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//std::shared_ptr&lt;A&gt; m_Ptr;</span></span><br><span class="line"><span class="comment">//换为弱引用指针时不会增加shared_ptr的引用计数，可以解决循环引用问题</span></span><br><span class="line">std::weak_ptr&lt;A&gt; m_WeakPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">~<span class="built_in">A</span>()</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;A的析构&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//std::shared_ptr&lt;B&gt; m_Ptr;</span></span><br><span class="line">std::shared_ptr&lt;B&gt; m_WeakPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​下面看一下具体的使用：</p><p>​<code>weak_ptr</code>没有重载<code>*</code>和<code>-&gt;</code>运算符；他的<code>use_count()</code>返回的是所观察的<code>shared_ptr</code>的引用计数；使用<code>lock()</code>函数可以安全的获得<code>shared_ptr</code>，如果观察的<code>shared_ptr</code>已经被销毁就返回<code>nullptr</code>；使用<code>expired()</code>可以查看所观察的<code>shared_ptr</code>是否还存在，存在就返回<code>true</code>，否则返回<code>false</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    std::shared_ptr&lt;Data&gt; p1 = std::<span class="built_in">make_shared</span>&lt;Data&gt;(<span class="number">10</span>);</span><br><span class="line">    std::cout &lt;&lt; p<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">//引用计数为1</span></span><br><span class="line"></span><br><span class="line">    std::weak_ptr&lt;Data&gt; pw = p1;</span><br><span class="line">    std::cout &lt;&lt; p<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">//引用计数还是1</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        std::weak_ptr&lt;Data&gt; pw2;</span><br><span class="line">        &#123;</span><br><span class="line">            std::shared_ptr&lt;Data&gt; p2 = std::<span class="built_in">make_shared</span>&lt;Data&gt;(<span class="number">10</span>);</span><br><span class="line">            pw2 = p2;</span><br><span class="line"></span><br><span class="line">            std::cout &lt;&lt; pw<span class="number">2.</span><span class="built_in">expired</span>() &lt;&lt; std::endl; <span class="comment">//返回false</span></span><br><span class="line">            std::cout &lt;&lt; pw<span class="number">2.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">//返回1</span></span><br><span class="line">            std::shared_ptr&lt;Data&gt; p3 = pw<span class="number">2.l</span>ock(); <span class="comment">//此时会增加引用计数</span></span><br><span class="line">            std::cout &lt;&lt; (pw<span class="number">2.l</span>ock() == <span class="literal">nullptr</span>) &lt;&lt; std::endl; <span class="comment">//返回false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//退出作用域，销毁p2</span></span><br><span class="line">        std::cout &lt;&lt; pw<span class="number">2.</span><span class="built_in">expired</span>() &lt;&lt; std::endl; <span class="comment">//返回true</span></span><br><span class="line">        std::cout &lt;&lt; pw<span class="number">2.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">//返回0</span></span><br><span class="line">        std::cout &lt;&lt; (pw<span class="number">2.l</span>ock() == <span class="literal">nullptr</span>) &lt;&lt; std::endl; <span class="comment">//返回true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//weak_ptr并没有重载*和-&gt;运算符</span></span><br><span class="line">        <span class="comment">//pw-&gt;m_Val;</span></span><br><span class="line">        <span class="comment">//(*pw).m_Val;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="shared-ptr和weak-ptr"><a href="#shared-ptr和weak-ptr" class="headerlink" title="shared_ptr和weak_ptr"></a>shared_ptr和weak_ptr</h2><p>​现在为了解决循环引用问题引入了<code>weak_ptr</code>，所以<code>shared_ptr</code>就必须能兼容<code>weak_ptr</code>了，下面具体讲一下底层的原理。</p><p>​如下图所示，<code>shared_ptr</code>内有一个指向其管理对象的指针和指向控制块的指针，控制块内目前只关注<strong>强引用计数</strong>和<strong>弱引用计数</strong>。其中<strong>强引用计数</strong>表示当前有多少个 <code>shared_ptr</code>实例拥有该对象的所有权，<strong>弱引用计数</strong>表示当前有多少个 <code>weak_ptr</code>实例正在<strong>观察</strong>该对象，但<strong>不拥有所有权</strong>。</p><p>​当强引用计数为0时，会释放掉所管理对象的内存；如果此时弱引用计数不为0，控制块指针指向的内存不会被释放，只有当弱引用也为0时才会释放控制块指针指向的内存。</p><p>​前面说过的<code>lock()</code>函数和<code>expired()</code>函数就是根据控制块内的强引用计数判断的，如果<strong>强引用计数为0，就表面该对象已经被销毁了</strong>，所以此时<code>lock()</code>会返回<code>nullptr</code>而不会返回一个<code>shared_ptr</code>；<code>expired()</code>函数返回<code>true</code>，表面该对象已经被销毁了。</p><pre class="mermaid">graph TD    %% 更简洁专业的版本    A1[ctrlPtr]:::pointer    A2[objPtr]:::pointer        B[控制块<br/>use_count: 强引用计数<br/>weak_count: 弱引用计数<br/>deleter: 删除器函数<br/>allocator: 内存分配器]:::control        C1[ctrlPtr]:::pointer    D[动态分配的对象<br/>存储实际数据]:::object    %% 虚线框表示智能指针实例    subgraph SP["std::shared_ptr"]        A1        A2    end        subgraph WP["std::weak_ptr"]        C1    end    %% 连接关系    A1 --> B    A2 --> D    C1 --> B    %% 样式定义    classDef pointer fill:#f5f5f5,stroke:#333,stroke-width:1.5px    classDef control fill:#fff3e0,stroke:#ff9800,stroke-width:2px    classDef object fill:#e8f5e8,stroke:#4caf50,stroke-width:2px    classDef shared fill:#e3f2fd,stroke:#2196f3,stroke-width:1px,stroke-dasharray: 3 3,width:280px    classDef weak fill:#f3e5f5,stroke:#9c27b0,stroke-width:1px,stroke-dasharray: 3 3,width:140px        class SP shared    class WP weak    class A1,A2,C1 pointer    class B control    class D object</pre><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><pre class="mermaid">graph TD    A[基类Base]    A --> C[子类Derive1]    A --> D[子类Derive2]</pre><p>​向下转换：基类指针&#x2F;引用向下转换为子类指针&#x2F;引用。</p><p>​向上转换：子类指针&#x2F;引用向上转换为基类指针&#x2F;引用。</p><p>​下面几类类型转换的写法一致：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_cast</span>&lt;类型&gt;(变量);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;类型&gt;(变量);</span><br><span class="line"></span><br><span class="line"><span class="built_in">const_cast</span>&lt;类型&gt;(变量);</span><br><span class="line"></span><br><span class="line"><span class="built_in">reinterpret_cast</span>&lt;类型&gt;(变量);</span><br></pre></td></tr></table></figure><h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><p>​<code>static_cast</code>只会在编译时检查，由编译器判断是否能进行转换。主要用于：</p><ul><li>基本数据类型转换（<code>int</code>→ <code>double</code>）。</li><li>父子类指针&#x2F;引用的 <strong>向上转换</strong>（子类 → 基类）。</li><li>父子类指针&#x2F;引用的<strong>向下转换</strong>（基类 → 子类，但 <strong>不安全</strong>）。</li></ul><p>​指针之间不能直接使用<code>static_cast</code>转换，只能通过<code>void*</code> 才能相互转换，因为<code>static_cast</code>只允许指针和<code>void*</code> 相互转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-------------------------1. 基本类型相互转换</span></span><br><span class="line"><span class="type">double</span> d = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(d);</span><br><span class="line"><span class="type">int</span> j = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(c);</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------2. 指针与void*相互转换</span></span><br><span class="line"><span class="type">int</span> value = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span>* intPtr = &amp;value;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将int*转换为void*</span></span><br><span class="line"><span class="type">void</span>* voidPtr = <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(intPtr);</span><br><span class="line"><span class="comment">// 将void*转换回int*</span></span><br><span class="line"><span class="type">int</span>* newIntPtr = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>*&gt;(voidPtr);</span><br><span class="line"><span class="comment">//指针之间不能之直接转换，只能先转为void*再转为其他类型</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* aPtr = &amp;a;</span><br><span class="line"><span class="type">float</span> b = <span class="number">10.0f</span>;</span><br><span class="line"><span class="type">float</span>* bPtr = &amp;b;</span><br><span class="line">bPtr = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>*&gt;(<span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(aPtr));</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------3. 父类与子类间指针/引用向上转换（安全）</span></span><br><span class="line">Derived* derived = <span class="keyword">new</span> <span class="built_in">Derive</span>();</span><br><span class="line">Base* base_ptr = <span class="built_in">static_cast</span>&lt;Base*&gt;(derived);  <span class="comment">// 向上转换（安全）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------4. 父类与子类间指针/引用向下转换（不安全！程序员必须确定父类指针指向的为子类对象）</span></span><br><span class="line"><span class="comment">//下面两种转换编译器都是允许的，但是第一种情况转换后肯定会出问题，第二种转换是正确的，所以向上转换时要么确定转换一定正确，要么就使用dynamic_cast运行时检查</span></span><br><span class="line">Base* base1 = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">Derived* derived_ptr1 = <span class="built_in">static_cast</span>&lt;Derived*&gt;(base1);</span><br><span class="line"></span><br><span class="line">Base* base2 = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">Derived* derived_ptr2 = <span class="built_in">static_cast</span>&lt;Derived*&gt;(base2);</span><br></pre></td></tr></table></figure><h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><p>​<code>dynamic_cast</code>专门用来处理多态（有虚函数的类）的 <strong>向下转换</strong>（基类 → 子类）。该转换会在<strong>运行时检查</strong>，如果转换失败：</p><ul><li>指针 → 返回 <code>nullptr</code>。</li><li>引用 → 抛出 <code>std::bad_cast</code>异常。</li></ul><p>​<code>dynamic_cast</code>也可用来处理<strong>向上转换</strong>（子类 → 基类 ），<strong>向上转换不要求基类有虚函数</strong>，但<strong>向下转换基类必须要有虚函数</strong>（多态）。</p><p>运行时需要 <strong>运行时类型信息（RTTI）</strong>，可能影响性能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Derive</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derive* derive1 = <span class="keyword">new</span> <span class="built_in">Derive</span>();</span><br><span class="line">Base* base1 = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">    Base* base2 = <span class="keyword">new</span> <span class="built_in">Derive</span>();</span><br><span class="line">    <span class="comment">//转换失败，temp1为nullptr</span></span><br><span class="line">Derive* temp1 = <span class="built_in">dynamic_cast</span>&lt;Derive*&gt;(base1);</span><br><span class="line">    <span class="comment">//转换成功，temp2为正常指针</span></span><br><span class="line">    Derive* temp2 = <span class="built_in">dynamic_cast</span>&lt;Derive*&gt;(base2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//向上转换（子类-&gt;基类）是安全的，static_cast和dynamic_cast都可处理</span></span><br><span class="line">    Base* b1 = <span class="built_in">dynamic_cast</span>&lt;Base*&gt;(derive1);</span><br><span class="line">Base* b2 = <span class="built_in">static_cast</span>&lt;Base*&gt;(derive1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<code>static_cast</code>只能在编译时检查，但是<code>Base*</code> 转换为<code>Derive*</code> 操作是被编译器允许的，所以并不能检测出能不能进行转换，因为很可能出现<code>Base*</code>并<strong>不是由多态基类指针指向子类对象而创建的</strong>，就是一个单纯的基类指针，这种转换显然是不合理的。而<code>dynamic_cast</code>可以在允许时检查这种转换是否正确，以此提升安全性。</p><h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h2><p>​<strong><code>const_cast</code></strong> 是 C++ 中专门用于 <strong>常量属性</strong> 的类型转换操作符。它的主要作用是 <strong>移除</strong> 或 <strong>添加</strong> 对象的 <strong><code>const</code></strong> 或 <strong><code>volatile</code></strong> 修饰符。与其他类型转换操作符不同，<strong><code>const_cast</code></strong> <strong>只能用于修改对象的常量性</strong>，而<strong>不能用于在不同类型之间进行转换</strong>。 </p><p>​用法：</p><ul><li><strong>移除 <code>const</code> 限定符</strong>：允许将指向常量的指针或引用转换为指向非常量的指针或引用，以便修改常量对象（注意：修改真正的常量对象会导致未定义行为）。</li><li><strong>添加 <code>const</code> 限定符</strong>：也可以用于给指针或引用添加 <code>const</code> 限定符。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Modify</span><span class="params">(<span class="type">int</span>* a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">*a = <span class="number">666</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ModifyConst</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//a指向的内存不能被修改</span></span><br><span class="line"><span class="comment">//*a = 666;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//-----------------------------------------1. 去除const修饰(直接修改const变量的值可能导致未定义行为，不安全)</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* ptr = &amp;x;</span><br><span class="line">    <span class="built_in">Modify</span>(ptr);<span class="comment">//编译器报错，因为const int*无法转换为int*</span></span><br><span class="line"><span class="built_in">Modify</span>(<span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(ptr));<span class="comment">//使用const_cast将const int*转换为int*，即去除掉const修饰</span></span><br><span class="line">std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//-----------------------------------------2. 去除const修饰，修改非const变量(可以安全修改)</span></span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* ptr = &amp;x;</span><br><span class="line"><span class="built_in">Modify</span>(<span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(ptr));<span class="comment">//使用const_cast将const int*转换为int*，即去除掉const修饰</span></span><br><span class="line">std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//-----------------------------------------3. 添加const修饰，防止某些函数修改对象</span></span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span>* ptr = &amp;x;</span><br><span class="line"><span class="built_in">ModifyConst</span>(<span class="built_in">const_cast</span>&lt;<span class="type">const</span> <span class="type">int</span>*&gt;(ptr));<span class="comment">//使用const_cast将int*转换为const int*，即添加const修饰</span></span><br><span class="line">std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h2><p>​<code>reinterpret_cast</code> 是 C++ 中最强大、但也最危险的类型转换操作符之一。它允许在<strong>不同类型之间进行低级别的类型转换</strong>。与其他类型转换操作符不同，<code>reinterpret_cast</code> 并<strong>不会进行任何类型检查</strong>，它仅仅是<strong>重新解释二进制位的含义</strong>，直接将一个类型的位模式重新解释为另一个类型。<br>​简单来说就是<code>reinterpret_cast</code>转换时不关心二者之间的转换是否合理，不做任何检查，而是强制将一段内存解释为另一种类型。</p><p>​对于下面的例子来说，就是将<code>aPtr</code>所指向的内存重新解释为<code>float</code>类型。转换后<code>aPtr</code>和<code>bPtr</code>都指向同一块内存空间，该空间的内容为<code>0x0000000a</code>，是十六进制表示的数字10。虽然两个指针指向一块内存空间，但是一个是<code>int*</code> ，一个是<code>float*</code> ，两个指针对该内存的解释不同，一个当作<code>int</code>型解释，一个当作<code>float</code>型解释。最后的输出结果也大不相同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* aPtr = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> b = <span class="number">10.0f</span>;</span><br><span class="line"><span class="type">float</span>* bPtr = &amp;b;</span><br><span class="line">std::cout &lt;&lt; *bPtr &lt;&lt; std::endl;<span class="comment">//输出结果为10.0</span></span><br><span class="line">    </span><br><span class="line">bPtr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">float</span>*&gt;(aPtr);</span><br><span class="line">    <span class="comment">//两个指针指向同一块内存，但是对内存的解释不同，输出结果也不同</span></span><br><span class="line">std::cout &lt;&lt; *bPtr &lt;&lt; std::endl;<span class="comment">//输出结果为1.4013e-44</span></span><br><span class="line">    std::cout &lt;&lt; *aPtr &lt;&lt; std::endl;<span class="comment">//输出结果为10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\HMY\AppData\Roaming\Typora\typora-user-images\image-20250928204356691.png" alt="image-20250928204356691"></p><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h2><p>​模板是现代 C++ 的一项强大特性，初衷是为了实现泛型编程。可以编写一次代码，然后使用不同的数据类型，不用为每种类型编写单独的函数或类。现代C++中功能强大的STL就是基于模板实现的，同时模板也是实现静态多态的方法之一。C++中的模板主要分为<strong>类模板</strong>和<strong>函数模板</strong>，这两种类型的模板都很容易理解，运行时编程差异不算大，后面再各自详细介绍一下。</p><p>​如果没有模板的话，我们怎么才能实现一个函数适配各种类型的数据呢？可以使用宏定义来实现。但是正如Effective C++所说的那样，我们应该尽量避免使用宏。宏本质上就是预处理时进行字符串替换，没有类型检查，调试时也不会进入到宏内部，这显然是不行的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ADD(T) T add(T a, T b)\</span></span><br><span class="line"><span class="meta">&#123;\</span></span><br><span class="line"><span class="meta">return a + b;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ADD</span>(<span class="type">int</span>);</span><br><span class="line"><span class="built_in">ADD</span>(<span class="type">float</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">add</span>(<span class="number">1.0f</span>, <span class="number">2.0f</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​模板出现后，我们可以很方便的定义接收任意类型的类或函数。使用时需要在对应的函数或者类前面使用<code>template&lt;typename T&gt;</code>或<code>template&lt;class T&gt;</code>加上模板声明，然后在该类或者函数内就能使用<code>T</code>作为数据类型使用。并且参数的类型编译器可以自动推导，也可以在使用时使用<code>&lt;int&gt;</code>的语法显示指明类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模板实现</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">addTemplate</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//自动推导模板参数类型</span></span><br><span class="line">    <span class="built_in">addTemplate</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">addTemplate</span>(<span class="number">1.0f</span>, <span class="number">2.0f</span>);</span><br><span class="line"><span class="comment">//addTemplate(1.0f, 2); 编译错误，我们这种写法就隐含了两个参数的类型必须相同</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//显示指明模板参数类型</span></span><br><span class="line">    <span class="built_in">addTemplate</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​模板只有在使用的时候编译器才会<strong>实例化</strong>对应版本的类或者函数，所以模板的实例化是编译期实现的，不会带来运行时的性能损耗。以下面的代码为例，对应<code>add</code>模板函数，我们使用了<code>int, float和double</code>类型的版本，所以编译器只会为我们生成这三个类型的函数版本，参考<strong>C++ Insights得到</strong>的结果如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> a + b; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);  </span><br><span class="line">  <span class="built_in">add</span>(<span class="number">1.0f</span>, <span class="number">2.0f</span>);</span><br><span class="line">  <span class="built_in">add</span>(<span class="number">1.0</span>, <span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//C++ Insights得到的中间代码</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">int</span> <span class="built_in">add</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">float</span> <span class="built_in">add</span>&lt;<span class="type">float</span>&gt;(<span class="type">float</span> a, <span class="type">float</span> b)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">double</span> <span class="built_in">add</span>&lt;<span class="type">double</span>&gt;(<span class="type">double</span> a, <span class="type">double</span> b)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">add</span>(<span class="number">1.0F</span>, <span class="number">2.0F</span>);</span><br><span class="line">  <span class="built_in">add</span>(<span class="number">1.0</span>, <span class="number">2.0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="全特化和偏特化"><a href="#全特化和偏特化" class="headerlink" title="全特化和偏特化"></a>全特化和偏特化</h2><p>​<strong>全特化</strong>：一个模板的所有模板参数都被具体化时，称为全特化。它为特定的一组参数提供了一个完全独立的实现。简单来说，全特化就是模板中的参数都是我们指定的，不存在需要编译器推导的模板参数。</p><p>​下面的例子中，我们提供了一个<code>T</code>为<code>double</code>类型时的全特化版本，当函数实参为<code>double</code>类型时，由于<strong>全特化版本优先级</strong> &gt; <strong>普通模板优先级</strong>，所以会优先调用全特化版本。由于全特化模板时，所有的模板参数都是我们明确指定的，模板声明时就不用声明任何模板参数，但是仍然需要使用<code>template&lt;&gt;</code>来声明这是一个模板函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模板实现</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">addTemplate</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;normal&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="comment">//虽然没有模板参数，但是仍需要该语句声明这个是一个模板函数</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">addTemplate</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;all&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">addTemplate</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//调用的普通模板函数</span></span><br><span class="line"><span class="built_in">addTemplate</span>(<span class="number">1.0</span>, <span class="number">2.0</span>); <span class="comment">//调用的针对double类型的全特化版本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<strong>偏特化</strong>：当一个类模板（注意：<strong>函数模板没有偏特化</strong>，只有重载）的<strong>某些模板参数被具体化</strong>，而<strong>另一些仍保持泛型时</strong>，称为偏特化。主要是为一类参数（不是单个具体参数）提供专门的实现。简单来说就是，仍然存在模板参数需要编译器推导，但是我们可以对这些模板参数进行一些限制或者修饰，为符合条件的一类提供实现。</p><p>​下面的例子中，偏特化中仍然存在模板参数<code>T</code>，但是函数的参数列表却变成了<code>T*</code>类型，这就是前面说的对模板参数进行一些限制，这表明这个偏特化版本会接收所有类型的指针。同样，由于<strong>偏特化优先级 &gt; 普通模板</strong>，会有限调用偏特化版本。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模板实现</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">addTemplate</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;normal&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在模板类中叫做偏特化，但是模板函数没有偏特化，只有函数重载</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">addTemplate</span><span class="params">(T* a, T* b)</span> <span class="comment">//形参列表为T*，表面这是专门接收各种类型的指针，当接收指针时就调用他</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;special&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> *a + *b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">2</span>, b = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">addTemplate</span>(a, b); <span class="comment">//调用的普通模板函数</span></span><br><span class="line"><span class="built_in">addTemplate</span>(&amp;a, &amp;b); <span class="comment">//调用的针对所有指针类型的版本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​这里说明一下，<strong>类模板和函数模板都有全特化</strong>，<strong>只有类模板有偏特化</strong>，模板函数实现偏特化的功能<strong>就是函数重载</strong>。并且主模板、偏特化和全特化的调用优先级如下：</p><p><strong>全特化 &gt; 偏特化 &gt; 主模板</strong></p><p>​可以理解为全特化因为指定了所有模板参数，是特化最强的版本，所以要优先调用。偏特化只是给模板参数添加了一些修饰和现在，是特化弱于全特化的版本，优先级中等。主模板则是最通用、最基础的模板版本，如果找不到特化版本就调用主模板的版本，属于是兜底的下下之策。</p><h2 id="模板参数"><a href="#模板参数" class="headerlink" title="模板参数"></a>模板参数</h2><p>​模板参数是模板进行编译时计算和类型操作的“变量”。分为三种主要类型：类型参数、非类型参数和模板的模板参数三类。</p><h3 id="类型参数"><a href="#类型参数" class="headerlink" title="类型参数"></a>类型参数</h3><p>​这是最常见的模板参数形式，以 <code>typename T</code> 或 <code>class T</code> 定义（模板声明时这两个关键字是等价的）；模板接受任意类型作为参数。模板参数T可以声明类模板的成员变量、函数模板中的函数参数和返回值等。同时也可以像函数形参那样给我们的模板类型参数指定默认类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模板声明的时候typename和class一样，同时也可以给模板参数指定默认类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="type">int</span>, <span class="keyword">class</span> U = <span class="type">float</span>&gt;</span><br><span class="line"><span class="keyword">class</span> Test</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//声明函数形参</span></span><br><span class="line"><span class="built_in">Test</span>(T a, U b)</span><br><span class="line">:<span class="built_in">m_A</span>(a), <span class="built_in">m_B</span>(b)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Test</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用作返回值</span></span><br><span class="line">T <span class="built_in">GetA</span>() &#123; <span class="keyword">return</span> m_A; &#125;</span><br><span class="line"><span class="function">U <span class="title">GetB</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_B; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//声明成员变量</span></span><br><span class="line">T m_A;</span><br><span class="line">U m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//显示指明类型</span></span><br><span class="line"><span class="function">Test&lt;<span class="type">int</span>, <span class="type">float</span>&gt; <span class="title">t1</span><span class="params">(<span class="number">1</span>, <span class="number">2.0f</span>)</span></span>;</span><br><span class="line"><span class="comment">//自动推导类型</span></span><br><span class="line"><span class="function">Test <span class="title">t2</span><span class="params">(<span class="number">1</span>, <span class="number">2.0f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没有传值，无法自动推导，使用默认类型</span></span><br><span class="line">Test&lt;&gt;<span class="built_in">t3</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非类型参数"><a href="#非类型参数" class="headerlink" title="非类型参数"></a>非类型参数</h3><p>​非类型参数允许模板接受<strong>编译时常量</strong>作为参数，这些参数在<strong>编译时是已知</strong>的，所以可以直接参与编译时计算。经典的使用就是C++标准模板库里的<code>std::array&lt;type, size&gt;</code>，我们可以指定一个类型和一个参数指定数组的大小。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">int</span> size&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Array</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">Get</span><span class="params">(<span class="type">uint32_t</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (idx &gt;= size)</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;索引越界&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> m_Arr[idx];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(<span class="type">uint32_t</span> idx, T val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (idx &gt;= size)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">m_Arr[idx] = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T m_Arr[size];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//Array&lt;int, size&gt; arr1; 编译错误，传入的大小必须是编译器就能确定的常量</span></span><br><span class="line">    <span class="type">int</span> size = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编译成功</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line">    Array&lt;<span class="type">int</span>, n&gt; arr1; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定类型和大小</span></span><br><span class="line">    Array&lt;<span class="type">int</span>, <span class="number">3</span>&gt; arr;</span><br><span class="line">    arr.<span class="built_in">Set</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    arr.<span class="built_in">Set</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    arr.<span class="built_in">Set</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    std::cout &lt;&lt; arr.<span class="built_in">Get</span>(<span class="number">0</span>) &lt;&lt; std::endl; <span class="comment">//正常访问</span></span><br><span class="line">    std::cout &lt;&lt; arr.<span class="built_in">Get</span>(<span class="number">5</span>) &lt;&lt; std::endl; <span class="comment">//触发索引越界异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板的模板参数"><a href="#模板的模板参数" class="headerlink" title="模板的模板参数"></a>模板的模板参数</h3><p>​这种参数类型允许一个模板<strong>接受另一个模板作为参数</strong>。这在需要操作或生成其他模板时非常有用，提供了更高层次的抽象和泛化能力。普通的模板参数是一个类型或者值，模板的模板模板参数则是一个<strong>是一个未被实例化的模板类</strong>，而非普通类型或值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">int</span> size&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Array</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">Get</span><span class="params">(<span class="type">uint32_t</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (idx &gt;= size)</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;索引越界&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> m_Arr[idx];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(<span class="type">uint32_t</span> idx, T val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (idx &gt;= size)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">m_Arr[idx] = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T m_Arr[size];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">int</span> size&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OtherArray</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//template&lt;typename T,int size, Array&lt;T, size&gt; arr&gt; 这种声明是错误的，听完模板的模板参数可以接收任何符合要求的类模板</span></span><br><span class="line"><span class="comment">//模板的模板参数的的写法就是声明一个模板类的标准写法，他会接收所以符合该模板参数要求的类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="type">int</span> size, <span class="keyword">template</span>&lt;<span class="keyword">typename</span>, <span class="type">int</span>&gt; <span class="keyword">class</span> <span class="title class_">ContainerTemplate</span> &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayContainer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">ContainerTemplate&lt;T, size&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ArrayContainer&lt;int, 5, Test&gt; arrayContainer; 编译错误，因为Test和我们指定的ContainerTemplate不兼容</span></span><br><span class="line">    ArrayContainer&lt;<span class="type">int</span>, <span class="number">5</span>, Array&gt; arrayContainer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不止Array能使用，只要模板参数和ContainerTemplate兼容的类模板都可以当作参数传进去</span></span><br><span class="line">    ArrayContainer&lt;<span class="type">int</span>, <span class="number">5</span>, OtherArray&gt; otherArrayContainer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h2><p>​前面介绍的模板其模板参数都是固定数量的，也就是我们在<code>&lt;&gt;</code>指定了几个，使用时就需要写上几个。而可变参数模板中的模板参数是不固定的，需要使用特定的语法接收和展开。</p><h2 id="模板中的类型推导"><a href="#模板中的类型推导" class="headerlink" title="模板中的类型推导"></a>模板中的类型推导</h2><h2 id="SFINAE"><a href="#SFINAE" class="headerlink" title="SFINAE"></a>SFINAE</h2><p>​<strong>SFINAE</strong> 的全称是 “<strong>Substitution Failure Is Not An Error</strong>”，直译过来是“<strong>替换失败不是一个错误</strong>”。</p><h2 id="模板元编程（Template-meta-programming，TMP）"><a href="#模板元编程（Template-meta-programming，TMP）" class="headerlink" title="模板元编程（Template meta programming，TMP）"></a>模板元编程（Template meta programming，TMP）</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/11/22/hello-world/"/>
      <url>/2025/11/22/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
