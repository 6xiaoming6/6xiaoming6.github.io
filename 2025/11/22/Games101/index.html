<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Games101课堂笔记和作业, 小明茶馆">
    <meta name="description" content="GAME101课程的笔记和作业总结">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Games101课堂笔记和作业 | 小明茶馆</title>
    <link rel="icon" type="image/svg+xml" href="/myfavicon.svg">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 8.1.1"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/mylogo.svg" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">小明茶馆</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fa-brands fa-bilibili fa-beat-fade" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fas fa-list" style="zoom: 0.6;"></i>
      
      <span>多媒体</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/musics">
          
          <i class="fas fa-music" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>音乐</span>
        </a>
      </li>
      
      <li>
        <a href="/movies">
          
          <i class="fas fa-film" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>电影</span>
        </a>
      </li>
      
      <li>
        <a href="/books">
          
          <i class="fas fa-book" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>阅读</span>
        </a>
      </li>
      
      <li>
        <a href="/galleries">
          
          <i class="fas fa-image" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>相册</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/mylogo.svg" class="logo-img circle responsive-img">
        
        <div class="logo-name">小明茶馆</div>
        <div class="logo-desc">
            
            每天都要比昨天优秀一点
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fa-brands fa-bilibili fa-beat-fade"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-list"></i>
			
			多媒体
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>

                  <a href="/musics " style="margin-left:75px">
				  
				   <i class="fa fas fa-music" style="position: absolute;left:50px" ></i>
			      
		          <span>音乐</span>
                  </a>
                </li>
              
                <li>

                  <a href="/movies " style="margin-left:75px">
				  
				   <i class="fa fas fa-film" style="position: absolute;left:50px" ></i>
			      
		          <span>电影</span>
                  </a>
                </li>
              
                <li>

                  <a href="/books " style="margin-left:75px">
				  
				   <i class="fa fas fa-book" style="position: absolute;left:50px" ></i>
			      
		          <span>阅读</span>
                  </a>
                </li>
              
                <li>

                  <a href="/galleries " style="margin-left:75px">
				  
				   <i class="fa fas fa-image" style="position: absolute;left:50px" ></i>
			      
		          <span>相册</span>
                  </a>
                </li>
              
            </ul>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/feature_map/6.png')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Games101课堂笔记和作业</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/">
                                <span class="chip bg-color">计算机图形学</span>
                            </a>
                        
                            <a href="/tags/GAMES101/">
                                <span class="chip bg-color">GAMES101</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/" class="post-category">
                                计算机图形学
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2025-11-22
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2025-11-25
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    21.3k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    74 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="常用英语"><a class="header-anchor" href="#常用英语"></a>常用英语</h1>
<ol>
<li>raster 光栅</li>
<li>tringle 三角形</li>
<li>mesh 网格</li>
<li>Anti-Aliasing，AA 反走样（抗锯齿）</li>
</ol>
<h1 id="补充知识"><a class="header-anchor" href="#补充知识"></a>补充知识</h1>
<h2 id="Barycentric-Coordinates-重心坐标"><a class="header-anchor" href="#Barycentric-Coordinates-重心坐标"></a>Barycentric Coordinates(重心坐标)</h2>
<p>在着色方法中的<strong>顶点着色</strong>部分提到了先求出三个顶点处的颜色，然后三角形内部的颜色采用<strong>插值</strong>实现在三个顶点间<strong>渐变</strong>颜色，为此引入了重心坐标来解决问题。本质上就是根据三角形的三个顶点的颜色值，得出三角形内部任意一点的颜色值，实现颜色的平滑过渡。</p>
<p>插值可以对三角形中的任意属性，比如任意像素的颜色、深度等，都可以通过插值处理。</p>
<h3 id="定义"><a class="header-anchor" href="#定义"></a>定义</h3>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240119171752928.png" alt="image-20240119171752928" style="zoom:67%;" />
<p>给定三角形的三点坐标A, B, C，该<strong>平面内一点</strong>(x,y)可以写成这三点坐标的线性组合形式，即 <strong>( x , y ) = α A + β B + γ C</strong>且满足 <strong>α + β + γ = 1</strong>， 则称此时3个坐标A,B,C的权重<strong>α , β , γ</strong> 为点( x , y ) 的<strong>重心坐标</strong>。<br>
【<strong>注意：<strong>只满足上面两个条件只是保证该点在三角形所在平面上。必须当</strong>α , β , γ</strong> 均为<strong>非负数</strong>时，该点才在三角形<strong>内部</strong>】</p>
<p>举个栗子：我们求A的重心坐标，如下图所示，可以得出A的重心坐标为(1，0，0)。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240119172353379.png" alt="image-20240119172353379" style="zoom:67%;" />
<h3 id="三角形内任意一点中心坐标求解"><a class="header-anchor" href="#三角形内任意一点中心坐标求解"></a>三角形内任意一点中心坐标求解</h3>
<p>对于三角形内任意一点，我们将该点与A,B,C相连，可以得到三个小三角形，那么与之对应的<strong>α , β , γ</strong> 值可以通过小三角形面积与总三角形面积的比值得到，如下图所示。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240119172733749.png" alt="image-20240119172733749" style="zoom:67%;" />
<p>将上式进一步推导求解可以得到另外一种形式。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240119173117762.png" alt="image-20240119173117762" style="zoom:67%;" />
<h3 id="应用重心坐标做插值处理"><a class="header-anchor" href="#应用重心坐标做插值处理"></a>应用重心坐标做插值处理</h3>
<p>通过上面的描述得来，在三角形中，我们可以把三角形内任一点的任意属性通过三个顶点的线性组合得来。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240119173224511.png" alt="image-20240119173224511" style="zoom: 67%;" />
<h1 id="Transformation-变换"><a class="header-anchor" href="#Transformation-变换"></a>Transformation(变换)</h1>
<h2 id="2DTransformations-2维变换"><a class="header-anchor" href="#2DTransformations-2维变换"></a>2DTransformations(2维变换)</h2>
<h3 id="线性变换"><a class="header-anchor" href="#线性变换"></a>线性变换</h3>
<ul>
<li>
<h2 id="Scale-缩放变换"><a class="header-anchor" href="#Scale-缩放变换"></a>Scale(缩放变换)</h2>
</li>
</ul>
<p>把每个点的x,y坐标分别按相同的比例进行缩放。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240115120839898.png" alt="image-20240115120839898" style="zoom:50%;" />
<p>这种操作可以写成以下的数学形式</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240115121232580.png" alt="image-20240115121232580" style="zoom:50%;" />
<p>上式可以进一步写为矩阵相乘形式，S的那个矩阵称为<strong>缩放矩阵</strong>。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240115121305055.png" alt="image-20240115121305055" style="zoom:50%;" />
<ul>
<li>
<h3 id="Relfection-反射变换"><a class="header-anchor" href="#Relfection-反射变换"></a>Relfection(反射变换)</h3>
</li>
</ul>
<p>其实就是镜像反转以下，数学中就是所有点根据y轴对称过去。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240115121527251.png" alt="image-20240115121527251" style="zoom: 50%;" />
<ul>
<li>
<h3 id="Shear-错切变换"><a class="header-anchor" href="#Shear-错切变换"></a>Shear(错切变换)</h3>
</li>
</ul>
<p>大概就是将原图根据一个角进行拉伸，如下图所示。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240115140057237.png" alt="image-20240115140057237" style="zoom:50%;" />
<ul>
<li>
<h3 id="Rotate-旋转变换"><a class="header-anchor" href="#Rotate-旋转变换"></a>Rotate(旋转变换)</h3>
</li>
</ul>
<p>就是图像绕着一个点进行选择，图中是绕原点逆时针旋转。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240115141040006.png" alt="image-20240115141040006" style="zoom:50%;" />
<p>上述的所有变换都可以用下面的式子表示，如果符合这个式子的变换，那么叫做<strong>线性变换</strong>。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240115141150892.png" alt="image-20240115141150892" style="zoom:50%;" />
<ul>
<li>
<h3 id="Translation-平移变换"><a class="header-anchor" href="#Translation-平移变换"></a>Translation(平移变换)</h3>
</li>
</ul>
<p>就是把一个图像沿x、y轴平移一些距离，但是这种变换不能用上面的那种矩阵形式得来，所有平移变换<strong>不属于线性变换</strong>。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240115141704545.png" alt="image-20240115141704545" style="zoom:50%;" />
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240115141822651.png" alt="image-20240115141822651" style="zoom: 80%;" />
<h3 id="Homogeneous-Matrix-齐次坐标"><a class="header-anchor" href="#Homogeneous-Matrix-齐次坐标"></a>Homogeneous Matrix(齐次坐标)</h3>
<p>由于<strong>平移变换并不满足线性变换的表达形式</strong>，所以在处理过程中要对平移操作当作特殊操作。为了解决这个问题，于是便引入了<strong>齐次坐标</strong>，通过给变换矩阵增加一个纬度，使得上述所有变换都有一个统一的形式表达（矩阵 <strong>·</strong> 向量）。</p>
<p>引入的新维度，向量和点的形式不同。对于一个点，新增纬度的值为1；对于一个向量，新增纬度的值为0。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240115145542395.png" alt="image-20240115145542395" style="zoom:67%;" />
<p>从下图可以看到，通过外引入一个参数后，二维点坐标也变为了三维。但与此同时，平移变换也可以写成矩阵与向量相乘的统一形式。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240115145525316.png" alt="image-20240115145525316" style="zoom:50%;" />
<p>在齐次坐标中任何一个点(x,y,w)，都可以转换成在笛卡尔坐标系中的点(x/w,y/w)。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240115150154510.png" alt="image-20240115150154510" style="zoom: 50%;" />
<p>下图是一些变换在齐次变换中的二维变换矩阵。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240115150632168.png" alt="image-20240115150632168" style="zoom: 67%;" />
<h3 id="Affine-Transformations-仿射变换"><a class="header-anchor" href="#Affine-Transformations-仿射变换"></a>Affine Transformations(仿射变换)</h3>
<p>对于所有可以用下列形式表示的变换，称为<strong>仿射变换</strong>。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240115150428521.png" alt="image-20240115150428521" style="zoom: 67%;" />
<p>所有的仿射变换都可以通关引入齐次坐标写成以下形式。这样我们就把所有的变换统一成一种形式了。这种写法表示的是先进行线性变换，再进行平移操作。</p>
<p>可以看到变换矩阵的<strong>最后一列是与点平移有关的</strong>，<strong>最后一行是始终为(0, 0, 1)</strong>，左上角2x2大小的范围控制点的旋转平移等变换。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240115150537162.png" alt="image-20240115150537162" style="zoom: 67%;" />
<h3 id="Composing-Transforms-组合变换"><a class="header-anchor" href="#Composing-Transforms-组合变换"></a>Composing Transforms(组合变换)</h3>
<p>一系列复杂的变换都可以由这些基本变换得来，而且和变换的<strong>顺序有关</strong>(矩阵乘法不满足交换律)。从右向左运算结果依次作用于矩阵，下图中就表示先旋转45度，再平移一个单位。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240115144233249.png" alt="image-20240115144233249" style="zoom:80%;" />
<p>由矩阵运算的结合律可知，下图等式右侧的n个矩阵可以先进行运算得到一3维个矩阵，再把这个矩阵和右侧向量相乘结果一样的。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240115144415627.png" alt="image-20240115144415627" style="zoom:67%;" />
<h2 id="3DTransfroms-3维变换"><a class="header-anchor" href="#3DTransfroms-3维变换"></a>3DTransfroms(3维变换)</h2>
<p>同样，在三维空间中也有平移变换，所以也需要引入齐次坐标，用四维的向量表示一个点或者向量，用四维矩阵表示3维空间的变换矩阵。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240115150829738.png" alt="image-20240115150829738" style="zoom:50%;" />
<p>与二维变换类似，变换矩阵的最后一列是平移相关的参数，最后一行始终为(0, 0, 0, 1)，左上角3x3区域是旋转缩放等变换的参数。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240115150902525.png" alt="image-20240115150902525" style="zoom: 67%;" />
<p>下面是三维空间中的旋转和平移变换矩阵：</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250903232724015.png" alt="image-20250903232724015" style="zoom:67%;" />
<p>下面是三维空间中分别绕着x、y、z轴旋转的旋转矩阵。</p>
<p><img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250903232659772.png" alt="image-20250903232659772"></p>
<p>上面三个旋转矩阵都是针对于绕某个轴旋转的的情况下，那么对于一般情况下对于任意一个旋转，该怎么写旋转矩阵呢？</p>
<p>一种简单的做法就是将任意的旋转拆解为绕三个轴先后旋转的组合，再将三个旋转矩阵相乘即可，这里的旋转叫就叫做欧拉角（Euler Angles）。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250904234749225.png" alt="image-20250904234749225" style="zoom: 50%;" />
<p>也可以使用<strong>罗德里格斯公式</strong>直接求出绕任意轴 $\vec{n}$ 旋转的旋转矩阵：</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250904234933674.png" alt="image-20250904234933674" style="zoom:67%;" />
<h2 id="View-Camera-Transformation"><a class="header-anchor" href="#View-Camera-Transformation"></a>View/Camera Transformation</h2>
<p>这一步可以按照拍照理解，就是将三维的世界投影到2维图像上。</p>
<p>对于一个相机，我们需要知道他的位置、正面朝向和上方向，分别就用 $\vec{e}$ 、 $\vec{y}$ 和 $\vec{t}$ 三个向量来表示。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240115155212445.png" alt="image-20240115155212445" style="zoom:50%;" />
<p>对于拍照来说，只要背景一样、相机和拍摄物体的相对位置一样，不论在哪里拍出来的东西都是一样的。在渲染中也是一样的，无论相机在哪，角度如何。我们始终都把相机固定到固定位置，固定角度的状态，为了保证相机和物体的相对位置不发生变化，场景内的物体也要随相机做同样的变换。（这种理解和<strong>将顶点坐标从模型坐标系变换到摄像机坐标系的理解是等价的</strong>，前者是空间位置的变换，后者是坐标系的变换）</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250904235902312.png" alt="image-20250904235902312" style="zoom:67%;" />
<p>为了简化计算，规定相机的固定状态：相机始终在(0,0,0)原点位置，且相机始终向-Z方向看，上方向为Y轴正方向。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240115155621631.png" alt="image-20240115155621631" style="zoom:67%;" />
<p>当我们知道了相机的位置和旋转角度时，需要将相机变换到我们的固定状态去。首先使用平移变换将相机移动到坐标原点(0, 0, 0)，然后再进行旋转变换将相机的朝向与-z轴重合，上方向与y轴重合。当两个轴与坐标轴重合后，相机的右方向自然也就和x轴重合了。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250905224315450.png" alt="image-20250905224315450" style="zoom:67%;" />
<p>​	对于第一步平移的变换矩阵很好写。第二步需要将相机的各个方向进行旋转后与坐标轴重合，但是从任意轴旋转到坐标轴的旋转矩阵不好写，但是将坐标轴变换到任意轴的旋转矩阵是容易写出来的。又因为变换矩阵的逆矩阵表示相反的变换，所以我们可以写出将坐标轴变换到任意轴的旋转矩阵，再求其逆矩阵就得到了要求的旋转矩阵。又因为旋转矩阵是正交矩阵，正交矩阵的逆矩阵就是其转置矩阵，于是就求出了对应的旋转矩阵。</p>
<p>​	于是我们要求的视图变换矩阵 <strong>ViewMatrix = R * T</strong>。（将两个变换矩阵按照先平移后旋转的顺序相乘即可）</p>
<p>​	由于要保证相机和场景内物体的相对运动不变，场景内的所有顶点也要乘上视图变化矩阵。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250905224957251.png" alt="image-20250905224957251" style="zoom:67%;" />
<h2 id="Projection-Transformation-投影变换"><a class="header-anchor" href="#Projection-Transformation-投影变换"></a>Projection Transformation(投影变换)</h2>
<p>投影分为<strong>正交投影</strong>和<strong>透视投影</strong>，两种投影的本质区别就是<strong>是否会产生进大远小的视觉效果</strong>后者会产生这种效果，前者则没有。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240115161825742.png" alt="image-20240115161825742" style="zoom:50%;" />
<h3 id="Orthographic-Projection-正交投影"><a class="header-anchor" href="#Orthographic-Projection-正交投影"></a>Orthographic  Projection(正交投影)</h3>
<p>正交投影较为简单，因为相机的投影盒是一个立方体。只需要先把投影盒中心平移到原点，场景中所有顶点跟随投影盒做相同平移变换；再投影盒范围缩放到[-1,1]，场景中的顶点也做同样的缩放变换。</p>
<p>这样变换后，所有在<strong>投影盒内的顶点坐标</strong>范围<strong>均为[-1, 1]</strong>，所有<strong>不在投影盒内的顶点坐标</strong>范围**都不在[-1, 1]**内。</p>
<p>所以正交投影矩阵也较为简单，只需要根据投影盒的边界进行一次平移变换和一次缩放变换即可。</p>
<p>下<strong>面图示及推到过程中和最终矩阵里的n，f以及其他边界，都是使用的边界的坐标值（有正有负）。</strong></p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240115162552686.png" alt="image-20240115162552686" style="zoom:67%;" />
<h3 id="Perspective-Projection-透视投影"><a class="header-anchor" href="#Perspective-Projection-透视投影"></a>Perspective Projection(透视投影)</h3>
<p>符合人眼看见的效果，会出现进大远小的视觉效果，会让平行线变得看起来不再平行。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240115164743885.png" alt="image-20240115164743885" style="zoom: 67%;" />
<p>透视投影的视图就是从相机位置向朝向发射出一个锥型区域，而且进大远小。如果我们想得到透视投影的话，需要先把上图中的锥体<strong>挤压</strong>成右侧的立方体，然后再对立方体进行<strong>正交投影</strong>。最终的投影结果就是透视投影的结果。正交投影我们已经知道怎么做，最大的问题就是如何把锥体挤压成立方体，下面来具体介绍。</p>
<p>首先我们先侧面观察一下前后两个截面坐标之间的关系。由相似三角形的知识我们不难得出图中右侧的结论，因为挤压只会远端平面改变x和y的值，z并不改变，所以x和y值都满足图中右侧的关系。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240115165515788.png" alt="image-20240115165515788" style="zoom:67%;" />
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240115165630899.png" alt="image-20240115165630899" style="zoom:67%;" />
<p>通过上图我们可以清晰的看到远端平面中x和y值挤压后变换的结果，在齐次坐标中对一点(x,y,z,1)，可以写出挤压后的点坐标(齐次坐标中参数同时乘一个数表示的还是一个点)，最终最右侧的坐标就是我们变换后的点坐标。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240115172433597.png" alt="image-20240115172433597" style="zoom: 67%;" />
<p>坐标的变换可以通关乘一个变换矩阵得到，现在我们已经有了变换后的<strong>部分</strong>结果，可以反推出变换矩阵的<strong>部分内容</strong>。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240115172712495.png" alt="image-20240115172712495" style="zoom:67%;" />
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240115172749715.png" alt="image-20240115172749715" style="zoom:67%;" />
<p>然后问题就会转换成求变换矩阵第三行这个较为简单的问题。</p>
<p>在变换中有两个观测事实：</p>
<ol>
<li>近平面的所有点都不会发生改变(变换矩阵乘近平面的任何点还是会得到原来的点)。</li>
<li>远平面的经过变换之后不会发生改变</li>
</ol>
<p>下面是根据<strong>第一条</strong>事实得出的等式</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240115173354452.png" alt="image-20240115173354452" style="zoom:67%;" />
<p>可以写出变换矩阵第三行的部分内容为(0,0,A,B)，其中A,B未知。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240115173806097.png" alt="image-20240115173806097" style="zoom:67%;" />
<p>现在根据<strong>第二条</strong>事实可以再写出一个等式。(取远端平面上的**(0,0,f)**点为例)</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240115173819454.png" alt="image-20240115173819454" style="zoom:67%;" />
<p>最终可以根据二元一次方程组解法求出A和B最大值。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240115173933835.png" alt="image-20240115173933835" style="zoom:67%;" />
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240115174004580.png" alt="image-20240115174004580" style="zoom:67%;" />
<p>根据这个变换矩阵把锥形体挤压为标准立方体后，再进行正交投影即可得到透视投影的结果。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250910103731638.png" alt="image-20250910103731638" style="zoom: 80%;" />
<p><strong>PS：由于我们这里是右手坐标系，摄像机是看向-z轴的。这里所提到的n和f是指近平面和远平面与相机的z坐标，而near和far表示距离是z坐标的绝对值。前面说了我们是看向-z轴的所以，近平面和远平面的z坐标均为负数，因此有near = -n，far = -f，将其带入矩阵可得：</strong></p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250910105939911.png" alt="image-20250910105939911" style="zoom: 80%;" />
<p>这样变换后，我们可以发现：近平面zNear的z坐标为1，远平面zFar的z坐标为-1。也就是说，离摄像机越近的物体z值越大，离摄像机越远的物体z值越小，这和深度测试中是相反的，也不符合人直觉。</p>
<p>为了解决这一问题，我们需要将z轴进行翻转，使得我们的z值和深度测试中是对应的，即距离近z值小，距离远z值大。（如果在投影矩阵的推到中将近平面映射到-1，远平面映射到1，最终得到的投影矩阵是一样的）。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250910111222175.png" alt="image-20250910111222175" style="zoom:80%;" />
<p>再将投影矩阵和翻转矩阵相乘，我们也就从右手坐标系转到了左手坐标系。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250910111246438.png" alt="image-20250910111246438" style="zoom:80%;" />
<p>也等价于这个矩阵(都用包围盒边界坐标轴表示)。</p>
<p><img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250910113957251.png" alt="image-20250910113957251"></p>
<p>其中为了简化透视投影中各项参数的定义，使其更符合人的直觉，定义参数aspect和fov。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250910085929626.png" alt="image-20250910085929626" style="zoom:67%;" />
<p>我们可以利用fov，aspect，near和far求出l，r，b，t。</p>
<p><img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250910090048434.png" alt="image-20250910090048434"></p>
<h2 id="Viewport-Transformation-视口变换"><a class="header-anchor" href="#Viewport-Transformation-视口变换"></a><strong>Viewport Transformation</strong>(视口变换)</h2>
<p>这个变换就是把我们经过MVP操作得到的标准立方体在二维平面的投影均匀的映射到屏幕范围内，即[-1,1]^2→[0,width]*[0,height], 其中width和height指屏幕分辨率大小。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240116200330459.png" alt="image-20240116200330459" style="zoom:50%;" />
<p>下面就是变换矩阵，操作是先把原来[-1,1]^2的图拉伸到[0,width]*[0,height]的大小，然后再平移使得左下角在原点。这样我们就可以把三维空间中的任意变换放到屏幕上了。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240116200341692.png" alt="image-20240116200341692" style="zoom: 67%;" />
<p><strong>MVP概念</strong></p>
<p>MPV是计算机图形学中前面三中变换的缩写,我们把三维空间转换维二维图片首先要经过MVP操作，然后进行光栅化，就可以转换成2维图像呈现出来。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240116194407072.png" alt="image-20240116194407072" style="zoom:67%;" />
<h1 id="rasterization-光栅化"><a class="header-anchor" href="#rasterization-光栅化"></a>rasterization(光栅化)</h1>
<p>经过上述变换操作，我们可以得到三维空间中的任意物体变换后在屏幕中分布的信息（NDC坐标，范围[-1, 1]），然后我们需要进行视口变换，将范围为[-1, 1]的各个点坐标映射到大小为width × height的二维屏幕的像素坐标上，最终把颜色绘制在屏幕上的一个个像素块上。</p>
<p>而这里说的<strong>光栅化</strong>就是就是根据这些点信息转化为像素并<strong>画到屏幕上的过程</strong>。</p>
<h2 id="视口变换"><a class="header-anchor" href="#视口变换"></a>视口变换</h2>
<p>在这里，我们将一个个的像素看做大小都相等的正方向块，而且每个像素块内的颜色都是一样的（即每个像素块都是纯色块）。</p>
<p>下图定义了一个屏幕空间，左下角是(0, 0)点，屏幕空间由一个个像素组成。像素的坐标都为整数，且从0开始，下图中蓝色的像素坐标为(2, 1)。像素的中心点就在正方形的中心，每个像素长度为1，那么对于坐标为(x, y)的像素来说，其中心点坐标为</p>
<p>(x+0.5, y+0.5)。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250905231834967.png" alt="image-20250905231834967" style="zoom:50%;" />
<p>定义好了屏幕空间后，我们就可以将将范围为[-1, 1]的各个点坐标映射到大小为width × height的二维屏幕空间上。将范围为[-1, 1]的x和y坐标分别映射为[0, width]和[0, height]。 z坐标的变换现在暂时不用关系，后面介绍遮挡时会用到。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250905232201174.png" alt="image-20250905232201174" style="zoom:50%;" />
<p>实现这样的变换，只需要构造这样一个视口变换矩阵即可。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250905232309485.png" alt="image-20250905232309485" style="zoom:50%;" />
<h2 id="走样"><a class="header-anchor" href="#走样"></a>走样</h2>
<p>当我们想把一个图像绘制到屏幕上时（这里用三角形举例，三角形用的多），在<strong>简单采样</strong>中会根据像素的中心点是否在三角形内来决定这个像素的颜色，在屏幕中显示出这些像素的颜色，实现在屏幕的绘制，如下图所示。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240116222801328.png" alt="image-20240116222801328" style="zoom:67%;" />
<p>但是我们希望看到的三角形是下图中所示的样子，通过上面的变换会出现很多的棱角，就出现了所谓的<strong>锯齿</strong>效果，也叫走样。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240116222858676.png" alt="image-20240116222858676" style="zoom: 80%;" />
<h2 id="反走样"><a class="header-anchor" href="#反走样"></a>反走样</h2>
<p>锯齿的学名叫做<strong>Aliasing(走样)</strong>，在很多情况下都会出现，如下图所示。将一张图片不断放大，当放大到一定程度时就会看到这些小锯齿。为了解决这种问题，我们要进行<strong>反走样(Anti-Aliasing，AA)或抗锯齿</strong>。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240116223218011.png" alt="image-20240116223218011" style="zoom: 50%;" />
<h3 id="模糊处理"><a class="header-anchor" href="#模糊处理"></a>模糊处理</h3>
<p>简单的解决方法就是我们<strong>先</strong>对原图像进行<strong>模糊处理</strong>，然后再对<strong>模糊后的图像</strong>进行<strong>采样</strong>，可以在一定程度上消除锯齿。必须是<strong>先模糊再采样</strong>才有效果，如果对先采样得到的锯齿图片模糊处理则不会有效果。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240116223531674.png" alt="image-20240116223531674" style="zoom:67%;" />
<p>模糊处理的方法就是对图像进行<strong>卷积操作</strong>，使得每一块区域内的值有一个平均，从而达到模糊处理的效果。下图就是卷积操作的一个示例图，这里我们把用于卷积运算的那个矩阵叫做<strong>滤波器</strong>。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240116223923769.png" alt="image-20240116223923769" style="zoom: 67%;" />
<p>对于部分在三角形内部的像素块来说，不使用01变换的方式，而是将这个像素内部的值做一个平均操作，本质上也就是进行了一个卷积操作。这样处理过后，三角形边界的像素即使部分在三角形内部，也会有一个模糊后的颜色，会让边缘的锯齿变得光滑一些，以达到反走样的效果。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250807211000337.png" alt="image-20250807211000337" style="zoom:50%;" />
<p>反走样的原理并不复杂，但是要实现这一效果需要知道三角形覆盖某一像素的面积，这一才能将像素部分区域的颜色平均到整个像素中。我们无法准确的计算出这一结果，但是可以通过一些算法来<strong>近似计算道三角形覆盖某一像素的面积</strong>。</p>
<p>常见的抗锯齿方法（<strong>超采样</strong>）有：MSAA（多重采样抗锯齿，Multisample Anti-Aliasing），FXAA（快速近似抗锯齿，Fast Approximate Anti-Aliasing），TAA（时间性抗锯齿，Temporal Anti-Aliasing）。这些方法都不是提高采样率，增大分辨率实现抗锯齿的，只是使用某种方法近似计算一个像素在三角形内的面积，更好的实现图像的模糊操作。本质上还是通过先<strong>模糊</strong>后采样的策略实现抗锯齿的。</p>
<p>也可以通过<strong>超分辨率</strong>技术解决抗锯齿：DLSS（深度学习超采样，Deep Learning Supre Sampling），本质上是把一张低分辨率的图片放大为一张高分辨率的图片，放大后多出来的像素细节就使用深度学习进行补全，通过**提高了分辨率(采样率)**来实现抗锯齿。</p>
<h3 id="MSAA-Multi-Sample-AA"><a class="header-anchor" href="#MSAA-Multi-Sample-AA"></a>MSAA(Multi Sample AA)</h3>
<p>MSAA对多边形的边缘进行多重采样（通常是 2x、4x、8x），假设使用的是4x的MSAA，就会将像素内的采样点由变为4x4=16个，相当于把一个像素划分为了4x4的网格。根据在三角形内部的点数来估计一个像素在三角形内部的面积。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250807212441176.png" alt="image-20250807212441176" style="zoom: 50%;" />
<p>下图是2x的例子，根据一个像素在三角形内部的采样点占一个像素所有采样点的百分比估计一个像素在三角形内的面积。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250807212643581.png" alt="image-20250807212643581" style="zoom: 67%;" />
<p>显然，一个像素的采样点越多，抗锯齿的效果越好，但是带来的性能消耗也越多，因为一个像素判断的采样点所作的运算也更多。</p>
<h3 id="FXAA-Fast-Approximate-AA"><a class="header-anchor" href="#FXAA-Fast-Approximate-AA"></a>FXAA(Fast Approximate AA)</h3>
<p>对于一个三角形来说，我们需要抗锯齿的地方就是三角形的边界部分。FXAA的做法就是集中于边界的处理，通过卷积操作找到原始图像的边界线，然后只对边界部分进行抗锯齿。FXAA所带来的开销很小。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250807214222852.png" alt="image-20250807214222852" style="zoom: 80%;" />
<h3 id="TAA-Tempoal-AA"><a class="header-anchor" href="#TAA-Tempoal-AA"></a>TAA(Tempoal AA)</h3>
<h2 id="Z-Buffer算法-解决物体间的先后顺序遮挡问题"><a class="header-anchor" href="#Z-Buffer算法-解决物体间的先后顺序遮挡问题"></a>Z-Buffer算法(解决物体间的先后顺序遮挡问题)</h2>
<p>在前面我们学习了如何解决走样问题，可以使图像的效果更好，但是对于三维空间中的物体不同的远近物体之间会有遮挡问题，所以这一次我们就学习如何在二维图像中呈现出这种<strong>遮挡效果</strong>，用到的算法就是<strong>Z-Buffer</strong>算法。</p>
<p>Z-Buffer算法需要维护一个数组<strong>zbuffer</strong>，这个数组记录了三角形中所有<strong>像素</strong>的深度，初始为<strong>无限大</strong>。（这里说的深度是指该像素距离相机远近的距离，深度越小离相机越近，会遮盖住深度达的像素）。然后在渲染图像时遍历每个三角形上的像素点(x,y)，与该位置的zbuffer的值进行比较，如果小则更新zbuffer数组，表示这个像素离相机更近，要覆盖这个位置原来的像素，并把这个像素颜色更新为新像素的颜色。下图是具体的算法流程。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240118132918032.png" alt="image-20240118132918032" style="zoom:67%;" />
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240118132939130.png" alt="image-20240118132939130" style="zoom:67%;" />
<p>当每一个三角形不是太大或者太小时，每个三角形所覆盖的像素都是一定数量的常数的，所以我们渲染时只需要扫描n个三角形就实现了图像的遮盖效果，所以Z-Buffer算法的事件复杂度可以看作O(n)的。</p>
<h1 id="Shading-着色"><a class="header-anchor" href="#Shading-着色"></a>Shading(着色)</h1>
<p>前面两大节已经学习了变换和光栅化，可以通过各种各样的变换的组合实现多种图形效果，并通过光栅化把三维的物体绘制到二维的屏幕上面，现在我们就要考虑如何将这些颜色绘制到对应的像素上，实现绘制彩色的图片。</p>
<h2 id="准备工作"><a class="header-anchor" href="#准备工作"></a>准备工作</h2>
<p>进入一个新的阶段，为了解决新的问题，需要定义和引入一些东西。这些向量都是单位向量，只是为了表示方向。另外这里我们说的只是<strong>局部着色</strong>，对每一个着色点来说，我们<strong>只考虑这一个点</strong>的光照方向以及亮度等，并<strong>不考虑</strong>是否有其他物体遮挡住它，阴影效果后面再说如何解决。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240118135837094.png" alt="image-20240118135837094" style="zoom:80%;" />
<h2 id="Lambert漫反射模型"><a class="header-anchor" href="#Lambert漫反射模型"></a>Lambert漫反射模型</h2>
<h3 id="Diffuse-Reflect-漫反射"><a class="header-anchor" href="#Diffuse-Reflect-漫反射"></a>Diffuse Reflect(漫反射)</h3>
<p>漫反射是光从一定角度入射之后从入射点向四面八方反射，且每个不同方向反射的光的强度相等，而产生漫反射的原因是物体表面的粗糙，导致了这种物理现象的发生。</p>
<p>我们可以通过着色点表面与光照的不同角度出现不同的光照效果模拟漫反射。</p>
<p>其中就有Lambert’s cosine law(Lambert’s余弦定理)即，<strong>c o s θ = l ⋅ n</strong> ，其中<strong>l</strong> 是入射光方向，<strong>n</strong> 为平面法线方向。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240118140822720.png" alt="image-20240118140822720" style="zoom:67%;" />
<h3 id="光的传播"><a class="header-anchor" href="#光的传播"></a>光的传播</h3>
<p>除了需要知道光的入射角角度，还需要知道距离光源的距离，以便计算光的强度。</p>
<p>我们假设点光源在各个方向开始扩散，各个方向的速度和能量都相同，那么就会像水波纹那样向外扩散，假设能量不受损，根据能量守恒定律可以求出距离点光源任意距离的光的强度。如下图所示，可以看到距离点光源越远，光照强度就越低。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240118141508079.png" alt="image-20240118141508079" style="zoom:67%;" />
<p>于是结合以上两点，我们可以综合得出漫反射的模拟模型</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240118142007087.png" alt="image-20240118142007087" style="zoom:67%;" />
<p>k<sub>d</sub>表示的是<strong>漫反射系数</strong>，决定了这一点对光的吸收能力的大小。当k<sub>d</sub>为1时表示为白色，即反射所有光，当k<sub>d</sub>为0时表示为黑色，即吸收所有光。这个属性可以表示物体某一点的明暗程度。</p>
<p>L<sub>d</sub>表示的是漫反射反射出去的光。</p>
<p>从上式可以看出，漫反射与我们的<strong>观测方向v无关</strong>，即从哪个方向观察漫反射的结果都是一样的。</p>
<h2 id="Blinn-Phong镜面反射模型"><a class="header-anchor" href="#Blinn-Phong镜面反射模型"></a>Blinn-Phong镜面反射模型</h2>
<p>在现实生活中不止有漫反射，还存在着镜面反射。镜面反射可以使物体表面出现高光，例如下图中左边是只有漫反射的效果，右侧则是考虑了镜面反射的效果，可以使得物体看起来更加逼真。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240118143849681.png" alt="image-20240118143849681" style="zoom:67%;" />
<p>镜面反射的方向和入射角与法线的角度相同。下图中R表示镜面反射的方向，当R的方向与观察方向V很接近时，就会产生<strong>HighLight</strong>(<strong>高光)</strong>。就好比拿着镜子对准太阳，当我们人眼的观测角度和太阳光的反射角度非常接近时会晃眼，高光就是和这个差不多。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240118144017886.png" alt="image-20240118144017886" style="zoom:67%;" />
<p>在Blinn-Phon镜面反射模型中，引入了<strong>h(半程向量)</strong>，半程向量时I和<strong>V</strong>夹角的<strong>角平分线</strong>方向，可以通过两个向量相加再归一化得到班车向量<strong>h</strong>。在这个模型中认为当h和<strong>n</strong>很接近时，能在一定程度上表示了<strong>V和R</strong>很接近，这样就简化了运算，n和h的接近程度可以通过点乘得到结果。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240118144255239.png" alt="image-20240118144255239" style="zoom:67%;" />
<p>我们可以看到模型中的式子中有个指数<strong>p</strong>，这是用来控制高光的生成范围的，我们一般希望高光在很小的一个范围内，击中一小块区域内很亮，随着指数的增大，可以实现这种效果。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240118144948456.png" alt="image-20240118144948456" style="zoom:67%;" />
<h2 id="泛光模型"><a class="header-anchor" href="#泛光模型"></a>泛光模型</h2>
<p>泛光模型即只考虑环境光，这是最简单的<strong>经验</strong>模型，只会去考虑环境光的影响，并且不会去精确的描述，而只是用一个简单的式子表示。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240118145209844.png" alt="image-20240118145209844" style="zoom:67%;" />
<p>其中<strong>Ka</strong>代表物体表面对环境光的反射率，<strong>Ia</strong>代表入射环境光的亮度。</p>
<p>最后在渲染的时候，我们整体考虑环境光、漫反射光和镜面反射光，就能呈现出较好的模拟效果。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240118145358529.png" alt="image-20240118145358529" style="zoom:67%;" />
<p>最终效果演示图如下所示。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240118145434108.png" alt="image-20240118145434108" style="zoom:67%;" />
<h2 id="着色方法-频率"><a class="header-anchor" href="#着色方法-频率"></a>着色方法(频率)</h2>
<p>前面我们只是针对一个点进行着色，现在就开始对整体进行渲染。下图是三种不同的渲染方法产生的结果，根据渲染所选取的对象不同，得到的结果也不同。大致可以分为三类：面着色，顶点着色，像素着色。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240118150140996.png" alt="image-20240118150140996" style="zoom:67%;" />
<h3 id="Flat-Shading-面着色"><a class="header-anchor" href="#Flat-Shading-面着色"></a>Flat Shading(面着色)</h3>
<p>面着色，顾名思义以每一个<strong>面</strong>作为一个着色单位。模型数据大多以很多个三角面进行存储，因此也就记录了每个面的法线向量，利用每个面的法线向量进行一次Blinn-Phong反射光照模型的计算，将该颜色赋予整个面。</p>
<h3 id="Gouraud-Shading-顶点着色"><a class="header-anchor" href="#Gouraud-Shading-顶点着色"></a>Gouraud Shading(顶点着色)</h3>
<p>顶点着色，会对<strong>每个三角形的顶点</strong>进行一次着色，三角形的内部通过渐变的形式进行着色。现在最大的问题就是如何求出每个顶点的法向量，从下图我们可以看到，一个顶点会被多个面共享，所以一个顶点的法向量可以通过这些<strong>共享面</strong>的<strong>法向量求平均值</strong>得来。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240118151316581.png" alt="image-20240118151316581" style="zoom:67%;" />
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240118151614959.png" alt="image-20240118151614959" style="zoom:67%;" />
<p>对于三角形内的一点，我们已经有了三个顶点的法线，内部的法线是在顶点之间平滑过渡的。</p>
<h3 id="Phong-Shading-像素着色"><a class="header-anchor" href="#Phong-Shading-像素着色"></a>Phong Shading(像素着色)</h3>
<p>像素着色，会对每一个像素（片元）都进行一次着色。</p>
<p>下图是一个对比，每一行都是相同的模型，随着向下走，模型的三角形数量不断的增加。可见随着三角形数量的增加，三种着色频率的区别并不是太大。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240118151009539.png" alt="image-20240118151009539" style="zoom:67%;" />
<h1 id="Graphics-Pipeline-图形管线"><a class="header-anchor" href="#Graphics-Pipeline-图形管线"></a>Graphics Pipeline(图形管线)</h1>
<p>从三维空间映射到二维屏幕上的一系列过程叫做图形管线。这一套流程被写在硬件中，现在普遍是由显卡执行这一套操作。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240118152205254.png" alt="image-20240118152205254" style="zoom:67%;" />
<ol>
<li><strong>顶点处理</strong>的作用是指<strong>对所有的顶点数据进行Model，View，和Projection的变换，最终得到投影到二维平面的坐标信息</strong>(同时为了Zbuffer保留深度z值)。当然如果超出观察空间的会被剪裁掉(关于剪裁的知识因为闫老师的课并没有多提，所以本系列笔记也暂未设及到，但是会在之后进行该部分知识的补充)。</li>
</ol>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240118154558385.png" alt="image-20240118154558385" style="zoom: 80%;" />
<ol start="2">
<li>三角形处理也十分容易理解，就是<strong>将所有的顶点按照原几何信息，变成三角面，每个面由3个顶点组成</strong>。</li>
<li>光栅化所执行的操作就是，<strong>找到屏幕中的哪些像素在三角形内</strong>，即找出哪些像素是我们需要绘制上色的。</li>
</ol>
<p><img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240118154611553.png" alt="image-20240118154611553"></p>
<ol start="4">
<li>在进行完三角形的光栅化之后，知道了哪些在三角形内的像素可以被显示。由于多个三角形直接会存在遮挡关系，在片元处理之前，还<strong>需要使用Z-Buffer算法计算每个片元的可见性</strong>。只有最终不被遮挡的片元才能进入片元处理阶段进行着色。</li>
</ol>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240118154659249.png" alt="image-20240118154659249" style="zoom: 80%;" />
<ol start="5">
<li>
<p>片元处理阶段就是<strong>决定了每一个像素的最终颜色</strong>，也就是俗称的着色。顶点处理阶段可以使用每个顶点的顶点颜色进行着色，其他片元的颜色会通过插值算法计算出自己的颜色。如果向实现Phong式着色的话还必须到片元处理阶段拿到每个像素进行着色。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240118154648252.png" alt="image-20240118154648252" style="zoom: 80%;" />
</li>
<li>
<p>最后一步！Framebuffer的处理，就是将所有的像素颜色信息整合在一起，输送给显示设备加以显示。这也就完成了整个图形渲染管线了。</p>
</li>
</ol>
<h1 id="Texture-Mapping-纹理映射"><a class="header-anchor" href="#Texture-Mapping-纹理映射"></a>Texture Mapping(纹理映射)</h1>
<p>先看这样一张图，对于图片中的任何一个物体，每个点都有不同的颜色。前面学习漫反射可以知道，每个点的颜色是可以通过漫反射系数的调节改变的。但是一个物体的这么多点，我们显然不可能手动设置每一个点的颜色，于是便有了纹理映射技术。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240118160139682.png" alt="image-20240118160139682" style="zoom:67%;" />
<p>纹理是一张二维的图，覆盖在物体表面。大概原理就是一个三维物体的表明可以通过展开形成一个二维的平面，可以找到与之对应的二维图片覆盖在表明，形成了不同的颜色和样式。所以实现物体平面上任何一个点与纹理上任何一个点像映射的过程叫做纹理映射。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240118160357193.png" alt="image-20240118160357193" style="zoom:67%;" />
<p>如下图所示，我们可以先用通用着色器渲染出模型的样子，然后再把最右侧的纹理贴在模型上，就形成了中间的最终模型。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240118160640194.png" alt="image-20240118160640194" style="zoom:67%;" />
<h2 id="纹理坐标系-UV"><a class="header-anchor" href="#纹理坐标系-UV"></a>纹理坐标系(UV)</h2>
<p>纹理坐标系通常用u、v两个字母表示坐标系的值，u和v的值都在[0,1]之间，如下图所示。至于一个顶点所对应在纹理空间的坐标是怎么得到的，这就并不是程序员们关心的了，我们在编程前是假设已经知道了顶点到纹理坐标的映射关系。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240118160923315.png" alt="image-20240118160923315" style="zoom:67%;" />
<p>下面是纹理坐标具体使用的伪代码：大致流程就是我们根据在屏幕上的每一个位置获取其对应的uv坐标，再根据uv坐标到贴图获取该位置的颜色，最后用这个颜色替换屏幕上这点的颜色，就实现了贴材质到模型上。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240119185608675.png" alt="image-20240119185608675" style="zoom: 50%;" />
<h2 id="当纹理过大或者过小引起的问题及解决方案"><a class="header-anchor" href="#当纹理过大或者过小引起的问题及解决方案"></a>当纹理过大或者过小引起的问题及解决方案</h2>
<h3 id="纹理过小问题"><a class="header-anchor" href="#纹理过小问题"></a>纹理过小问题</h3>
<p>如果纹理大小可以正好与屏幕上对应区域大小相同，每一个像素都能对应上。但是当纹理过小时，我们就需要对纹理进行放大，那么纹理上的一个像素可能会覆盖屏幕上的几个像素，导致两个像素的中心点对应不上，如下图所示红色位置。那么此时我们该如何计算这一点的颜色呢，如果只是简单的选择离他最近的点的颜色，会导致照片出现失真显示，就会在照片上出现像素块，这显然是不可取的。</p>
<p><img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240119191029096.png" alt="image-20240119191029096"></p>
<h3 id="双线性插值"><a class="header-anchor" href="#双线性插值"></a>双线性插值</h3>
<p>第一步，取出离红色点最近的4个黑色顶点，分别算出，该红色点在水平及竖直方向偏移的距离s,t。</p>
<p><img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240119191257173.png" alt="image-20240119191257173"></p>
<p>接着先利用s，可以线性插值出如下图所示的u0，u1点的颜色值</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240119191335576.png" alt="image-20240119191335576" style="zoom:67%;" />
<p>最后利用t，颜色值u0，u1插值出红色点的颜色值</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240119191430598.png" alt="image-20240119191430598" style="zoom: 50%;" />
<p>最后得出该点的颜色就综合考虑了周围四个点的颜色，会让图片看起来有种平滑过渡的效果。下图就是最近距离和双线性插值的结构比较，可以明显看出右边的效果比坐标的好了很多。</p>
<p>由于Nearest是直接选取离自己最近的像素点，所以会出现几个像素都是一个颜色，导致图像中出现一些像素块。而双线性插值则是将周围几个点的值进行插值，会得到更平滑的过渡效果。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240119191651120.png" alt="image-20240119191651120" style="zoom:67%;" />
<h3 id="纹理过大问题"><a class="header-anchor" href="#纹理过大问题"></a>纹理过大问题</h3>
<p>当纹理过大时，会产生比纹理过小更严重的问题。正常情况下，我们希望看到这样的渲染结果。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240119211505394.png" alt="image-20240119211505394" style="zoom:67%;" />
<p>但是实际上会出现这样的结果</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240119211546161.png" alt="image-20240119211546161" style="zoom:67%;" />
<p>这是因为透视投影存在进大远小的效果，所以远处的一片材质在屏幕空间中可能只对应了几个像素，我们用这几个像素来呈现这一片的颜色，肯定会造成很严重的失真。如下图所示，距离相机越远，一个像素所包含的纹理范围(纹素)就越多，造成的问题也就越严重，所以我们就需要想办法解决这一问题。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240119211726573.png" alt="image-20240119211726573" style="zoom:67%;" />
<h3 id="MipMap"><a class="header-anchor" href="#MipMap"></a>MipMap</h3>
<p>​	对应上面区域中的一个像素包含一片区域的贴图，这个只选取范围贴图中的某给颜色表示这块纹理显然是不合理的，所以我们干脆就对这块区域内的颜色求平均值，而屏幕空间中该像素的颜色就为这块纹理颜色的平均值。</p>
<p>​	而MipMap技术就允许我们进行<strong>范围查询</strong>，从而得到这片区域的颜色的平均值。但是MipMap只能对<strong>正方形区域</strong>做近似查询(得出的结果是大约值，不是准确值)，但是速度很快。</p>
<p>​	具体做法就是根据原始图像通过不断的向下缩放分辨率生产其他层的低分辨率图像，level 0代表的是原始纹理，也是精度最高的纹理，随着level的提升，每提升一级将4个相邻像素点求均值合为一个像素点，因此越高的level也就代表了更大的footprint的区域查询。接下来要做的就是根据屏幕像素的footprint大小选定不同level的texture，再进行点查询即可，而这其实就相当于在原始texture上进行了区域查询！</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240119212630596.png" alt="image-20240119212630596" style="zoom:67%;" />
<p>​	那么我们如何选择第几层的材质查询呢？</p>
<p>​	在屏幕空间中取当前像素点的右方和上方的两个相邻像素点(4个全取也可以)，分别查询得到这3个点对应在Texture space的坐标，计算出当前像素点与右方像素点和上方像素点在Texture space的距离，二者取最大值，计算公式如图中所示，那么level D就是这个距离的log2值 (D = log2L) 。根据计算出来的L进一步求出D从而选择对应缩放级别的图片。</p>
<p>​	mipmap的核心就是针对不同的像素区域选择合适的缩放级别的纹理，使得1像素 ≈ 1纹素，避免多个纹素对应一个像素产生走样问题。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240119213407192.png" alt="image-20240119213407192" style="zoom:67%;" />
<p>​	<strong>注意</strong>这里我们求得的D可能不是一个整数，就比如我们得到了1.8，但是我们没有1.8层的图片。这里就可以再次用插值处理，先对第一层查询插值得到一个值，再去第二层查询插值得到一个值，最后根据第1层和第2层得到的信息插值出来第1.8层的信息，供需要插值三次，所以叫做<strong>三线性插值</strong>。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240119214127535.png" alt="image-20240119214127535" style="zoom:67%;" />
<h3 id="各向异性过滤MipMap"><a class="header-anchor" href="#各向异性过滤MipMap"></a>各向异性过滤MipMap</h3>
<p>应用了MipMap后，我们得到的图如下，可以看到没有很好的解决问题，这是因为MipMap只能解决<strong>方形</strong>的区域，对于一些矩形或者不规则区域，则无法进行处理。而屏幕空间中的一个像素映射到纹理上并不都是方形区域，甚至会出现不规则的斜着的区域。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240119214324256.png" alt="image-20240119214324256" style="zoom: 50%;" />
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240119214548681.png" alt="image-20240119214548681" style="zoom:50%;" />
<p>各向异性过滤MipMap允许处理矩形区域和方形区域，但是对于一些斜着的或者不规则的无法处理，但是也可以进一步增强图片的效果。</p>
<h2 id="纹理映射的应用"><a class="header-anchor" href="#纹理映射的应用"></a>纹理映射的应用</h2>
<h1 id="Geometry-几何"><a class="header-anchor" href="#Geometry-几何"></a>Geometry(几何)</h1>
<p>计算机图形学中，要表示各种各样的模型，而如何更好的表示这些模型就离不开几何。几何可以分为<strong>隐式</strong>几何和<strong>显式</strong>几何两种。</p>
<h2 id="隐式几何"><a class="header-anchor" href="#隐式几何"></a>隐式几何</h2>
<h4 id="特点"><a class="header-anchor" href="#特点"></a>特点</h4>
<p>所谓隐式，就是不会告诉你任何关于点的信息，只会告诉我们这些点之间满足的关系，即各种各样的函数。比如下图中给出了球面方程，我们可以知道在球面上的所有点都满足这个方程，但是具体具体是哪一个点我们无法得知。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240120103636172.png" alt="image-20240120103636172" style="zoom:67%;" />
<p>对于隐式的来说，我们可以很容易判断某一个点在球外、球内还是球面上，但是我们无法知道都有哪些点在球面上，因为对于一个面来说有无限多的点。</p>
<h3 id="其他表示方法"><a class="header-anchor" href="#其他表示方法"></a>其他表示方法</h3>
<h4 id="代数表示"><a class="header-anchor" href="#代数表示"></a>代数表示</h4>
<p>代数表示顾名思义就是用数学表达式描述一个曲面，这是最简单的表达方式，对于简单几何能很好描述，但是对于一些复杂几何就不太好描述了。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240120105335229.png" alt="image-20240120105335229" style="zoom:67%;" />
<h4 id="Constructive-Solid-Geometry-CSG"><a class="header-anchor" href="#Constructive-Solid-Geometry-CSG"></a>Constructive Solid Geometry(CSG)</h4>
<p>这种表示方法允许对基本几何进行布尔运算，通过不同的操作组合来表示复杂几何。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240120105706250.png" alt="image-20240120105706250" style="zoom:50%;" />
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240120105719539.png" alt="image-20240120105719539" style="zoom:67%;" />
<h2 id="显式几何"><a class="header-anchor" href="#显式几何"></a>显式几何</h2>
<h3 id="特点-k2"><a class="header-anchor" href="#特点-k2"></a>特点</h3>
<p>显示与隐式是相对的，和之前的三角形表示一样，我们知道了所有的点坐标或者通过映射关系得到所有点坐标。通过这些点构建一个曲面。如下图所示，我们用这一一种坐标的映射也可以得到一个球面。</p>
<p>​		                                       <img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240120104901725.png" alt="image-20240120104901725" style="zoom: 50%;" /></p>
<p>但是对于显示来说，我们很容易得到曲面上的所有点，但是很难判断某一点与该曲面的关系。</p>
<p>所以两者各有利弊，各有不同的适用范围。</p>
<h3 id="其他表示方法-k2"><a class="header-anchor" href="#其他表示方法-k2"></a>其他表示方法</h3>
<h4 id="Point-Cloud-点云"><a class="header-anchor" href="#Point-Cloud-点云"></a>Point Cloud(点云)</h4>
<p>是最简单的表示方法，就是用一堆点构成曲面，点多模型就精细，点少就不那么精细。理论上用点云方式可以表示任何形状的几何，但是点的密度要足够高。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240120111557918.png" alt="image-20240120111557918" style="zoom:67%;" />
<h3 id="Polygon-Mesh-多边形网格"><a class="header-anchor" href="#Polygon-Mesh-多边形网格"></a>Polygon Mesh(多边形网格)</h3>
<p>用三角形面通过连接组合，形成其他曲面。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240120111809818.png" alt="image-20240120111809818" style="zoom:67%;" />
<h2 id="Bezier-Curves-贝塞尔曲线"><a class="header-anchor" href="#Bezier-Curves-贝塞尔曲线"></a>Bézier Curves(贝塞尔曲线)</h2>
<p>P0,P1,P2,P3都是控制点，P0和P3是终点和七点，P1和P2控制曲线的走向。其实贝塞尔曲线的定义很像参数方程，给定一个参数，t∈[0,1]就能确定贝塞尔曲线上的一点，倘若取完所有t值，就能得到完整的贝塞尔曲线，了解一下大概之后，接下来我们就开始介绍计算曲线的过程。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240120112603359.png" alt="image-20240120112603359" style="zoom: 50%;" />
<p>选择一个最简单的形式，即只有三个控制点。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240120113632915.png" alt="image-20240120113632915" style="zoom:67%;" />
<p>第一步选定一个参数 t∈[0,1]，在b0b1线段 上进行插值</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240120113727263.png" alt="image-20240120113727263" style="zoom:67%;" />
<p>在b1b2线段上做同样操作</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240120113802086.png" alt="image-20240120113802086" style="zoom:67%;" />
<p>最后在线段b0<sup>1</sup>b1<sup>1</sup>上再次插值就可以得到贝塞尔曲线在t时刻的点，遍历所有的情况就可以绘制出贝塞尔曲线。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240120113910603.png" alt="image-20240120113910603" style="zoom:67%;" />
<p>对于n个点的操作也一样，都是不断重复一个操作，下图就是4个控制点的绘制过程。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240120114021767.png" alt="image-20240120114021767" style="zoom:67%;" />
<p>对于t时刻的贝塞尔曲线上的点，我们可以递归式的求解出来，具体形式如下图所示，该点由其他线段插值得来。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240120114222128.png" alt="image-20240120114222128" style="zoom:50%;" />
<p>于是我们可以通过数学表达式写出来，如下图所示，任意时刻贝塞尔曲线一点的坐标与所有控制点和t有关。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240120114350164.png" alt="image-20240120114350164" style="zoom:50%;" />
<p>​	可以看到贝塞尔曲线是一个关于t的多项式，其中的B一栏是一个特殊系数，对于这样一个特殊系数其实也有一个多项式与之对应，正是<strong>伯恩斯坦多项式</strong>。n个控制点的贝塞尔曲线为n-1次。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240120114635728.png" alt="image-20240120114635728" style="zoom:67%;" />
<p><strong>贝塞尔曲线的性质：</strong></p>
<p>​	<strong>1 必定经过起始与终止控制点</strong><br>
​	<strong>2 必定经与起始与终止线段相切</strong><br>
​	<strong>3 具有仿射变换性质，可以通过移动控制点移动整条曲线</strong><br>
​	<strong>4 凸包性质，曲线一定不会超出所有控制点构成的多边形范围</strong></p>
<p>但是对于高阶的贝塞尔曲线不好控制，当下图中11个控制点绘制曲线是，可以发现效果并不是很好。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240120120058617.png" alt="image-20240120120058617" style="zoom:67%;" />
<p>为了解决这个问题，于是就有了<strong>Piecewise Curves</strong>即分段的曲线，先分别用几个控制点绘制好曲线，再把几段曲线连接起来。现在普遍采用四个控制点描绘一段曲线，即下图中所示，然后再把各个曲线连接起来。然后我们通过控制这些控制点调整曲线的形状。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240120120720675.png" alt="image-20240120120720675" style="zoom:67%;" />
<h2 id="Bezier-Surfaces-贝塞尔曲面"><a class="header-anchor" href="#Bezier-Surfaces-贝塞尔曲面"></a>Bézier Surfaces(贝塞尔曲面)</h2>
<p>理解了贝塞尔曲线不难理解，贝塞尔曲面就是将2维过渡到3维。如下图所示，就是利用了4x4 即16个控制点绘制出的曲面。二维的需要一个参数t，那么三维的就需要两个参数来描述，记作u,v，在任意时刻(u1.v1)，都可以找到一个点，遍历所有情况就能组成贝塞尔曲面。</p>
<p><img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240120125237415.png" alt="image-20240120125237415"></p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240120125420963.png" alt="image-20240120125420963" style="zoom:67%;" />
<p><strong>网格细分是指将一个模型的面合理的分成更多小的面，从而提升模型精度，提高渲染效果</strong><br>
<strong>网格简化是指将一个模型的面合理的合成更少的面，从而降低模型精度，为特定情形下提供使用(如LOD技术)</strong></p>
<h2 id="Mesh-Subdivision-网格细分"><a class="header-anchor" href="#Mesh-Subdivision-网格细分"></a>Mesh Subdivision(网格细分)</h2>
<p>从下图可以知道，细分就是把一个三角形合理分为更多更小的面，从而提高模型的精度，使模型有更多的细节。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240123095715936.png" alt="image-20240123095715936" style="zoom: 67%;" />
<p>细分过程中我们需要做两件事情，<strong>一</strong>是将一个三角形细分为更多小的三角形，二是改变小三角形的位置，使细分后的模型表面看起来更加圆滑，而不是棱角分明。如下图所示，把一个多面体变为圆形。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240123100115787.png" alt="image-20240123100115787" style="zoom:50%;" />
<h3 id="Loop细分-Loop-Subdivision"><a class="header-anchor" href="#Loop细分-Loop-Subdivision"></a>Loop细分(Loop Subdivision)</h3>
<h4 id="划分三角形"><a class="header-anchor" href="#划分三角形"></a>划分三角形</h4>
<p>将每一个三角形按照下图的方式划分为4个小三角形</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240123100241925.png" alt="image-20240123100241925" style="zoom:67%;" />
<h4 id="改变顶点位置"><a class="header-anchor" href="#改变顶点位置"></a>改变顶点位置</h4>
<p>我们把划分好的三角形的顶点分为<strong>新顶点</strong>和<strong>旧顶点</strong>两类，新顶点就是划分出来的小三角形产生的新顶点，下图中红圈标记的点。旧顶点就是原先大三角形的顶点，下图中的黑色点。</p>
<p>对于每一个<strong>新顶点</strong>，都做下图中右侧的处理，移动顶点的位置</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240123100843592.png" alt="image-20240123100843592" style="zoom: 50%;" />
<p>对于每一个旧顶点，做以下操作。其中n是该顶点的度，更新旧顶点需要依赖周围顶点的信息和自身的信息，进行加权平均得来的。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240123101543442.png" alt="image-20240123101543442" style="zoom: 80%;" />
<h3 id="Catmull-Clark细分-Catmull-Clark-Subdivision"><a class="header-anchor" href="#Catmull-Clark细分-Catmull-Clark-Subdivision"></a>Catmull-Clark细分(Catmull-Clark Subdivision)</h3>
<p>先说明一些定义：</p>
<p><strong>1 对于所有不是四边形的面，称之为Non-quad face</strong><br>
<strong>2 所有度不为4的顶点称之为奇异点</strong></p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240123113806433.png" alt="image-20240123113806433" style="zoom: 80%;" />
<p>每次细分步骤如图中右下角所示，在每个面中都添加一个点，在每条边的中点也都添加一个点，面上的新顶点连接所有边上的新顶点</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240123113910545.png" alt="image-20240123113910545" style="zoom: 80%;" />
<p>从中我们可以观察到一些性质：</p>
<p><strong>1 有几个非四边形面，就会多出几个奇异点，所以现在一共有2+2 = 4个</strong><br>
<strong>2 新多出来的奇异点的度数与原来所在面的边数相等，如这里就是3度</strong><br>
<strong>3 第一次细分之后所有面都会变成四边形，且往后奇异点数目不再增加</strong></p>
<p>再次细分后奇异点的数量也不再增加。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240123113947015.png" alt="image-20240123113947015" style="zoom:67%;" />
<p>以上我们明白了如何增加新顶点，与Loop细分类似，同样需要去调整各类顶点的位置，这里将所有的顶点分为三类，对于各类顶点位置调整如下图所示：</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240123114145199.png" alt="image-20240123114145199" style="zoom: 90%;" />
<h2 id="Mesh-Smplication-网格简化"><a class="header-anchor" href="#Mesh-Smplication-网格简化"></a>Mesh Smplication(网格简化)</h2>
<p>简化操作顾名思义就是减少模型中三角形面，以达到某种目的，在特定情况下会使用。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240123095726935.png" alt="image-20240123095726935" style="zoom:67%;" />
<p>举个栗子，对于用不同数量的三角形组成的骷髅模型来说，从远处看区别并不是很大，我们就没有必要在远处还渲染这么复杂的模型，在很多游戏中也是如此，远处的模型看起来会模糊也是这个道理，一般模型的精度会根据距离的远近选择。距离模型远的时候三角形数量少一点，距离近的时候再增加三角形的数量。和前面的MipMap原理类似，远处精度低，进出精度高。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240123103438083.png" alt="image-20240123103438083" style="zoom: 50%;" />
<p>这里介绍的方法叫做<strong>边坍缩</strong>方法，如下图所示，就是把一条边的两个顶点合并为一给顶点。但是我们需要解决的问题是简化需要尽可能的保存原模型的形状，我们该如何选择坍缩的边是关键。</p>
<p><img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240123105045421.png" alt="image-20240123105045421"></p>
<p>再次我们引入<strong>二次度量</strong>这个概念，即坍缩之后蓝色新顶点所在的位置与原来各个平面的垂直距离之和。</p>
<p>如果能够使得这个误差最小那么对整个模型样貌修改一定程度上也会较小。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240123105637261.png" alt="image-20240123105637261" style="zoom: 67%;" />
<p>那么我们需要做的整体流程就很明确了：</p>
<p><strong>1 为模型每条边赋值，其值为坍缩这条边之后，代替两个老顶点的新顶点所能得到的最小二次误差度量</strong><br>
<strong>2 选取权值最小的边做坍缩，新顶点位置为原来计算得出使得二次误差最小的位置</strong><br>
<strong>3 坍缩完之后，与之相连其他的边的位置会改动，更新这些边的权值</strong><br>
<strong>4 重复2-3步，直到到达终止条件</strong></p>
<p>这其实是一个标准的贪心算法，可能到不了全局最优解，但事实证明最终的结果依然相当不错。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240123110518727.png" alt="image-20240123110518727" style="zoom:67%;" />
<h1 id="Ray-Tracing-光线追踪"><a class="header-anchor" href="#Ray-Tracing-光线追踪"></a>Ray Tracing(光线追踪)</h1>
<p>​	对于前面着色部分介绍的Blinn-Phong模型来说，它是一个<strong>局部模型</strong>，<strong>无法处理全局</strong>的效果。以下图为例，物体接收的的光除了我们的光影之外，还有可能会接收到由其他物体反射而来的光，这是Blinn-Phong模型所无法处理的，而光线追踪正是为了解决这种问题所提出的一种全局光照模型。但是光栅化虽然图形质量一般，但是速度快；光线追踪虽然提高了图像质量，但是会增大计算量，速度会很慢。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240123115856784.png" alt="image-20240123115856784" style="zoom: 80%;" />
<p>​	为了方便我们的计算实现光线追踪，我们需要对光线做出一些假设：</p>
<p><strong>1. 光线一定沿着直线传播</strong><br>
<strong>2. 光线之间无法碰撞</strong>（两条光线相交后互不影响，各自都还沿各自的方向传播）<br>
<strong>3. 光线路径可逆，即从A发出的到B的光线，一定也可以从B发出到A（中途可发生反射和折射）</strong></p>
<p>​	考虑一下对光线的第三条假设：<strong>光路可逆</strong>，所有进入到人眼的光，都可从人眼发出光按照原路反方向返回，那么利用这种模拟从人眼发射光线的方法不就可以还原出所有的光路了呢？没错这就是光线追踪的核心想法。</p>
<p>​	光线追踪的做法就是从<strong>相机随机向场景中投射光线</strong>，光线在世界中不断进行反射，<strong>反射一定次数后再和光源相连</strong>。这样我们就反向模拟出了一条从光源出发，经过多次反射后进入相机的光线了。</p>
<h2 id="Whitted-Style光线追踪原理"><a class="header-anchor" href="#Whitted-Style光线追踪原理"></a>Whitted-Style光线追踪原理</h2>
<p>​	具体流程入下图所示，首先从相机出发发射一条光线（红色线），光线穿过的像素会对应场景中的一个位置，该位置有物体，说明光线会在该点发生反射。再在该点和光源位置连线（蓝色线），判断该点是否在阴影中，如果不在阴影中，就说明我们找到了一条可行的光线通路，计算该光路最终的能量，进而求出该像素的颜色。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250920225124855.png" alt="image-20250920225124855" style="zoom:50%;" />
<p>​	从人眼或相机向每个像素点发射一条光线，与场景中的物体相交（只考虑相交的距离最近的点，后面的点会被遮挡住）。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240123140652541.png" alt="image-20240123140652541" style="zoom: 120%;" />
<p>​	因为我们只会看到最前面的物体，后面被遮挡的就看不到了，所以<strong>只考虑与物体最近的交点</strong>。从该点出发，连接光源，只需要判断该连线是否会被遮挡就能判断该点是否在阴影中。同时我们也能得到该点的观测方向，光源方向和法线方向，可以计算出该点的颜色。但是这样也只是考虑了**局部（光线只弹射了一次）<strong>的光照情况，下面就开始考虑</strong>全局（光线弹射多次）**的光照。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240123141041856.png" alt="image-20240123141041856"  />
<p>​	如果上图中的球体是一个玻璃状透明球体，不仅会发生反射，也会发生折射，折射的光也会再反射到其他物体最终进入人眼，所以这步我们就开始考虑全局的这些光照。</p>
<p>​	我们把如下图所示的所有会发生反射和折射的点与光源连接，判断哪些点可以进入人眼。最后将这些可以进入人眼处的颜色考虑到该像素颜色的计算中，就得到了最终的颜色。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240123141359000.png" alt="image-20240123141359000"  />
<p>这部分知识说明一下基本原理，具体实际的解决方法后面会再说明。</p>
<h2 id="光线的表示方式"><a class="header-anchor" href="#光线的表示方式"></a>光线的表示方式</h2>
<p>为了实际解决光线追踪的技术问题，我们需要大量的计算，所以需要对光线进行表示，以便进行数学运算。</p>
<p>我们把光线看作一条可以无限延伸的射线，起点 <strong>o</strong> 就是<strong>点光源</strong>的位置，<strong>t</strong> 表示光线传播的时间，**d **是光线的方向向量。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240123142152633.png" alt="image-20240123142152633" style="zoom:67%;" />
<h2 id="光线与物体求交的方法"><a class="header-anchor" href="#光线与物体求交的方法"></a>光线与物体求交的方法</h2>
<h3 id="隐式表面求交"><a class="header-anchor" href="#隐式表面求交"></a>隐式表面求交</h3>
<p>​	光线的数学形式我们已经给出，隐式几何表面也会给出一个表达式，我们可以用几何中求交点的方法求解。<strong>两个图形的交点必然都满足两个图形的表达式</strong>，所以我们只需<strong>联立解方程</strong>即可。</p>
<p>​	对于下面圆形和光线求交来说，只需用求根公式求解即可，但是要注意满足求解的 <strong>t</strong> 是<strong>实数</strong>并且为<strong>正数</strong>。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240123143010839.png" alt="image-20240123143010839" style="zoom:67%;" />
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240123143020376.png" alt="image-20240123143020376" style="zoom:67%;" />
<p>所以对于普遍的隐式曲面，只需联立方程求解即可，最后解出来的参数 <strong>t 是有意义的正实数</strong>就说明光线和物体表面有交点。</p>
<p><img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240123143128061.png" alt="image-20240123143128061"></p>
<h3 id="显式表面求交"><a class="header-anchor" href="#显式表面求交"></a>显式表面求交</h3>
<p>​	对于显示曲面来说，我们不知道曲面的表达式，无法直接求解。但是曲面都是由许多个三角形组成的，我们可以通过<strong>遍历所有三角形</strong>，查看是否有<strong>三角形与光线相交</strong>。当然如果只是简单的全局遍历是非常慢的，后面会介绍如何加速这一过程。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240123143726106.png" alt="image-20240123143726106" style="zoom:67%;" />
<p>​	现在就需要解决<strong>如何求出光线与三角形面的交点</strong>。因为三角形肯定在一个平面内，所以我们可以先判断光线是否与该平面相交，再判断交点是否在三角形内即可。</p>
<p>我们把这个问题分解为两个问题：</p>
<p><strong>1.光线是否与三角形所在平面相交</strong></p>
<p><strong>2.如果相交，交点是否在三角形内</strong></p>
<p>如果相交，且交点在三角形内，那么就得到了我们想要的交点。</p>
<p>为了解决这个问题，下面给出平面的表示方法：</p>
<p>即用一个<strong>法向量</strong>和<strong>一个点</strong>确定一个唯一的平面，具体数学表达式如下图所示。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240123145234557.png" alt="image-20240123145234557" style="zoom: 80%;" />
<p>有了表达式，我们就可以直接带入求解，得到交点。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240123145345522.png" alt="image-20240123145345522" style="zoom:67%;" />
<p>​	上面的解法是分成两个步骤求解的，但是可以利用下面的算法直接判断光线是否和三角形相交。（本质上来说该算法所做的也是上面两个步骤，只是可以直接用算法一步到位求解）。</p>
<p>​	用下图的<strong>Möller-Trumbore 算法</strong>可以快速求解出<strong>三维空间中光线和三角形平面的交点的重心坐标</strong>，并判断是否在三角形内部即可。因为求出的是交点的三维重心坐标的形式，性质与二维的一致。如果b1, b2, 1-b1-b2<strong>三个系数都是非负数且和为1</strong>，就说明交点在三角形内，即光线和三角形有交点。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240123145908559.png" alt="image-20240123145908559" style="zoom:67%;" />
<h2 id="光线与物体相交计算加速"><a class="header-anchor" href="#光线与物体相交计算加速"></a>光线与物体相交计算加速</h2>
<p>​	前面在显示曲面求交点部分介绍要与每一个三角形判断是否相交，但是如果屏幕分辨率过大，场景中模型三角形数量又很多，最终每渲染一次的速度都会非常非常慢，所以我们需要对这一过程进行加速。加速的过程其实就是尽量跳过不可能与光线相交的三角形，避免大量的无效计算。</p>
<h3 id="轴对齐包围盒-Axis-Aligned-Bounding-Box，AABB"><a class="header-anchor" href="#轴对齐包围盒-Axis-Aligned-Bounding-Box，AABB"></a>轴对齐包围盒(Axis Aligned Bounding Box，AABB)</h3>
<p>​	利用一个包围盒包住该物体，在与该物体的三角面计算求交之前先判断光线是否与包围盒相交，倘若连包围盒都与光线没有交点的话，那么显然包围盒内部的物体肯定不会和光线有交点。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240123154149307.png" alt="image-20240123154149307" style="zoom:67%;" />
<p>​	而所谓AABB也是一种包围盒，也是由三对无限大平面的交集构成，只不过AABB的任意一对平面都与x-axis，y-axis或者z-axis垂直，所以称之为轴对齐包围盒。如下图所示：</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240123154206346.png" alt="image-20240123154206346" style="zoom:67%;" />
<p>我们以2D AABB为例子，因此只有x，y两对平面，3D情况可类推：</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240123154239099.png" alt="image-20240123154239099" style="zoom:67%;" />
<p>​	首先如上图最左边所示，求出光线与x平面的交点，将<strong>先进入的交点(偏小的那个)记为 tmin</strong>, <strong>后出去的交点(偏大的那个)记为 tmax</strong>，紧接着如中间图所示计算出光线与y平面的两个交点同样记为另外一组tmin, tmax，当然计算的过程中要注意如果任意的 t &lt; 0，那么这代表的是光线反向传播与对应平面的交点。</p>
<p>我们可以得到以下性质：</p>
<p><strong>1 只有当光线进入了所有的平面才算是真正进入了盒子中</strong><br>
<strong>2 只要当光线离开了任一平面就算是真正离开了盒子</strong><br>
所以对每对平面的tmin，tmax做如下运算(负的也没有关系)</p>
<p><strong>tenter  = max ⁡{ tmin ⁡ } , texit  = min ⁡{ tmax ⁡ }</strong></p>
<p>​	我们可以根据 tenter 和 texit 的正负值推断光线与AABB是否有交点。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240123154511161.png" alt="image-20240123154511161"  />
<p>在计算光线和平面是否相交时，我们可以使用更方便的方法。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240123154759265.png" alt="image-20240123154759265"  />
<p>​	使用AABB方法可以加速判断光线是否与物体相交，那么具体应用在光线追踪加速上，AABB该如何应用，下面介绍两种加速光线追踪的方法：</p>
<h3 id="Uniform-Spatial-Partitions-均匀空间划分"><a class="header-anchor" href="#Uniform-Spatial-Partitions-均匀空间划分"></a>Uniform Spatial Partitions (均匀空间划分)</h3>
<p>​	首先将场景中的物体都包在一个包围盒内，再将大包围盒均匀地划分为若干个大小相等的小格子，记录下所有与物体表面相交的格子。下面的图是以二维的为例，三维场景的计算过程和二维的一样。</p>
<p>​	这样就完成了场景的预处理，处理光线相交时，只需要判断与光线相交的格子内是否有物体即可：如果格子内没有物体，那么光线自然不会与物体相交；如果格子内有物体，就说明光线可能会和物体有交点，计算判断光线和物体表面是否有交点。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250806165529162.png" alt="image-20250806165529162" style="zoom:67%;" />
<p>​	这样就可以用光线于盒子的相交判断是否与物体有相交的可能，避免了光线与场景内所有物体判断是否相交，可以一定程度上进行加速。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250806170253933.png" alt="image-20250806170253933" style="zoom:67%;" />
<p>​	这种空间划分的方法在物体均匀分布的场景中加速效果较好，但是对于大规模的空旷且集中的场景中，效果没有那么好。对于大面积的空白区域来说，仍然使用多个小格子划分是不合理的，对于密集的区域划分多个格子，空旷的区域使用少量的大格子效果会更好更合理。</p>
<h3 id="不均匀空间划分"><a class="header-anchor" href="#不均匀空间划分"></a>不均匀空间划分</h3>
<p>​	为了解决均匀划分中的问题，可以采用空间树形划分，划分方式多种多样，但本质上思想都是一样的。按照某一种划分方式划分空间，当某个格子内没有物体或者物体很少的时候就停止划分。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250806171203512.png" alt="image-20250806171203512" style="zoom:67%;" />
<p>​	由于八叉树的划分方式与纬度有关，空间纬度越高，划分次数越多，所以重点介绍KD-tree，下面是KD-tree具体划分的一个例子，划分后可以将空间划分为一个树形结构，场景中的所<strong>有叶子节点存储自己所包围的物体</strong>。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250806171657884.png" alt="image-20250806171657884" style="zoom: 50%;" />
<p>判断光线相交时，先从根节点（最大的包围盒）开始判断，如果光线与包围盒A相交，则继续判断子节点1和B是否与光线相交，递归遍历相交的节点。</p>
<p>当光线与叶子节点的包围盒相交时，要与子节点保存的所有物体判断是否相交。（叶子节点存储所有物体，与叶子节点相交说明光线有可能与叶子节点内的物体相交，要判断一下）</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250806171918631.png" alt="image-20250806171918631" style="zoom: 50%;" />
<p>​	在使用KD-tree划分空间时，会不可避免的出现包围盒和物体相交的情况，但是计算三角形和包围盒的相交是比较麻烦的事情，而且一个物体可能会和多个包围盒相交，那么这些相交的包围盒所在的子节点都要存储一份该物体。</p>
<p>简而言之，使用KD-tree会带来以下问题：</p>
<ol>
<li>计算三角形和包围盒相交是困难的</li>
<li>一个物体可能会被存储多份（与该物体相交的包围盒都要保存该物体）</li>
</ol>
<p>为了解决这些问题，就要避免出现包围盒和物体相交的情况，BVH就解决了这一问题。</p>
<h3 id="层次包围体（Bounding-Volume-Hierarchy，BVH）"><a class="header-anchor" href="#层次包围体（Bounding-Volume-Hierarchy，BVH）"></a>层次包围体（Bounding Volume Hierarchy，BVH）</h3>
<p>​	前面介绍的划分都是基于空间的划分，但是<strong>BVH是基于物体的划分</strong>，保证了<strong>每个物体只会在一个包围盒内</strong>。</p>
<p>​	BVH的划分方式是<strong>递归地将物体划分为两部分</strong>，再根据每部分的物体计算每部分的包围盒，以此类推，递归划分。当某个节点内的物体小于某个阈值时停止划分该节点。</p>
<p>​	这样的划分并不是严格根据空间划分的，所以不同包围盒之间是会出现相互重叠的，但是可以保证每个物体只会在一个包围盒内，避免了物体和包围盒相交的情况。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250921225006212.png" alt="image-20250921225006212" style="zoom:80%;" />
<p>​	下面是可以在划分节点时让BVH更好划分的两个技巧：</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250806173704528.png" alt="image-20250806173704528" style="zoom:50%;" />
<p>​	下面是用BVH划分场景后，计算光线是否和光线相交的算法的伪代码：</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250806173720121.png" alt="image-20250806173720121" style="zoom: 50%;" />
<h2 id="辐射度量学"><a class="header-anchor" href="#辐射度量学"></a>辐射度量学</h2>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250806180301199.png" alt="image-20250806180301199" style="zoom:50%;" />
<h3 id="为什么要学辐射度量学"><a class="header-anchor" href="#为什么要学辐射度量学"></a>为什么要学辐射度量学</h3>
<p>在前面提到的whited-style光线追踪模型，它真的是一个正确的模型吗？显然不是，原因如下：</p>
<p><strong>1 whited-style光线追踪并没有对漫反射的光线进行追踪，而是直接返回当前着色点颜色。</strong><br>
<strong>2 在计算光源直接照射的贡献时，使用了Blinn-Phong模型，而Blinn-Phong模型本身就是一个不准确的经验模型，使用的这种模型的whited-style光线追踪自身自然也是不正确的。</strong></p>
<p>最终得到的渲染结果和现实相差还是比较大的，为了渲染结果更接近现实，我们要对光及光的各种描述有更加符合物理世界的规则，所以需要学习辐射度量学来解决这一问题。</p>
<p>辐射度量学其实是对光照的一套测量系统和单位，它能够准确的描述光线的物理性质。</p>
<p>具体来说，我们需要明白的是其中的几个关于光线概念，分别为：<br>
<strong>辐射能量(Radiant energy)</strong>，<strong>辐射通量(Radiant flux)</strong>，<strong>辐射强度(Radiant intensity)</strong>，<strong>irradiance</strong>，<strong>radiance</strong>。</p>
<h3 id="辐射能量-Radiant-energy"><a class="header-anchor" href="#辐射能量-Radiant-energy"></a><strong>辐射能量(Radiant energy)</strong></h3>
<p>看起来比较直观，单位是<strong>焦耳</strong>，可以类比热学中的<strong>功</strong>。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240126104345583.png" alt="image-20240126104345583" style="zoom:67%;" />
<h3 id="辐射通量-Radiant-flux-power"><a class="header-anchor" href="#辐射通量-Radiant-flux-power"></a>辐射通量(Radiant flux)(power)</h3>
<p>根据定义来说是单位时间内接收、发散等的能量，单位是<strong>瓦特</strong>或<strong>流明</strong>（也就是我们常说的光的<strong>亮度</strong>），可以类比热学中的<strong>功率</strong>。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240126104446840.png" alt="image-20240126104446840" style="zoom:67%;" />
<h3 id="辐射强度-Radiant-intensity"><a class="header-anchor" href="#辐射强度-Radiant-intensity"></a><strong>辐射强度(Radiant intensity)</strong></h3>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240126113442916.png" alt="image-20240126113442916" style="zoom:67%;" />
<p><strong>1 Radiant itensity其实就是指从一个光源出发某一方向上的亮度，也就是光源某根光线的亮度</strong><br>
<strong>2 Irradiance指某一微小平面所接受到的光线亮度</strong><br>
<strong>3 radiance衡量的是一条传播光线所具有的亮度(不受传播方向影响)</strong><br>
（这里的亮度也可以理解为radiant flux(power)）</p>
<p>从定义来看，在·就是每<strong>单位立体角</strong>的<strong>Radiant flux</strong> (power) 。也即<strong>单位时间</strong>内，在<strong>单位立体角</strong>上接收或发散的光的能量。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240126113544202.png" alt="image-20240126113544202" style="zoom:67%;" />
<p>那么立体角是什么呢？</p>
<p>我们首先看<strong>二维平面中弧度</strong>怎么计算。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240126113716465.png" alt="image-20240126113716465" style="zoom:80%;" />
<p>其实立体角就是弧度在三维空间中的推广，即<strong>三维球体</strong>中的弧度。即立体角度所对应球上的投影面积比上半径的平方，整个球的立体角为4 π。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240126113813374.png" alt="image-20240126113813374" style="zoom: 80%;" />
<p>​	那么对于Radiant intensity的定义当中，微分立体角dω 计算如下：<br>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240126113944642.png" alt="image-20240126113944642" style="zoom:67%;margin-left:300px"/></p>
<p>​	注意在<strong>计算微分立体角之前，我们其实选定了空间当中的一个方向（由θ ,ϕ所确定），称这个方向为ω，是一个单位向量</strong>。然后才在此基础之上分别对 θ ,ϕ 增加 dθ ,dϕ 经计算得到最终的 dω 。</p>
<p>​	至此<strong>Radiant intensity</strong>的物理含义此时就很清楚了，即<strong>光源向某一方向所发射出的单位立体角的功率</strong>，简而言之就是<strong>光源在某个方向上的亮度</strong>如何！</p>
<p>​	因此对于各向同性点光源来说，每个方向相同距离的亮度或者说能量都一样。因为已经定义了 <em>I</em> 为单位时间、单位立体角上接收或散发的能量，ϕ为光源单位时间散发的能量，那么将该点光源所有方向立体角的intesity求和可得该光影单位时间所散发的能量 ϕ。具体公式如下图所示：</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240126114124196.png" alt="image-20240126114124196" style="zoom:67%;" />
<h3 id="Irradiance-考虑所有方向"><a class="header-anchor" href="#Irradiance-考虑所有方向"></a>Irradiance(考虑所有方向)</h3>
<p>​	从定义来看是指单<strong>位照射面积的power</strong>，但是表明必须要和光线垂直才可直接这样写，否则要乘cos值。说明了光照的能量会随着接触面积的减小而减小。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240126105602149.png" alt="image-20240126105602149" style="zoom: 80%;" />
<p>​	在Blinn-Phong模型所提到的光线越远会越加衰减：</p>
<p>​	该现象也完全可以用irradiance解释，因为光的功率 ϕ 始终一致，离点光源所照射到的圆球面积也就越大，因此根据irradiance的式子，分母的<strong>面积值</strong>也就<strong>越大</strong>，<strong>irradiance</strong>也就<strong>越小</strong>。（光的功率 ϕ 不变，点光源向四面八方均匀发射光线，所以能量被均匀的分布在一个球面上，距离越远，球面面积越大，对应每个方向的功率也就越小）。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240126110237885.png" alt="image-20240126110237885" style="zoom: 80%;" />
<h3 id="Radiance-只考虑一个方向"><a class="header-anchor" href="#Radiance-只考虑一个方向"></a>Radiance(只考虑一个方向)</h3>
<p>​	所谓radiance就是指<strong>每单位立体角，每单位垂直面积的power</strong>。直观来看的话，很像是Intensity和irradiance的结合。<strong>它同时指定了光的方向与照射到的表面所接受到的亮度</strong>。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240126110654997.png" alt="image-20240126110654997" style="zoom: 80%;" />
<p>这个量可以把前面的<strong>Irradiance</strong>和<strong>Intensity</strong>两个量联系在一起。</p>
<p>Irradiance表示单位面积的power，所以<strong>Radiance</strong>可以理解为<strong>单位立体角</strong>的<strong>Irradiance</strong></p>
<p>Intensity表示单位立体角的power，所以<strong>Radiance</strong>可以理解为<strong>单位面积</strong>的<strong>Intensity</strong></p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240126111114950.png" alt="image-20240126111114950" style="zoom:50%;" />
<p>两者的区别在与是否考虑方向性：</p>
<p><strong>Irradiance</strong>指该单位面积接收的<strong>四面八方</strong>的光线的<strong>power的总和</strong>。简单来说就是某块区域收到的的power总和。</p>
<p><strong>Radiance</strong>指从该单位面积区域出发的某<strong>一方向</strong>辐射的<strong>power</strong>。简单来说就是某块区域某个方向发散的光线的power。</p>
<p>最后可得到下图中所式Irradiance和Radiance的联系：</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240126113127927.png" alt="image-20240126113127927" style="zoom:67%;" />
<p>观察一下积分后的式子，<strong>E(p)<strong>就是点</strong>p</strong>的<strong>irradiance</strong>，那么该积分式子的物理含义便是，一个点(微分面积元)所接收到的亮度(irradiance)，由所有不同方向的入射光线亮度(radiance)共同贡献得到。</p>
<h3 id="双向反射分布函数-Bidirectional-Reflectance-Distribution-Function，BRDF"><a class="header-anchor" href="#双向反射分布函数-Bidirectional-Reflectance-Distribution-Function，BRDF"></a>双向反射分布函数(Bidirectional Reflectance Distribution Function，BRDF)</h3>
<p>​	介绍了上面这些概念后，我们就开始更具体的描述一下反射。BRDF可以更具体的给出某点的<strong>入射光线经过反射后每个方向的反射光线的能量是多少</strong>，可以更真实的模拟真实的反射。</p>
<p>​	现在我们可以换个角度理解反射，如下图所示：光线从某一方向照射到物体表面一点(表面微元)，会先吸收一部分能量，然后四处扩散这些能量。即根据入射光计算表明微元处的<strong>Radiance</strong>，然后再向四处扩散计算四周每个方向的<strong>Radiance</strong>。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240126154411561.png" alt="image-20240126154411561" style="zoom: 80%;" />
<p>​	在理想光滑表面会把入射光线完全反射到镜面反射方向，其它方向则完全没有。如理想粗糙表面会把入射光线均匀的反射到所有方向。因此所谓BRDF就是描述这样一个从不同方向入射之后，<strong>反射光线分布情况</strong>(每一个出射方向的能量的比例)的函数，定义如下：</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240126154918469.png" alt="image-20240126154918469" style="zoom: 80%;" />
<p>​	上图中下方的式子即为BRDF，它就收两个参数入射光方向ωi,反射光方向ωr ，<strong>函数值</strong>为反射光的<strong>radiance</strong>与入射光的<strong>iiradiance</strong>的比值。表明出射光在该方向的能量比例。</p>
<p>​	借助BRDF，我们可以写出<strong>反射方程</strong>：</p>
<p>​	简单描述就是入射点处吸收的iradiance乘以在该出射方向的比例，对于相机观测方向来说，所观察到的光的能量就是空间中所有能打到该点的radiance向该方向反射的radiance之和，所以要对半球面积分求和。（对于反射来说，我们只考虑上半球面，下半球面相当于从背面过来的，我们认为这部分贡献为0，所以不考虑 ）</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240126155600307.png" alt="image-20240126155600307" style="zoom: 50%;" />
<p>​	进一步考虑方程的通用性，加上物体自身发出的光线，就形成了<strong>渲染方程</strong>。渲染方程将光分为两部分：物体自身产生的向外发散的光(方程的前一项)、外来的光照射在物体表面被反射的光(方程的后一项)。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240126160230963.png" alt="image-20240126160230963" style="zoom:67%;" />
<p>​	其中<strong>L e ( p, ωo )L</strong> 为自发光项，反射方程中的<strong>cosθ</strong>用，<strong>n ⋅ ωi</strong>代替。(tips：所有光线方向均指向外)</p>
<p>​	下面从点光源到多种光源具体解释一下渲染方程：</p>
<p>​	对于点光源来说，本身就足够小，不用求积分。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240126163604630.png" alt="image-20240126163604630" style="zoom: 80%;" />
<p>​	对于多个点光源，只需要将其反射光的反射相加即可。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240126163614339.png" alt="image-20240126163614339" style="zoom: 80%;" />
<p>​	对于面光源来说，只需要将面上所有点光源累加即可。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240126163715862.png" alt="image-20240126163715862" style="zoom: 80%;" />
<p>​	再进一步加上场景中其他物体的间接反射光，也就形成了全局光照。</p>
<p>​	可以把其它物体同样考虑成面光源，对其所占立体角进行积分即可，只不过对其它物体的立体角积分不像是面光源所有入射方向都有radiance，物体的立体角可能只有个别几个方向有入射的radiance(即多次物体间光线反射之后恰好照射到着色点x)，其它方向没有，但本质上都可以视作是面光源。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240126163819892.png" alt="image-20240126163819892" style="zoom: 80%;" />
<p>​	为了求解方便，我们转换一下参数，利用数学推导得出下图中式子：</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240126163906892.png" alt="image-20240126163906892" style="zoom: 80%;" />
<p>​	再进一步转化为线性表达式的形式：</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240126163915914.png" alt="image-20240126163915914" style="zoom: 80%;" />
<p>​	最终求解L可得：</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240126164022107.png" alt="image-20240126164022107" style="zoom: 80%;" />
<p>​	E为自身作为光源发出的光，KE则代表对光源反射一次的结果，即直接光照，那么前两项之和就是光栅化当中着色所考虑的结果，对于全局光照来说，还考虑了K<sup>2</sup>E，即一次弹射的间接照明，K<sup>3</sup>E 就是两次弹射的间接照明，依次类推。</p>
<p>​	这样来看整个结果是不是就很清晰了，就是<strong>光源发光</strong>加上<strong>直接光照</strong>与<strong>多次间接光照</strong>的结果！而这一切都是从渲染方程推导而来的，因此这也正是渲染方程的物理意义！</p>
<h1 id="路径追踪-Path-Tracing"><a class="header-anchor" href="#路径追踪-Path-Tracing"></a>路径追踪(Path Tracing)</h1>
<p>​	我们虽然得到了渲染方程，但是是积分形式的渲染方程，为了得到可以具体实现应用，还需要对这个方程进行求解。但是渲染方程时积分的形式，我们无法准确求解，可以使用<strong>蒙特卡洛积分</strong>来<strong>求解渲染方程</strong>。</p>
<h2 id="蒙特卡洛积分-Monte-Carlo-Integration"><a class="header-anchor" href="#蒙特卡洛积分-Monte-Carlo-Integration"></a>蒙特卡洛积分(Monte Carlo Integration)</h2>
<p>​	对于一个给定的函数<strong>f(x)</strong>，我们很容易求其在某一区间内的积分值，但是如下图中所示，我们<strong>无法准确写出其表达式</strong>，求[a,b]区间内的积分会非常困难，所以就有了蒙特卡洛积分。</p>
<p>​	所以<strong>蒙特卡洛积分的目的：</strong> 当一个积分很难通过解析式得到答案的时候可以通过蒙特卡洛的方式<strong>近似</strong>得到积分结果。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240127163006089.png" alt="image-20240127163006089" style="zoom:67%;" />
<p>​	具体做法就是随机从[a,b]内取一点xi，求出这点的f(xi)，并用结果当作矩形的高,矩形的长为b-a，我们就用这样<strong>一个矩形的面积近似代替曲线面积</strong>。当我们<strong>取样的点足够多</strong>，并将<strong>这些面积进行平均求和</strong>，最后的结果就会非常<strong>接近原曲线围成的面积</strong>。蒙特卡洛积分的一般形式如下：</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240127164446051.png" alt="image-20240127164446051" style="zoom: 80%;" />
<p>​	假设我们做的是均匀采样，即<strong>p(x) = 1/(b-a)</strong>，带入可得到下式：</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240127164529009.png" alt="image-20240127164529009" style="zoom:90%;" />
<h2 id="路径追踪-Path-Tracing-k2"><a class="header-anchor" href="#路径追踪-Path-Tracing-k2"></a>路径追踪(Path Tracing)</h2>
<p>​	我们先回顾一下前面的渲染方程，可以看到这个方程还是比较复杂的，并且由于多次的反射，函数还是一个递归式求解的，求解还是比较困难的。但是我们可以用<strong>蒙特卡洛积分进行求近似解</strong>。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240127165550323.png" alt="image-20240127165550323" style="zoom:67%;" />
<p>要想解出以上方程的解主要有两个难点：</p>
<ol>
<li><strong>积分的计算</strong></li>
<li><strong>递归形式</strong></li>
</ol>
<p>​	在进入具体计算之前，对渲染方程做出一点小修改，即舍弃一下自发光项(假设除了光源其他物体不会发光), 以方便进行计算推导：</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240127185658277.png" alt="image-20240127185658277"  />
<p>​	首先我们只考虑直接光照，即没有经过其他物体反射直接从光源照射到物体表面。我们考虑的光源都是面光源，点光源实际上实现比较困难。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240127185817756.png" alt="image-20240127185817756" style="zoom: 67%;" />
<p>​	观察该修改过之后的方程其实就只是一个单纯的积分计算了，其物理含义为着色点p到摄像机或人眼的Radiance值。</p>
<p>这么一个积分式我们直接展开计算是比较困难的，所以可以利用蒙特卡洛积分进行近似相等，近似结果如下：</p>
<p><img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240127190144947.png" alt="image-20240127190144947"></p>
<p>​	正如一开始所说，先单独考虑直接光照，因此只有当采样的方向ωi击中光源的时候，光源才会对该着色点有贡献，计算伪代码如下：</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240127190233240.png" alt="image-20240127190233240" style="zoom: 80%;" />
<p>​	通过上面步骤，我们就解决了如何求积分的问题。但既然是为了实现全局光照，只考虑直接光照显然是不够的，我们必须把简介光照也考虑进来。如下图中情况所示，光线经过多次反射才进入相机。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240127190422104.png" alt="image-20240127190422104" style="zoom: 50%;" />
<p>​	那么该怎么样求出P点接收到的间接光线呢，对于Q到P的光线来说，我们可以此时把Q点看作一个光源，然后Q点向P点发散的Radiance，这就求出了P点接收到的间接入射光，这显然是一个递归式的求解过程，这也是为什么这个方法叫做路径追踪。伪代码如下：</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240127190846711.png" alt="image-20240127190846711" style="zoom: 80%;" />
<p>​	至此，我们成功通过蒙特卡洛的方式解出了渲染方程的积分值，也通过考虑直接光照与间接光照解决了递归的问题。但是现在还有一个致命的问题，对于递归算法来说，运行过程就好像数据结构中的树，每一个节点都会向下延伸n个子节点，这样下去数量级会爆炸式增长，这显然不是我们所希望看到的。</p>
<p>​	就如下图所示，每次都采样100个点，即发射100条光线，经过反射一次后，反射处每次又会都发射100条光线，光线数量随反射次数乘指数级增长。</p>
<p><img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240127191033675.png" alt="image-20240127191033675"></p>
<p>​	那么该如何解决这个问题呢？因为N表示蒙特卡洛积分的样本数量，但是根据指数函数会爆炸式增长，为了防止出现这种情况，我们只能将<strong>N取1</strong>，即<strong>每次只向一个方向发射光线</strong>。这样才不会随着反弹次数的增加指数级增长。</p>
<p><img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240127191431445.png" alt="image-20240127191431445"></p>
<p>​	但是蒙特卡洛积分又是近似值，N=1必然会导致得出的结果不准确，所以我们就需要多次执行这个递归算法，找到多条路径，最终的结果取平均值，尽量的减小误差。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240127191534017.png" alt="image-20240127191534017"  />
<p>​	下面是改良后的伪代码：</p>
<p><img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240127191608911.png" alt="image-20240127191608911"></p>
<p>​	通过对经过像素的光线重复采样，每次在反射的时候只按分布随机选取一个方向，解决了只对经过像素的光线采样一次，而对反射光线按分布采样多次所导致的光线爆炸问题。</p>
<p>​	但是现在问题还是没有解决，作为一个递归算法，可<strong>拆分子问题</strong>和<strong>结束条件</strong>两个因素缺一不可，我们的伪代码中似乎还没有说明递归应该什么时候停止，目前的算法只会一直递归下去，不会停止，这显然也是一个致命的问题。但是我们并不知道准确的退出次数，所以精妙的采用了<strong>俄罗斯轮盘赌(Russian Roulette)</strong>。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240127191908076.png" alt="image-20240127191908076" style="zoom:67%;" />
<p>​	给你一把左轮，两发子弹，你不知道哪一发会真正的射出子弹，因此拿这把左轮射自己，你有4/6的概率活下来，这就是俄罗斯轮盘赌的概念。</p>
<p>​	将其应用在路径追踪当中，首先设定一个概率P , <strong>有P的概率光线会继续递归并设置返回值为Lo / P</strong>，有<strong>1 − P 的概率光线停止递归，并返回0</strong>。这样巧妙的设定之下光线一定会在某次反射之后停止递归，并且计算的结果依然是无偏的，因为最终的期望不变，证明如下：</p>
<p><img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240127192007558.png" alt="image-20240127192007558"></p>
<p>​	至此伪代码可以改进为如下形式：</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240127192043052.png" alt="image-20240127192043052"  />
<p>​	到此看来我们的算法好像已经很完善了，但是最后还是有一个小问题，那就是<strong>算法的效率并不高</strong>。</p>
<p>​	如下图所示：我们从某点向空间中上半球发射光线，随着光源区域的变小，可以到达光源的有效光线的比例也在减少。换句话说就是我们花费了大量的时间计算了不需要的方向，这导致这个算法效率比较低。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240127192146861.png" alt="image-20240127192146861" style="zoom: 80%;" />
<p>​	出现上述问题是因为我们是在空间中半球进行采样，那么我们直接在光源处进行采样，所有的计算不就都是有意义的计算了吗。但最大的问题就是如何将<strong>从对任意方向的采样转换到在光源上的采样</strong>，这就要最牛逼的数学登场了。</p>
<p>​	假设光源的面积为A，那么对光源进行采样的pdf = 1/A (因为∫ pdf ⁡dA = 1 )，但原始的渲染方程：</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240127192733131.png" alt="image-20240127192733131"  />
<p>​	显然两个方程的微分变量不同，我们要想把dw转换为dA，由微积分的知识可知，必须找到变量w和A之间的关系。如下图所示，我们可以理解为dw是光源上面积为dA的部分投影到球面上后所对应的立体角dw。</p>
<p>​	首先将<strong>光源面乘以余弦值</strong>将光源面投影到与打出的光线垂直的方向，又因为立体角的定义是面积除以距离的平方，所以可以求出投影后的光源面积对应的立体角，将dw替换为dA的表达式即可。</p>
<p>​	等式是由前面讲的立体角部分推导而来，左侧为<strong>立体角</strong>，右侧为<strong>球面的面积与半径的平方的比值</strong>。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240127192854758.png" alt="image-20240127192854758" style="zoom: 80%;" />
<p>​	根据这一关系，进行积分变量的替换后，渲染方程可以写为：</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240127193308830.png" alt="image-20240127193308830"  />
<p>​	这样便成功从 <strong>ωi</strong> 积分转到了对光源面积A的积分，就可以利用蒙特卡洛的方法对光源进行采样从而计算直接光照的积分值了，对于间接光照，依然采用先前的方法进行光线方向的均匀采样。最终伪代码如下，分直接光照和间接光照两部分计算：</p>
<p>​	上一部分是计算直接光照，下部分会根据概率判断是否继续计算间接光照。这就得到了最终的路径追踪的算法。因为直接光照我们可以直接对光源采样得到，不需要用俄罗斯轮盘赌的方法进行判断；而间接光照由于需要递归多次，我们就用俄罗斯轮盘赌的方法结束递归。</p>
<p>​	并且对应间接光照的部分，只计算来自非光源的反射光，因为这部分是直接光，第一部分就已经计算了，所以只需要计算由周围其他物体反射来的间接光。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240127193406394.png" alt="image-20240127193406394"  />
<p>​	另外计算直接光照的时候还需要判断光源与着色点之间是否有物体遮挡，该做法也很简单，只需从着色点x向光源采样点x’发出一条检测光线判断是否与光源之外的物体相交即可，如图所示:</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240127193550723.png" alt="image-20240127193550723"  />
<h1 id="PBR（Physical-Based-Renderer）"><a class="header-anchor" href="#PBR（Physical-Based-Renderer）"></a>PBR（Physical Based Renderer）</h1>
<h2 id="Microfacet-Model（微表面模型）"><a class="header-anchor" href="#Microfacet-Model（微表面模型）"></a>Microfacet Model（微表面模型）</h2>
<h1 id="颜色"><a class="header-anchor" href="#颜色"></a>颜色</h1>
<h1 id="games101作业"><a class="header-anchor" href="#games101作业"></a>games101作业</h1>
<h2 id="作业1"><a class="header-anchor" href="#作业1"></a>作业1</h2>
<h2 id="作业2"><a class="header-anchor" href="#作业2"></a>作业2</h2>
<h3 id="正常"><a class="header-anchor" href="#正常"></a>正常</h3>
<p>最普通的情况下没有进行任何的反走样，只是单纯的判断某个像素中心点在不在三角形内，再使用z-buffer算法更新frame_buffer中各像素的颜色值。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;Screen space rasterization
void rst::rasterizer::rasterize_triangle(const Triangle&amp; t) &#123;
    auto v &#x3D; t.toVector4();
    
    Vector3f triangleVector[3];

    triangleVector[0] &#x3D; &#123; v[0].x(), v[0].y(), v[0].z() &#125;;
    triangleVector[1] &#x3D; &#123; v[1].x(), v[1].y(), v[1].z() &#125;;
    triangleVector[2] &#x3D; &#123; v[2].x(), v[2].y(), v[2].z() &#125;;

    &#x2F;&#x2F;计算三角形的包围盒，加速光栅化
    float minX &#x3D; INFINITY, minY &#x3D; INFINITY;
    float maxX &#x3D; 0.0f, maxY &#x3D; 0.0f;
    for (auto p : v)
    &#123;
        minX &#x3D; std::min(minX, p.x());
        minY &#x3D; std::min(minY, p.y());

        maxX &#x3D; std::max(maxX, p.x());
        maxY &#x3D; std::max(maxY, p.y());
    &#125;
    &#x2F;&#x2F;使用z-buffer算法正常采样
    for (int x &#x3D; (int)minX; x &lt;&#x3D; (int)maxX; x++)
        for (int y &#x3D; (int)minY; y &lt;&#x3D; (int)maxY; y++)
        &#123;
            if (insideTriangle(x + 0.5f, y + 0.5f, triangleVector))
            &#123;
                auto[alpha, beta, gamma] &#x3D; computeBarycentric2D(x, y, t.v);
                float w_reciprocal &#x3D; 1.0&#x2F;(alpha &#x2F; v[0].w() + beta &#x2F; v[1].w() + gamma &#x2F; v[2].w());
                float z_interpolated &#x3D; alpha * v[0].z() &#x2F; v[0].w() + beta * v[1].z() &#x2F; v[1].w() + gamma * v[2].z() &#x2F; v[2].w();
                z_interpolated *&#x3D; w_reciprocal;
                &#x2F;&#x2F;如果当前像素深度值小于该像素的深度缓冲，则更新该像素的颜色缓冲
                if (z_interpolated &lt; depth_buf[get_index(x,y)])
                &#123;
                    depth_buf[get_index(x, y)] &#x3D; z_interpolated;
                    Vector3f point &#x3D; &#123; (float)x, (float)y, z_interpolated &#125;;
                    Vector3f color &#x3D; t.getColor();
                    set_pixel(point, color);
   	            &#125;
            &#125;
        &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>虽然可以正确绘制出来并且遮挡关系也正确，但是当我们放大图片后就会发现锯齿效果明显，所以需要反走样。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250910234354624.png" alt="image-20250910234354624" style="zoom: 40%;" />
<h3 id="MSAA2X"><a class="header-anchor" href="#MSAA2X"></a>MSAA2X</h3>
<p>为了实现抗锯齿，这里使用MSAA2X，即使用每个像素4倍采样，以此实现抗锯齿。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;分别存放每个像素的4个采样块的深度缓冲和颜色缓冲，且大小是原来的4倍
std::vector&lt;Eigen::Vector3f&gt; sup_frame_buf;
std::vector&lt;float&gt; sup_depth_buf;

&#x2F;&#x2F;传入正常的像素坐标和第i个采样块的标号，计算该采样块的序号（像素内4个采样块的序号从左到右，从上到下依次为0 1 2 3）
int rst::rasterizer::get_supre_index(int x, int y, int i)
&#123;
    int row &#x3D; 2 * y + i &#x2F; 2;
    int col &#x3D; 2 * x + i % 2;
    return (height * 2 - 1 - row) * width * 2 + col;
&#125;

&#x2F;&#x2F;MSAA2x超采样
float offets[4][2] &#x3D; &#123;
    &#123;0.25,0.75&#125;,
    &#123;0.75,0.75&#125;,
    &#123;0.25,0.25&#125;,
    &#123;0.75,0.25&#125;,
&#125;;
for(int x &#x3D; (int)minX; x &lt;&#x3D; (int)maxX; x++)
    for (int y &#x3D; (int)minY; y &lt;&#x3D; (int)maxY; y++)
    &#123;
        &#x2F;&#x2F;遍历所有像素时，将每个像素的四个采样块也都看做单独的像素，记录每个采样块最终的颜色
        int cnt &#x3D; 0;
        for (int i &#x3D; 0; i &lt; 4; i++)
        &#123;
            if (insideTriangle(x + offets[i][0], y + offets[i][1], triangleVector))
            &#123;
                cnt++;
                
                auto [alpha, beta, gamma] &#x3D; computeBarycentric2D(x, y, t.v);
                float w_reciprocal &#x3D; 1.0 &#x2F; (alpha &#x2F; v[0].w() + beta &#x2F; v[1].w() + gamma &#x2F; v[2].w());
                float z_interpolated &#x3D; alpha * v[0].z() &#x2F; v[0].w() + beta * v[1].z() &#x2F; v[1].w() + gamma * v[2].z() &#x2F; v[2].w();
                z_interpolated *&#x3D; w_reciprocal;

                if (z_interpolated &lt; sup_depth_buf[get_supre_index(x, y ,i)])
                &#123;
                    sup_depth_buf[get_supre_index(x, y, i)] &#x3D; z_interpolated;
                    sup_frame_buf[get_supre_index(x, y, i)] &#x3D; t.getColor();
                &#125;
            &#125;
        &#125;
        &#x2F;&#x2F;如果有一个采样块的颜色更新了，那么这个大像素的颜色就需要更新
        if (cnt)
        &#123;
            Vector3f color &#x3D; Vector3f::Zero();
            for (int i &#x3D; 0; i &lt; 4; i++) color +&#x3D; 0.25 * sup_frame_buf[get_supre_index(x, y, i)];
            set_pixel(Vector3f&#123;(float)x, (float)y ,1.0&#125;, color);
        &#125;

    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最终得到的图片即使放大同样的倍数也不会有明显的锯齿。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250910235144201.png" alt="image-20250910235144201" style="zoom: 67%;" />

                
            </div>
            <hr/>

            



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/">
                                    <span class="chip bg-color">计算机图形学</span>
                                </a>
                            
                                <a href="/tags/GAMES101/">
                                    <span class="chip bg-color">GAMES101</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/2025/11/22/Games101/">
                    <div class="card-image">
                        
                        
                        <img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/feature_map/6.png" class="responsive-img" alt="Games101课堂笔记和作业">
                        
                        <span class="card-title">Games101课堂笔记和作业</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            GAME101课程的笔记和作业总结
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2025-11-22
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/" class="post-category">
                                    计算机图形学
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/">
                        <span class="chip bg-color">计算机图形学</span>
                    </a>
                    
                    <a href="/tags/GAMES101/">
                        <span class="chip bg-color">GAMES101</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2025/11/22/OpenGL/">
                    <div class="card-image">
                        
                        
                        <img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/feature_map/4.png" class="responsive-img" alt="OpenGL学习笔记">
                        
                        <span class="card-title">OpenGL学习笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            OpenGL学习的笔记和总结
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2025-11-22
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                    学习笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/OpenGL/">
                        <span class="chip bg-color">OpenGL</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('1'),
            headingSelector: 'h1, h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2025</span>
            
            <a href="/about" target="_blank">小明</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
                <span id="translate">|&nbsp;繁/简：</span><a id="translateLink" href="javascript:translatePage();">繁</a>
            
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">106.6k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
                <span id="sitetime"> Loading ...</span>
                <script>
                    var calcSiteTime = function () {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = "2025";
                        var startMonth = "11";
                        var startDate = "22";
                        var startHour = "16";
                        var startMinute = "0";
                        var startSecond = "0";
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);
                        // 补全计算时、分、秒的部分
                        // 计算剩余毫秒数（扣除已计算的年和天）
                        var remainingMs = diff - (diffYears * years) - (diffDays * days);
                        // 计算小时数
                        var diffHours = Math.floor(remainingMs / hours);
                        remainingMs = remainingMs % hours;
                        // 计算分钟数
                        var diffMinutes = Math.floor(remainingMs / minutes);
                        remainingMs = remainingMs % minutes;
                        // 计算秒数
                        var diffSeconds = Math.floor(remainingMs / seconds);

                        // 区分是否有年份.
                        var language = 'zh-CN';
                        if (startYear === String(todayYear)) {
                            document.getElementById("year").innerHTML = todayYear;
                            var daysTip = 'This site has been running for ' + diffDays + ' days'+  diffHours + ' hours'  + diffMinutes + ' minutes'  + diffSeconds + ' seconds';
                            if (language === 'zh-CN') {
                                daysTip = `本站已运行 ${diffDays} 天 ${String(diffHours).padStart(2, '0')} 时 ${String(diffMinutes).padStart(2, '0')} 分 ${String(diffSeconds).padStart(2, '0')} 秒`;
                            } else if (language === 'zh-HK') {
                                daysTip = '本站已運行 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = daysTip;
                        } else {
                            document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                            var yearsAndDaysTip = 'This site has been running for ' + diffYears + ' years and '
                                + diffDays + ' days';
                            if (language === 'zh-CN') {
                                yearsAndDaysTip = `本站已运行 ${diffYears}年 ${diffDays} 天 ${String(diffHours).padStart(2, '0')} 时 ${String(diffMinutes).padStart(2, '0')} 分 ${String(diffSeconds).padStart(2, '0')} 秒`;
                            } else if (language === 'zh-HK') {
                                yearsAndDaysTip = '本站已運行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
                        }
                    }
                    setInterval(calcSiteTime, 1000)
                </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/6xiaoming6" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:2022790507@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2022790507" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2022790507" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    
        <!-- <script src='https://unpkg.com/mermaid@latest/dist/mermaid.min.js'></script> -->
        <script src='/libs/mermaid/mermaid.min.js'></script>
        <script>
          if (window.mermaid) {
            mermaid.initialize({theme: 'forest'});
          }
        </script>
    

    
        <script type="text/javascript" src="/js/tw_cn.js"></script>
        <script type="text/javascript">
          var defaultEncoding = 2; //网站编写字体是否繁体，1-繁体，2-简体
          var translateDelay = 0; //延迟时间,若不在前, 要设定延迟翻译时间, 如100表示100ms,默认为0
          var cookieDomain = "http://example.com"; //Cookie地址, 一定要设定, 通常为你的网址
          var msgToTraditionalChinese = "繁"; //此处可以更改为你想要显示的文字
          var msgToSimplifiedChinese = "简"; //同上，但两处均不建议更改
          var translateButtonId = "translateLink"; //默认互换id
          translateInitilization();
        </script>
    
    
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="/libs/background/canvas-nest.js"></script>
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
