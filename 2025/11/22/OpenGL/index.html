<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="OpenGL学习笔记, 小明茶馆">
    <meta name="description" content="OpenGL学习的笔记和总结">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>OpenGL学习笔记 | 小明茶馆</title>
    <link rel="icon" type="image/svg+xml" href="/myfavicon.svg">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 8.1.1"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/mylogo.svg" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">小明茶馆</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fa-brands fa-bilibili fa-beat-fade" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fas fa-list" style="zoom: 0.6;"></i>
      
      <span>多媒体</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/musics">
          
          <i class="fas fa-music" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>音乐</span>
        </a>
      </li>
      
      <li>
        <a href="/movies">
          
          <i class="fas fa-film" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>电影</span>
        </a>
      </li>
      
      <li>
        <a href="/books">
          
          <i class="fas fa-book" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>阅读</span>
        </a>
      </li>
      
      <li>
        <a href="/galleries">
          
          <i class="fas fa-image" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>相册</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/mylogo.svg" class="logo-img circle responsive-img">
        
        <div class="logo-name">小明茶馆</div>
        <div class="logo-desc">
            
            每天都要比昨天优秀一点
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fa-brands fa-bilibili fa-beat-fade"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-list"></i>
			
			多媒体
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>

                  <a href="/musics " style="margin-left:75px">
				  
				   <i class="fa fas fa-music" style="position: absolute;left:50px" ></i>
			      
		          <span>音乐</span>
                  </a>
                </li>
              
                <li>

                  <a href="/movies " style="margin-left:75px">
				  
				   <i class="fa fas fa-film" style="position: absolute;left:50px" ></i>
			      
		          <span>电影</span>
                  </a>
                </li>
              
                <li>

                  <a href="/books " style="margin-left:75px">
				  
				   <i class="fa fas fa-book" style="position: absolute;left:50px" ></i>
			      
		          <span>阅读</span>
                  </a>
                </li>
              
                <li>

                  <a href="/galleries " style="margin-left:75px">
				  
				   <i class="fa fas fa-image" style="position: absolute;left:50px" ></i>
			      
		          <span>相册</span>
                  </a>
                </li>
              
            </ul>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/feature_map/4.png')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">OpenGL学习笔记</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/OpenGL/">
                                <span class="chip bg-color">OpenGL</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                学习笔记
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2025-11-22
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2025-11-25
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    42.1k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    169 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="OpenGL介绍"><a class="header-anchor" href="#OpenGL介绍"></a>OpenGL介绍</h1>
<h2 id="图形API"><a class="header-anchor" href="#图形API"></a>图形API</h2>
<p>OpenGL被认为是一个图形API(Application Programming Interface, 应用程序编程接口)，包含一系列可以操作图形、图像的函数。但是OpenGL实际上并不是一个供外界调用的API，它本质上是一个由<a target="_blank" rel="noopener" href="http://www.khronos.org/">Khronos组织</a>制定并维护的规范。</p>
<p>OpenGL规定了每个函数的定义，输入和输出值，并不关心内部是如何实现的(类似java中的interface)。</p>
<p>也因此OpenGL的实现基本是由各大显卡厂商完成，各厂商要遵守这个规范，一般写在显卡的驱动程序中。开发者使用OpenGL时调用指定的函数，即可使用在不同显卡的设备中运行同一段代码。</p>
<p>在 OpenGL 中，<strong>默认的坐标系是右手坐标系</strong>，可以使用右手来判断坐标轴的正方向。</p>
<ul>
<li><strong>右手定则</strong>：
<ul>
<li>伸出右手，<strong>拇指 = X 轴（→）</strong>，<strong>食指 = Y 轴（↑）</strong>，<strong>中指 = Z 轴（☞ 屏幕外）</strong>。</li>
<li>这种定义下，<strong>摄像机默认看向 -Z 方向</strong>（即屏幕内）。</li>
</ul>
</li>
</ul>
<h2 id="立即模式和核心模式"><a class="header-anchor" href="#立即模式和核心模式"></a>立即模式和核心模式</h2>
<p>早期的OpenGL使用<strong>立即渲染模式</strong>（Immediate mode，也就是固定渲染管线），这个模式下绘制图形很方便。OpenGL的大多数功能都被库隐藏起来，开发者很少有控制OpenGL如何进行计算的自由。</p>
<p><strong>OpenGL3.2</strong>开始，规范文档开始废弃立即渲染模式，并鼓励开发者在OpenGL的<strong>核心模式</strong>(Core-profile)下进行开发，这个分支的规范完全移除了旧的特性。</p>
<p>虽然OpenGL的新版本一直在更新，但是作为初学者从支持核心模式的旧版本开始学习也是没问题的。因为所有OpenGL的更高的版本都是在3.3的基础上，引入了额外的功能，并没有改动核心架构。新版本只是引入了一些更有效率或更有用的方式去完成同样的功能。因此，所有的概念和技术在现代OpenGL版本里都保持一致。当你的经验足够，你可以轻松使用来自更高版本OpenGL的新特性。</p>
<h2 id="状态机"><a class="header-anchor" href="#状态机"></a>状态机</h2>
<h2 id="渲染管线"><a class="header-anchor" href="#渲染管线"></a>渲染管线</h2>
<p>OpenGL中<strong>默认</strong>规定三角形的三个顶点的连接顺序为<strong>逆时针</strong>，即将<strong>逆时针方向</strong>连接的三角形视为<strong>正面</strong>，但是对于正面判定也可以通过OpenGL中的函数进行修改。</p>
<p>规定了三角形的正反面后，在后续进行渲染时，不会渲染反面三角形（反面三角形是被遮挡看不到的，跳过渲染节省计算量）。</p>
<h1 id="CMake"><a class="header-anchor" href="#CMake"></a>CMake</h1>
<p>CMake 是个一个开源的跨平台自动化建构系统，用来管理软件建置的程序，并不依赖于某特定编译器，并可支持多层目录、多个应用程序与多个函数库。 CMake 本身不是构建工具，而是生成构建系统的工具，它生成的构建系统可以使用不同的编译器和工具链。</p>
<p>CMake使用**CMakeLists.txt（文件名不可变）**文件作为配置文件，用于定义项目的构建规则、依赖关系、编译选项等。每个 CMake 项目通常包含一个或多个 CMakeLists.txt 文件。</p>
<h2 id="简单的CMake项目工程"><a class="header-anchor" href="#简单的CMake项目工程"></a>简单的CMake项目工程</h2>
<p>下面是一个简单CMake项目示例，项目文件夹中只有一个main.cpp作为源文件。</p>
<p>下面是该项目的CMakeLists.txt文件内容：</p>
<pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment">#设置该CMake项目的最低CMake版本要求</span>
<span class="token keyword">cmake_minimum_required</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">3.17</span><span class="token punctuation">)</span>

<span class="token comment">#设置项目名称</span>
<span class="token keyword">project</span><span class="token punctuation">(</span>OpenGL<span class="token punctuation">)</span>

<span class="token comment">#设置项目所使用的c++版本为c++17</span>
<span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">CMAKE_CXX_STANDARD</span> <span class="token number">17</span><span class="token punctuation">)</span>

<span class="token comment">#指定要生成的可执行文件和其源文件（第一个参数是生成的可执行文件的名称，后面的参数是源文件）</span>
<span class="token comment">#参数之间空格隔开</span>
<span class="token keyword">add_executable</span><span class="token punctuation">(</span>OpenGLStudy <span class="token string">"main.cpp"</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250411204132847.png" alt="image-20250411204132847" style="zoom: 67%;" />
<p>项目文件准备完成后，使用vs按照上图所示操作打开CMake项目，vs会根据配置文件生成对应的文件。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250411204540750.png" alt="image-20250411204540750" style="zoom:67%;" />
<p>如上图所示，在项目根目录下会生成out文件夹，里面存放的就是生成的目标文件。因此在分享项目工程时，out文件夹和.vs文件夹可以删除，这些都是IDE自动生成的，而且比较大。在根目录下的out/build/x64-Debug目录下可以看到生成的可执行文件，名称和我们在CMakeLists.txt中定义的一样。</p>
<h2 id="多源文件编译"><a class="header-anchor" href="#多源文件编译"></a>多源文件编译</h2>
<p>实际开发中，肯定不可能只有一个main.cpp文件，我们肯定会创建许多类，会有多个cpp文件。</p>
<p>如下图所示，新建了func.h和func.cpp文件，在main.cpp文件中使用了func.cpp实现的add函数，此时如果直接运行代码会报错，因为我们并没有将func.cpp加入到CMake的编译目标中。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250411215637145.png" alt="image-20250411215637145" style="zoom:67%;" />
<p>我们有两种解决方法：</p>
<ol>
<li>手动将所有的cpp文件加入到CMakeLists.txt中的源文件中</li>
</ol>
<pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment">#设置该CMake项目的最低CMake版本要求</span>
<span class="token keyword">cmake_minimum_required</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">3.17</span><span class="token punctuation">)</span>

<span class="token comment">#设置项目名称</span>
<span class="token keyword">project</span><span class="token punctuation">(</span>00_Test<span class="token punctuation">)</span>

<span class="token comment">#设置项目所使用的c++版本为c++17</span>
<span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">CMAKE_CXX_STANDARD</span> <span class="token number">17</span><span class="token punctuation">)</span>

<span class="token comment">#指定要生成的可执行文件和其源文件（第一个参数是生成的可执行文件的名称，后面的参数是源文件）</span>
<span class="token keyword">add_executable</span><span class="token punctuation">(</span>OpenGLStudy <span class="token string">"main.cpp"</span> <span class="token string">"func.cpp"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="2">
<li>将根目录下的所有cpp找到并定义为一个新变量，使用该变量代替所有的源文件</li>
</ol>
<pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment">#设置该CMake项目的最低CMake版本要求</span>
<span class="token keyword">cmake_minimum_required</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">3.17</span><span class="token punctuation">)</span>

<span class="token comment">#设置项目名称</span>
<span class="token keyword">project</span><span class="token punctuation">(</span>00_Test<span class="token punctuation">)</span>

<span class="token comment">#设置项目所使用的c++版本为c++17</span>
<span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">CMAKE_CXX_STANDARD</span> <span class="token number">17</span><span class="token punctuation">)</span>

<span class="token comment">#搜索当前目录下的所有cpp文件，加入到RES变量中</span>
<span class="token comment"># . 表示当前目录</span>
<span class="token keyword">aux_source_directory</span><span class="token punctuation">(</span>. RES<span class="token punctuation">)</span>

<span class="token comment">#指定要生成的可执行文件和其源文件，使用RES变量替换所有的源文件名称</span>
<span class="token comment">#$&#123;RES&#125;表示将变量里面cpp都展开，效果和第一种等效</span>
<span class="token keyword">add_executable</span><span class="token punctuation">(</span>OpenGLStudy <span class="token punctuation">$&#123;</span>RES<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>第一种比较简单暴力，但是维护困难，不推荐。</p>
<p>第二种效果和第一种是等价的，但是由CMake自动完成，快捷容易维护。</p>
<h2 id="多文件夹编译"><a class="header-anchor" href="#多文件夹编译"></a>多文件夹编译</h2>
<p>开发中为了规范，不可能将所有的cpp文件都放在根目录下，因此我们会创建专门的文件夹存放对应的cpp文件。</p>
<p>如下图所示，我们将func.cpp和func.h放在了funcs文件夹下，里面存放的都是我们自己实现的函数，但是这样一来CMake就会找不到func.cpp文件而报错。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250412112710734.png" alt="image-20250412112710734" style="zoom: 67%;" />
<ol>
<li>首先我们先在funcs目录下新建一个CMakeLists.txt文件，编译时将该目录下的所有cpp文件编译为一个lib库</li>
</ol>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250412114046837.png" alt="image-20250412114046837" style="zoom:67%;" />
<pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">
<span class="token comment">#递归扫描当前目录下的所有cpp文件，将其存到FUNCS变量</span>
<span class="token comment">#GLOB_RECURSE表示递归查询；FUNCS表示变量名；./*.cpp表示该目录下的所有cpp文件</span>
<span class="token keyword">file</span><span class="token punctuation">(</span>GLOB_RECURSE FUNCS ./*.cpp<span class="token punctuation">)</span>

<span class="token comment">#将FUNCS变量中的所有cpp文件编译成名字为MyFuncLib的lib库</span>
<span class="token comment">#第一个参数是编译成的lib库的名字</span>
<span class="token keyword">add_library</span><span class="token punctuation">(</span>MyFuncLib <span class="token punctuation">$&#123;</span>FUNCS<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="2">
<li>接下来只需要在根目录下的CMakeLists.txt文件中将生成的lib库连接到可执行文件即可</li>
</ol>
<pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment">#设置该CMake项目的最低CMake版本要求</span>
<span class="token keyword">cmake_minimum_required</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">3.17</span><span class="token punctuation">)</span>
<span class="token comment">#设置项目名称</span>
<span class="token keyword">project</span><span class="token punctuation">(</span>00_Test<span class="token punctuation">)</span>
<span class="token comment">#设置项目所使用的c++版本为c++17</span>
<span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">CMAKE_CXX_STANDARD</span> <span class="token number">17</span><span class="token punctuation">)</span>

<span class="token comment">#---------------------------------------------------------------------新增</span>
<span class="token comment">#将funcs文件夹加入编译系统(会执行该文件夹下的CMakeLists.txt文件)</span>
<span class="token keyword">add_subdirectory</span><span class="token punctuation">(</span>funcs<span class="token punctuation">)</span>

<span class="token comment">#搜索当前目录下的所有cpp文件，加入到RES变量中</span>
<span class="token comment"># . 表示当前目录</span>
<span class="token keyword">aux_source_directory</span><span class="token punctuation">(</span>. RES<span class="token punctuation">)</span>

<span class="token comment">#指定要生成的可执行文件和其源文件，使用RES变量替换所有的源文件名称</span>
<span class="token comment">#$&#123;RES&#125;表示将变量里面cpp都展开，效果和第一种等效</span>
<span class="token keyword">add_executable</span><span class="token punctuation">(</span>OpenGLStudy <span class="token punctuation">$&#123;</span>RES<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>

<span class="token comment">#---------------------------------------------------------------------新增</span>
<span class="token comment">#将funcs目录下生成的连接库连接到我们最终生成的的可执行文件中</span>
<span class="token keyword">target_link_libraries</span><span class="token punctuation">(</span>OpenGLStudy MyFuncLib<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250412115430563.png" alt="image-20250412115430563" style="zoom:67%;" />
<p>最后可以在生成的out目录下找到func文件夹，里面就是生成的lib库。</p>
<h2 id="资源拷贝"><a class="header-anchor" href="#资源拷贝"></a>资源拷贝</h2>
<p>在进行OpenGL开发中，我们会经常使用各种各样的图片素材，或者其他第三方的dll库，我们开发中会在根目录下创建对应的文件夹存放我们的素材和第三方链接库。</p>
<p>但是这些文件要放在最后生成的可执行文件同目录下才可以被正确的使用，但是CMake生成的可执行文件在out目录里。所以我们必须手动的将这些文件夹复制到可执行文件的同目录下，不仅麻烦而且容易出错。</p>
<p>为了方便，我们可以使用CMake的资源拷贝功能，自动的将这些文件复制到可执行文件统计目录下，只需要每次添加新素材或者链接库时重新生成一下即可，CMake会自动拷贝这些文件。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250412115647966.png" alt="image-20250412115647966" style="zoom:67%;" />
<p>想实现这个功能，只需要在根目录下的CMakeLists.txt文件中添加这两句指令即可</p>
<pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment">#资源拷贝</span>
<span class="token comment">#给出需要拷贝的资源路径，将路径里的文件放到ASSETS变量中</span>
<span class="token keyword">file</span><span class="token punctuation">(</span>GLOB ASSETS <span class="token string">"./assets"</span> <span class="token string">"./thirdParty/test.dll"</span><span class="token punctuation">)</span>
<span class="token comment">#将ASSETS中的内容都拷贝到可执行文件所在目录下</span>
<span class="token comment">#CMAKE_BINARY_DIR指的是当前项目可执行文件的所在目录</span>
<span class="token keyword">file</span><span class="token punctuation">(</span>COPY <span class="token punctuation">$&#123;</span>ASSETS<span class="token punctuation">&#125;</span> DESTINATION <span class="token punctuation">$&#123;</span><span class="token variable">CMAKE_BINARY_DIR</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250412120621684.png" alt="image-20250412120621684" style="zoom:67%;" />
<p>编写完成后在重新生成即可看到所需要的文件已经被拷贝到了可执行文件所在目录。</p>
<h1 id="GLAD"><a class="header-anchor" href="#GLAD"></a>GLAD</h1>
<p>GLAD是一个 <strong>OpenGL 函数加载库</strong>，用于动态加载 OpenGL 驱动程序的函数指针。因为OpenGL是一个规范，只对各个函数进行了定义，并没有具体实现，具体的实现在各个显卡的驱动程序里。所以我们想使用某个函数，就必须从驱动程序中拿到对应的函数指针。我们可以手动指定加载哪些函数的函数指针，但是函数有那么多，我们不可能每一个都手动加载进来。</p>
<p>GLAD就帮我们完成了这一工程，只需要使用GLAD提供的几行代码，就可以完成对应函数指针的加载。</p>
<h2 id="下载"><a class="header-anchor" href="#下载"></a>下载</h2>
<p>访问<a target="_blank" rel="noopener" href="https://glad.dav1d.de/%E5%8D%B3%E5%8F%AF%E6%89%BE%E5%88%B0glad%E7%9A%84%E4%B8%8B%E8%BD%BD%E7%95%8C%E9%9D%A2%EF%BC%8C%E8%BF%9B%E5%85%A5%E5%90%8E%E6%88%91%E4%BB%AC%E4%BC%9A%E7%9C%8B%E5%88%B0%E5%A6%82%E4%B8%8B%E5%86%85%E5%AE%B9%EF%BC%9A">https://glad.dav1d.de/即可找到glad的下载界面，进入后我们会看到如下内容：</a></p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250412171016000.png" alt="image-20250412171016000" style="zoom: 50%;" />
<p>我们只需选择对应的选项，再点击右下角的生成按钮，即可获得对应的代码。获取的文件如下图所示，我们可以获得对应的头文件和源代码。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250412171141544.png" alt="image-20250412171141544" style="zoom:67%;" />
<h2 id="配置"><a class="header-anchor" href="#配置"></a>配置</h2>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250412171614442.png" alt="image-20250412171614442" style="zoom:67%;" />
<p>这里引入项目的方式和GLFW类似，直接将include里面的东西都复制到thirdParty目录下的include文件夹中，但由于直接提供了源码，为了方便起见，我们直接将源码glad.c放到和main.cpp同样的目录下。</p>
<pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment">#CMakeLists.txt只需要修改这一句即可，将glad.c连接到可执行文件中</span>
<span class="token keyword">add_executable</span><span class="token punctuation">(</span>OpenGLStudy <span class="token string">"main.cpp"</span> <span class="token string">"glad.c"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
&#x2F;&#x2F;gald的引入要在glfw上面，不然会报错
#include &lt;glad&#x2F;glad.h&gt;
#include &lt;GLFW&#x2F;glfw3.h&gt;

int main()
&#123;
	std::cout&lt;&lt;&quot;Hello World&quot;&lt;&lt;std::endl;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="使用"><a class="header-anchor" href="#使用"></a>使用</h2>
<p>使用gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)代码即可完成加载，如果加载成功会返回true，加载失败返回false。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if(gladLoadGLLoader((GLADloadproc)glfwGetProcAddress) )
&#123;
    std::cout&lt;&lt;&quot;加载成功&quot;&lt;&lt;std::endl;
&#125;
else
&#123;
    std::cout&lt;&lt;&quot;加载失败&quot;&lt;&lt;std::endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="GLFW"><a class="header-anchor" href="#GLFW"></a>GLFW</h1>
<h2 id="介绍"><a class="header-anchor" href="#介绍"></a>介绍</h2>
<p>如果我们想进行图形学的编程，必然需要创建一个窗口展示效果，但是不同的操作系统创建一个窗口的方式天差地别且还需要考虑与OpenGL等图形学API的兼容性。GLFW是一个轻量级的 <strong>跨平台窗口和输入管理库</strong>，专门为 OpenGL/Vulkan 设计。其只负责创建窗口、处理用户输入（键盘/鼠标/手柄）、控制上下文（OpenGL 渲染环境）等操作，相当于为我们创建了一个画布，我们可以使用OpenGL规定的API在该窗口绘制图形。</p>
<h2 id="配置-k2"><a class="header-anchor" href="#配置-k2"></a>配置</h2>
<p>到官网下载对应的库（下载源码自己编译或者下载已经编译好的库），这里使用官方提供的已经编译好的库。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250412162250191.png" alt="image-20250412162250191" style="zoom:67%;" />
<p>打开文件夹可以看到如上图所示的文件，include文件夹里存放的是我们要引用的头文件，下面lib开头的是各个版本的链接库，现在使用的是vs2019，所以选择lib-vc2019里面的库。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250412162410785.png" alt="image-20250412162410785" style="zoom:50%;" />
<p>进入之后可以看到上图所示的链接库，根据不同的方案使用不同的库。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250412162452050.png" alt="image-20250412162452050" style="zoom:50%;" />
<p>为了方便起见，直接使用第一种静态链接的方式。</p>
<p>照下图所示新建一个项目，thirdParty文件夹用来存放所有的第三方库，include文件夹存放头文件，lib文件夹存放对应的lib链接文件。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250412165203427.png" alt="image-20250412165203427" style="zoom:67%;" />
<p>下面就是设置引入路径和链接路径，引入路径就是在写代码时#include搜寻的目录，链接路径就是链接时搜寻的路径。</p>
<pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment">#设置该CMake项目的最低CMake版本要求</span>
<span class="token keyword">cmake_minimum_required</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">3.17</span><span class="token punctuation">)</span>
<span class="token comment">#设置项目名称</span>
<span class="token keyword">project</span><span class="token punctuation">(</span>01_Config<span class="token punctuation">)</span>
<span class="token comment">#设置项目所使用的c++版本为c++17</span>
<span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">CMAKE_CXX_STANDARD</span> <span class="token number">17</span><span class="token punctuation">)</span>

<span class="token comment">#将存放头文件的路径加入引入路径</span>
<span class="token comment">#如果不设置，在main.cpp只能#include "thirdParty/include/GLFW/glfw.h"引入</span>
<span class="token comment">#设置后，在main.cpp就可以#include "GLFW/glfw.h"引入</span>
<span class="token keyword">include_directories</span><span class="token punctuation">(</span>SYSTEM <span class="token punctuation">$&#123;</span><span class="token variable">CMAKE_SOURCE_DIR</span><span class="token punctuation">&#125;</span>/thirdParty/include<span class="token punctuation">)</span>

<span class="token comment">#将存放链接库的路径加入链接路径</span>
<span class="token keyword">link_directories</span><span class="token punctuation">(</span>SYSTEM <span class="token punctuation">$&#123;</span><span class="token variable">CMAKE_SOURCE_DIR</span><span class="token punctuation">&#125;</span>/thirdParty/lib<span class="token punctuation">)</span>

<span class="token keyword">add_executable</span><span class="token punctuation">(</span>OpenGLStudy <span class="token string">"main.cpp"</span><span class="token punctuation">)</span>
<span class="token comment">#CMake会根据我们设置的链接路径寻找该lib文件</span>
<span class="token keyword">target_link_libraries</span><span class="token punctuation">(</span>OpenGLStudy glfw3.lib<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样配置完成后我们就可以运行成功了。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include &quot;GLFW&#x2F;glfw3.h&quot;

int main()
&#123;
	std::cout&lt;&lt;&quot;Hello World&quot;&lt;&lt;std::endl;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="创建窗口"><a class="header-anchor" href="#创建窗口"></a>创建窗口</h2>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;glad&#x2F;glad.h&gt;&#x2F;&#x2F;这个头文件引用要在glfw头文件引用上方
#include &lt;GLFW&#x2F;glfw3.h&gt;
int main()
&#123;
    &#x2F;&#x2F;初始化
    glfwInit();
    &#x2F;&#x2F;设置主版本号、次版本号 用的是4.6版本，所以是4和6
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);
    &#x2F;&#x2F;设置OpenGL启用核心模式
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

    &#x2F;&#x2F;创建窗体对象
    GLFWwindow* window &#x3D; glfwCreateWindow(800, 600, &quot;OpenGL&quot;, NULL, NULL);
    &#x2F;&#x2F;设置OpenGL绘制的窗口
    glfwMakeContextCurrent(window);

    &#x2F;&#x2F;执行循环，窗口关闭时退出循环
    while (!glfwWindowShouldClose(window))
    &#123;
        &#x2F;&#x2F;执行
        glfwPollEvents();
    &#125;

    &#x2F;&#x2F;退出程序前的清理工作
    glfwTerminate();

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="事件响应"><a class="header-anchor" href="#事件响应"></a>事件响应</h2>
<p>和其他框架一样，OpenGL也有一套事件监听系统，但是事件的回调函数需要我们自己根据定义自己实现，并且手动将窗口和事件回调函数绑定。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include &lt;glad&#x2F;glad.h&gt;&#x2F;&#x2F;这个头文件引用要在glfw头文件引用上方
#include &lt;GLFW&#x2F;glfw3.h&gt;

&#x2F;&#x2F;定义一个窗口大小改变时的回调函数，与window窗口绑定
void frameBufferSizeCallBack(GLFWwindow* window, int width, int height)
&#123;
    std::cout &lt;&lt; width &lt;&lt; &quot; &quot; &lt;&lt; height &lt;&lt; std::endl;
&#125;

&#x2F;&#x2F;键盘事件监听的回调函数
&#x2F;*
*  key是按下或者松开的键盘按键。
*  scancode是一个系统平台相关的键位扫描码信息,终点关注第一个参数即可
*  action可以是GLFW_PRESS（按下键），GLFW_RELEASE（松开键），GLFW_REPEAT（连续输入模式）中的一个。
*  mods对应着辅助键的设置，例如shift和ctrl是否同时被按下。(参数值) ctrl&#x3D;2,shift&#x3D;1,shift+ctrl&#x3D;3,一个都没按&#x3D;0
*&#x2F;
void keyCallBack(GLFWwindow* window, int key, int scancode, int action, int mods)
&#123;
    std::cout &lt;&lt; key &lt;&lt; &quot; &quot; &lt;&lt; scancode&lt;&lt; &quot; &quot; &lt;&lt; action&lt;&lt; &quot; &quot; &lt;&lt; mods &lt;&lt; std::endl;

&#125;

int main()
&#123;
    &#x2F;&#x2F;初始化
    glfwInit();
    &#x2F;&#x2F;设置主版本号、次版本号 用的是4.6版本，所以是4和6
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);
    &#x2F;&#x2F;设置OpenGL启用核心模式
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

    &#x2F;&#x2F;创建窗体对象
    GLFWwindow* window &#x3D; glfwCreateWindow(800, 600, &quot;OpenGL&quot;, NULL, NULL);
    &#x2F;&#x2F;设置OpenGL绘制的窗口
    glfwMakeContextCurrent(window);

    &#x2F;&#x2F;设置监听窗口尺寸改变事件，并指定回调函数
    glfwSetFramebufferSizeCallback(window, frameBufferSizeCallBack);

    glfwSetKeyCallback(window, keyCallBack);

    &#x2F;&#x2F;执行循环，窗口关闭时退出循环
    while (!glfwWindowShouldClose(window))
    &#123;
        &#x2F;&#x2F;执行
        glfwPollEvents();
    &#125;

    &#x2F;&#x2F;退出程序前的清理工作
    glfwTerminate();

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>因为事件会有很多，所以只列举开发中常用的事件：窗口大小改变事件，键盘事件，鼠标事件等。</p>
<h3 id="窗口尺寸改变事件"><a class="header-anchor" href="#窗口尺寸改变事件"></a>窗口尺寸改变事件</h3>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;定义一个窗口大小改变时的回调函数，与window窗口绑定
&#x2F;*
	width参数是新窗口的宽度
	height参数是新窗口的高度
*&#x2F;
void frameBufferSizeCallBack(GLFWwindow* window, int width, int height)
&#123;
    std::cout &lt;&lt; width &lt;&lt; &quot; &quot; &lt;&lt; height &lt;&lt; std::endl;
&#125;

&#x2F;&#x2F;事件绑定
glfwSetFramebufferSizeCallback(window, frameBufferSizeCallBack);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="键盘事件"><a class="header-anchor" href="#键盘事件"></a>键盘事件</h3>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;键盘事件监听的回调函数
&#x2F;*
*  key是按下或者松开的键盘按键。
*  scancode是一个系统平台相关的键位扫描码信息,不需要特别关注这个参数
*  action可以是当前的动作GLFW_PRESS（按下键），GLFW_RELEASE（松开键），GLFW_REPEAT（连续输入模式）。
*  mods对应着辅助键的设置，例如shift和ctrl是否同时被按下。(参数值) ctrl&#x3D;2,shift&#x3D;1,shift+ctrl&#x3D;3,一个都没按&#x3D;0
*&#x2F;
void keyCallBack(GLFWwindow* window, int key, int scancode, int action, int mods)
&#123;
    if(key&#x3D;&#x3D;GLFW_KEY_W)std::cout&lt;&lt;&quot;触发了W键&quot;;
    if(action&#x3D;&#x3D;GLFW_PRESS)std::cout&lt;&lt;&quot;按下了某个键&quot;;
    if(action&#x3D;&#x3D;GLFW_MOD_SHIFT)std::cout&lt;&lt;&quot;按下了shift键&quot;;
    std::cout &lt;&lt; key &lt;&lt; &quot; &quot; &lt;&lt; scancode&lt;&lt; &quot; &quot; &lt;&lt; action&lt;&lt; &quot; &quot; &lt;&lt; mods &lt;&lt; std::endl;

&#125;

glfwSetKeyCallback(window, keyCallBack);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在OpenGL中，用<strong>GLFW_KEY_XX</strong>格式的常量定义好了各种按键的值，各种模式、触发类型都有对应的常量表示，判断时直接使用即可。</p>
<h3 id="鼠标事件"><a class="header-anchor" href="#鼠标事件"></a>鼠标事件</h3>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;--------------------------------------鼠标按键事件
&#x2F;*
*  button是按下或者松开的键盘按键。GLFW_MOUSE_BUTTON_LEFT（鼠标左键），GLFW_MOUSE_BUTTON_RIGHT(鼠标右键)。
*  action可以是当前的动作GLFW_PRESS（按下键），GLFW_RELEASE（松开键）。
*  mods对应着辅助键的设置，例如shift和ctrl是否同时被按下。(参数值) ctrl&#x3D;2,shift&#x3D;1,shift+ctrl&#x3D;3,一个都没按为0
*&#x2F;
void MouseButtonCallback(GLFWwindow* window, int button, int action, int mods)
&#123;
     if (action &#x3D;&#x3D; GLFW_PRESS)
    &#123;
        if (button &#x3D;&#x3D; GLFW_MOUSE_BUTTON_LEFT)std::cout &lt;&lt; &quot;鼠标左键&quot; &lt;&lt; std::endl;
        std::cout &lt;&lt; mods &lt;&lt; std::endl;
    &#125;
&#125;
&#x2F;&#x2F;--------------------------------------鼠标滚轮事件
&#x2F;*
*  xoffset是滚轮水平滚动的值，但是大部分鼠标只有垂直滚动，因此该值大部分情况为0
*  yoffset是滚轮垂直滚动的值，向上(远离用户方向)滚动值为1，向下(靠近用户方向)滚动值为-1
*&#x2F;
void MouseScrollCallback(GLFWwindow* window, double xoffset, double yoffset)
&#123;
    std::cout &lt;&lt; xOffset &lt;&lt; &quot; &quot; &lt;&lt; yOffset &lt;&lt; std::endl;
&#125;



glfwSetMouseButtonCallback(window, MouseButtonCallback);
glfwSetScrollCallback(window, MouseScrollCallback);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="GLAD-k2"><a class="header-anchor" href="#GLAD-k2"></a>GLAD</h1>
<p>我们下载的GLFW文件中只有<strong>glfw.h</strong>头文件和<strong>lib</strong>静态链接库文件供我们使用。但是OpenGL也只是一种规范，具体的实现由显卡厂商决定，所以我们必须要拿到驱动程序中厂家实现好的OpenGL的函数。glad可以帮助我们更好的<strong>从驱动程序加载这些函数</strong>，供我们使用。成功引入glad后，我们可以用以下代码加载函数。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include &lt;glad&#x2F;glad.h&gt;&#x2F;&#x2F;这个头文件引用要在glfw头文件引用上方
#include &lt;GLFW&#x2F;glfw3.h&gt;
&#x2F;&#x2F;定义一个窗口大小改变时的回调函数，与window窗口绑定
void frameBufferSizeCallBack(GLFWwindow* window, int width, int height)
&#123;
    std::cout &lt;&lt; width &lt;&lt; &quot; &quot; &lt;&lt; height &lt;&lt; std::endl;
    &#x2F;&#x2F;改变窗口大小时同时改变视口大小
    glViewport(0, 0, width, height);
&#125;
&#x2F;&#x2F;键盘事件监听的回调函数
void keyCallBack(GLFWwindow* window, int key, int scancode, int action, int mods)
&#123;
    std::cout &lt;&lt; key &lt;&lt; &quot; &quot; &lt;&lt; scancode &lt;&lt; &quot; &quot; &lt;&lt; action &lt;&lt; &quot; &quot; &lt;&lt; mods &lt;&lt; std::endl;
&#125;

int main()
&#123;
    &#x2F;&#x2F;初始化
    glfwInit();
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    GLFWwindow* window &#x3D; glfwCreateWindow(800, 600, &quot;OpenGL&quot;, NULL, NULL);
    glfwMakeContextCurrent(window);
    glfwSetFramebufferSizeCallback(window, frameBufferSizeCallBack);
    glfwSetKeyCallback(window, keyCallBack);

    &#x2F;&#x2F;用glad加载显卡中具体实现的OpenGL的函数
    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123;
        &#x2F;&#x2F;如果加载出错
        std::cout &lt;&lt; &quot;加载出错&quot; &lt;&lt; std::endl;
        return -1;
    &#125;
	
    &#x2F;&#x2F;如果加载成功就可以正常使用这些函数
    &#x2F;&#x2F;设置视口位置和大小
    glViewport(0, 0, 800, 600);
    &#x2F;&#x2F;设置窗口清理画布使用的颜色
    glClearColor(0.8f, 0.81f, 0.83f, 0.8f);

    &#x2F;&#x2F;执行循环，窗口关闭时退出循环
    while (!glfwWindowShouldClose(window))
    &#123;
        &#x2F;&#x2F;执行一系列事件操作,不写的话无法处理各种事件
        glfwPollEvents();

        &#x2F;&#x2F;清理画布(清理上一帧的画面，开始绘制下一帧)
        glClear(GL_COLOR_BUFFER_BIT);
        &#x2F;&#x2F;渲染工作
        
        &#x2F;&#x2F;切换双缓存(shi&#39;jue)
        glfwSwapBuffers(window);
    &#125;

    &#x2F;&#x2F;退出程序前的清理工作
    glfwTerminate();

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="stb-image"><a class="header-anchor" href="#stb-image"></a>stb_image</h1>
<h2 id="介绍-k2"><a class="header-anchor" href="#介绍-k2"></a>介绍</h2>
<p>为了在后面的学习中使用纹理，我们首先需要能够读取各种格式的图片。而stb_image就是一个提供各种格式图片数据读取的第三方库，我们只需要下载后引入对应的头文件，简单配置一下就能开始使用。</p>
<h2 id="配置-k3"><a class="header-anchor" href="#配置-k3"></a>配置</h2>
<p>下载源文件后，可以发现每个功能都是一个单独的.h文件，所以我们只需要#include引入对应功能的.h文件即可。阅读文档可知我们读取图片需要引入stb_image.h头文件，并且要在引入前定义一个宏<strong>STB_IMAGE_IMPLEMENTATION</strong>才能正常使用。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define STB_IMAGE_IMPLEMENTATION
#include &lt;stb_image&#x2F;stb_image.h&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>**注意：<strong>图片的原点是左上角，但是在opengl中原点为左下角，所以在读取图片前需要翻转图片的y轴。在stb_image中，只需要在读取图片前使用</strong>stbi_set_flip_vertically_on_load(true)**即可实现y轴翻转。</p>
<h2 id="读取图片"><a class="header-anchor" href="#读取图片"></a>读取图片</h2>
<p>读取图片只需调用该函数即可，其中返回值为<strong>stbi_uc</strong>*，其实就是stb_image封装的**unsigned char ***数据类型。</p>
<p>其中最后一个参数是我们期待的拿到的图片通道格式，比如我们的图片只有rgb三个通道，但是实际需要rgba四个通道的数据，那么stbimage就可以完成格式之间的转化，共有四个选项可以选择。</p>
<p>STBI_grey ，STBI_grey_alpha，STBI_rgb，STBI_rgb_alpha。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250704224424533.png" alt="image-20250704224424533" style="zoom:50%;" />
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int width, height, channel;
&#x2F;&#x2F;读取图片
&#x2F;&#x2F;翻转y轴，使图片原点和opengl原点一致
stbi_set_flip_vertically_on_load(true);
&#x2F;&#x2F;读取纹理图片的数据到内存
unsigned char* data &#x3D; stbi_load(&quot;Assets&#x2F;Textures&#x2F;a.png&quot;, &amp;width, &amp;height, &amp;channel, STBI_rgb_alpha);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="GLM"><a class="header-anchor" href="#GLM"></a>GLM</h1>
<h2 id="介绍-k3"><a class="header-anchor" href="#介绍-k3"></a>介绍</h2>
<p>GLM（OpenGL Mathematics）是基于OpenGL着色语言（GLSL）规范的图形软件的头文件C ++数学库。</p>
<p>GLM提供的类和函数使用与GLSL相同的命名约定和功能设计和实现，因此了解GLSL就可以C ++中使用GLM。</p>
<p>OpenGL没有内建矩阵运算方法，经常使用第三方库GLM来进行矩阵运算。GLM作为一个header only库，只要包括了相应的头文件就可以使用它提供的类和函数。</p>
<h2 id="常用数据类型"><a class="header-anchor" href="#常用数据类型"></a>常用数据类型</h2>
<ul>
<li>vec2 二维向量</li>
<li>vec3 三维向量</li>
<li>vec4 四维向量</li>
<li>quat 单精度四元数</li>
<li>dquat 双精度四元数</li>
<li>mat2 二阶矩阵(2x2方阵)</li>
<li>mat3 三阶矩阵(3x3方阵)</li>
<li>mat4 四阶方阵(4x4方阵)</li>
</ul>
<h2 id="头文件"><a class="header-anchor" href="#头文件"></a>头文件</h2>
<p>GLM对于矩阵数据类型的定义位于glm/glm.hpp头文件中。</p>
<p>生成变换矩阵的函数位于glm/gtc/matrix_transform.hpp头文件中。</p>
<p>将数组转换成矩阵的函数位于头文件glm/gtc/type_ptr.hpp中（glm::value_ptr函数在里面）。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;正常情况下只需要引入这些头文件即可正常使用
#include &lt;glm&#x2F;glm.hpp&gt;
#include &lt;glm&#x2F;gtc&#x2F;matrix_transform.hpp&gt;
#include &lt;glm&#x2F;gtc&#x2F;type_ptr.hpp&gt;
&#x2F;&#x2F;这个头文件重载了 &lt;&lt; 符号，可以用cout直接输出向量或者矩阵变量
#define GLM_ENABLE_EXPERIMENTAL&#x2F;&#x2F;不加这个宏无法使用io.hpp头文件
#include &lt;glm&#x2F;gtx&#x2F;io.hpp&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="常用函数"><a class="header-anchor" href="#常用函数"></a>常用函数</h2>
<ol>
<li>默认构造函数(没有初始化的向量或矩阵无法正常使用)</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;glm1.0.0版本后必须显示初始化矩阵或向量
glm::mat4 m;&#x2F;&#x2F;旧版本会默认创建全0矩阵，新版本则不会，必须显示初始化

&#x2F;&#x2F;创建一个主对角线元素全为1的4阶方阵(单位矩阵)
glm::mat4 m4(1.0f);
&#x2F;&#x2F;创建元素全为零的零矩阵
glm::mat4 m4(0.0f);
&#x2F;&#x2F;使用数值赋值形式创建矩阵
glm::mat4 m &#x3D; &#123;
    1.0, 1.0, 1.0, 1.0,&#x2F;&#x2F;第一列
    2.0, 2.0, 2.0, 2.0,&#x2F;&#x2F;第二列
    3.0, 3.0, 3.0, 3.0,&#x2F;&#x2F;第三列
    4.0, 4.0, 4.0, 4.0&#x2F;&#x2F;第四列
&#125;;
&#x2F;&#x2F;可以用访问二维数值的形式m[i][j]对矩阵元素进行修改和访问
&#x2F;&#x2F;注意，glm中m[i][j]表示第i列，第j行
m[1][1] &#x3D; 10

&#x2F;&#x2F;创建一个元素全为1的2维向量
glm::vec2(1.0f);
&#x2F;&#x2F;使用数值赋值形式创建向量
glm::vec4 m &#x3D; &#123;
    1.0, 2.0, 3.0, 4.0
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="2">
<li>向量运算</li>
</ol>
<table>
<thead>
<tr>
<th>函数/操作符</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code></td>
<td>分量加减乘除</td>
<td><code>vec3 a = b + c;</code></td>
</tr>
<tr>
<td><code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code></td>
<td>分量赋值运算</td>
<td><code>a += b;</code></td>
</tr>
<tr>
<td><code>==</code>, <code>!=</code></td>
<td>向量相等比较</td>
<td><code>if (a == b) { ... }</code></td>
</tr>
<tr>
<td><code>glm::dot(a, b)</code></td>
<td>点积</td>
<td><code>float d = dot(a, b);</code></td>
</tr>
<tr>
<td><code>glm::cross(a, b)</code></td>
<td>叉积（仅 <code>vec3</code>）</td>
<td><code>vec3 c = cross(a, b);</code></td>
</tr>
<tr>
<td><code>glm::length(v)</code></td>
<td>向量长度</td>
<td><code>float len = length(v);</code></td>
</tr>
<tr>
<td><code>glm::distance(a, b)</code></td>
<td>两点间距离</td>
<td><code>float d = distance(a, b);</code></td>
</tr>
<tr>
<td><code>glm::normalize(v)</code></td>
<td>单位化向量</td>
<td><code>vec3 norm = normalize(v);</code></td>
</tr>
<tr>
<td><code>glm::reflect(I, N)</code></td>
<td>反射向量</td>
<td><code>vec3 R = reflect(I, N);</code></td>
</tr>
<tr>
<td><code>glm::refract(I, N, eta)</code></td>
<td>折射向量</td>
<td><code>vec3 T = refract(I, N, eta);</code></td>
</tr>
<tr>
<td><code>glm::abs(v)</code></td>
<td>各分量取绝对值</td>
<td><code>vec3 a = abs(v);</code></td>
</tr>
<tr>
<td><code>glm::floor(v)</code>, <code>glm::ceil(v)</code>, <code>glm::round(v)</code></td>
<td>分量取整</td>
<td><code>vec3 f = floor(v);</code></td>
</tr>
<tr>
<td><code>glm::clamp(v, min, max)</code></td>
<td>分量限制范围</td>
<td><code>vec3 c = clamp(v, 0.0f, 1.0f);</code></td>
</tr>
<tr>
<td><code>glm::mix(a, b, t)</code></td>
<td>线性插值（<code>t ∈ [0,1]</code>）</td>
<td><code>vec3 m = mix(a, b, 0.5f);</code></td>
</tr>
<tr>
<td><code>glm::max(a, b)</code>, <code>glm::min(a, b)</code></td>
<td>分量最大值/最小值</td>
<td><code>vec3 mx = max(a, b);</code></td>
</tr>
<tr>
<td>3. 矩阵运算</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>函数/操作符</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>+</code>, <code>-</code>, <code>*</code></td>
<td>矩阵加减乘</td>
<td><code>mat4 A = B + C;</code></td>
</tr>
<tr>
<td><code>*</code> (矩阵×向量)</td>
<td>矩阵与向量乘法</td>
<td><code>vec4 v = M * vec4(pos, 1.0f);</code></td>
</tr>
<tr>
<td><code>glm::transpose(M)</code></td>
<td>转置矩阵</td>
<td><code>mat4 T = transpose(M);</code></td>
</tr>
<tr>
<td><code>glm::inverse(M)</code></td>
<td>逆矩阵（需可逆）</td>
<td><code>mat4 invM = inverse(M);</code></td>
</tr>
<tr>
<td><code>glm::determinant(M)</code></td>
<td>行列式</td>
<td><code>float det = determinant(M);</code></td>
</tr>
<tr>
<td><code>glm::outerProduct(a, b)</code></td>
<td>外积（生成矩阵）</td>
<td><code>mat3 M = outerProduct(a, b);</code></td>
</tr>
<tr>
<td><code>glm::identity&lt;mat4&gt;()</code></td>
<td>单位矩阵</td>
<td><code>mat4 I = identity&lt;mat4&gt;();</code></td>
</tr>
<tr>
<td><code>glm::diagonalMatrix(v)</code></td>
<td>对角矩阵</td>
<td><code>mat4 D = diagonalMatrix(vec4(1.0f));</code></td>
</tr>
<tr>
<td><code>glm::translate(M, offset)</code></td>
<td>平移矩阵</td>
<td><code>mat4 T = translate(M, vec3(1.0f, 0.0f, 0.0f));</code></td>
</tr>
<tr>
<td><code>glm::rotate(M, angle, axis)</code></td>
<td>旋转矩阵</td>
<td><code>mat4 R = rotate(M, radians(45.0f), vec3(0.0f, 0.0f, 1.0f));</code></td>
</tr>
<tr>
<td><code>glm::scale(M, factors)</code></td>
<td>缩放矩阵</td>
<td><code>mat4 S = scale(M, vec3(2.0f));</code></td>
</tr>
<tr>
<td><code>glm::ortho(left, right, bottom, top, near, far)</code></td>
<td>正交投影矩阵</td>
<td><code>mat4 P = ortho(-1.0f, 1.0f, -1.0f, 1.0f, 0.1f, 100.0f);</code></td>
</tr>
<tr>
<td><code>glm::perspective(fov, aspect, near, far)</code></td>
<td>透视投影矩阵</td>
<td><code>mat4 P = perspective(radians(60.0f), 16.0f/9.0f, 0.1f, 100.0f);</code></td>
</tr>
<tr>
<td><code>glm::lookAt(eye, center, up)</code></td>
<td>视图矩阵（摄像机）</td>
<td><code>mat4 V = lookAt(eye, target, vec3(0.0f, 1.0f, 0.0f));</code></td>
</tr>
<tr>
<td>4. 矩阵变换</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>glm::translate(M, offset)</code></td>
<td>创建平移矩阵</td>
<td><code>mat4 T = translate(M, vec3(1.0f, 0.0f, 0.0f));</code></td>
</tr>
<tr>
<td><code>glm::rotate(M, angle, axis)</code></td>
<td>创建旋转矩阵</td>
<td><code>mat4 R = rotate(M, radians(45.0f), vec3(0.0f, 0.0f, 1.0f));</code></td>
</tr>
<tr>
<td><code>glm::scale(M, factors)</code></td>
<td>创建缩放矩阵</td>
<td><code>mat4 S = scale(M, vec3(2.0f));</code></td>
</tr>
<tr>
<td><code>glm::ortho(left, right, bottom, top, near, far)</code></td>
<td>创建正交投影矩阵</td>
<td><code>mat4 P = ortho(-1.0f, 1.0f, -1.0f, 1.0f, 0.1f, 100.0f);</code></td>
</tr>
<tr>
<td><code>glm::perspective(fov, aspect, near, far)</code></td>
<td>创建透视投影矩阵</td>
<td><code>mat4 P = perspective(radians(60.0f), 16.0f/9.0f, 0.1f, 100.0f);</code></td>
</tr>
<tr>
<td><code>glm::lookAt(eye, center, up)</code></td>
<td>创建视图矩阵（摄像机）</td>
<td><code>mat4 V = lookAt(eye, target, vec3(0.0f, 1.0f, 0.0f));</code></td>
</tr>
</tbody>
</table>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;创建一个单位矩阵
glm::mat4 m4(1.0f);

&#x2F;&#x2F;平移向量，沿x轴平移1个单位距离，沿y轴平移2个单位距离，沿z轴平移3个单位距离
glm::vec3 offset(1.0f, 2.0f, 3.0f);
&#x2F;&#x2F;平移矩阵。将这个平移矩阵传到shader中和每个顶点相乘，就会实现将图形平移的效果
glm::mat4 model &#x3D; glm::translate(m4, offset);


&#x2F;&#x2F;旋转轴(三维图形绕这个轴旋转),绕y轴旋转
glm::vec3 axis(0.0f, 1.0f, 0.0f);
&#x2F;&#x2F;旋转矩阵。实现将图形绕y轴逆时针旋转45度的效果(rotate函数里接收的是弧度)
glm::mat4 model &#x3D; glm::rotate(m4, glm::raidans(45.0f), axis);


&#x2F;&#x2F;图形在各个坐标轴的缩放系数
glm::vec3 multi(2.0);
&#x2F;&#x2F;缩放矩阵。每个轴都放大两倍
glm::mat4 model &#x3D; glm::scale(m4, multi);


&#x2F;&#x2F;正交投影矩阵。前四个参数分别是视口的左、右、上、下坐标。第五和第六个参数则定义了近平面和远平面的距离。
glm::ortho(float left, float right, float bottom, float top, float zNear, float zFar);


&#x2F;&#x2F;透视投影矩阵。第一个参数为视锥上下面之间的夹角，第二个参数为视口宽高比，第三、四个参数分别为近平面和远平面的深度。
glm::perspective(float fovy, float aspect, float zNear, float zFar);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="5">
<li>常用</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;将角度值转为弧度值。传入角度，输出弧度，
&#x2F;&#x2F;rotate函数中需要输入弧度值
float paiAngle &#x3D; glm::radians(45.0f);

&#x2F;&#x2F;获取矩阵或者向量的指针，搭配glUniformMatrix4fv可以将矩阵的值传递到shader中
float* val &#x3D; glm::value_ptr(m);

&#x2F;&#x2F;第一个参数表示uniform变量的位置，第二个参数表示传递几个矩阵数据，第三个参数表示传入的矩阵是否需要转置，第四个参数就是获取到的矩阵的指针
&#x2F;&#x2F;由于glm和glsl中矩阵都是列优先存储的，所以我们无需进行转置操作
glUniformMatrix4fv(location, 1, GL_FALSE, val);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="ImGUI"><a class="header-anchor" href="#ImGUI"></a>ImGUI</h1>
<h2 id="介绍-k4"><a class="header-anchor" href="#介绍-k4"></a>介绍</h2>
<p>ImGUI（Immediate Mode GUI）是一种 <strong>即时模式</strong> 的图形用户界面设计方法，与传统的 <strong>保留模式 GUI</strong>（如 Qt、WinForms）不同。它的核心特点是：</p>
<ul>
<li><strong>无持久化状态</strong>：每一帧都重新绘制整个 UI，而不是维护控件状态。</li>
<li><strong>轻量级</strong>：适合嵌入式、游戏、工具开发。</li>
<li><strong>快速原型设计</strong>：适合调试界面、编辑器插件等。</li>
</ul>
<p>ImGUI非常适合简单场景中绘制轻量级UI空间，如果是较为复杂的场景或者大型软件，还要使用QT进行开发。</p>
<h2 id="配置-k4"><a class="header-anchor" href="#配置-k4"></a>配置</h2>
<p>imgui是一个开源的库，可以直接从网上下载源码，加入到自己的项目中直接引用即可。</p>
<p>除了需要引入根目录下这些<strong>必须的文件</strong>，还需要根据项目所使用的库引入不同的<strong>兼容性文件</strong>，这部分文件是imgui为了兼容其他第三方库而实现的。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250717171621962.png" alt="image-20250717171621962" style="zoom:60%;" />
<p>一个简单的方法就是可以进入examples文件夹查看示例工程，将示例示例工程中引入的文件引入自己项目中。这里我们用的是glfw+opengl新版本，就选择对应的文件夹打开里面的项目文件。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250717172008182.png" alt="image-20250717172008182" style="zoom:60%;" />
<p>然后按照示例项目里面的引入文件引入到自己的项目即可。（示例项目里面的文件都引入之后，也有可能运行报错，这时候只需要根据报错信息引入对应的文件即可）</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250717172125492.png" alt="image-20250717172125492" style="zoom:67%;" />
<h2 id="使用-k2"><a class="header-anchor" href="#使用-k2"></a>使用</h2>
<p>在使用时，一共可分为三个步骤：</p>
<ol>
<li><strong>初始化</strong>imgui</li>
<li><strong>渲染</strong>imgui的ui</li>
<li><strong>退出程序前清理</strong>imgui</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;imgui&#x2F;imgui.h&quot;
#include &quot;imgui&#x2F;imgui_impl_glfw.h&quot;
#include &quot;imgui&#x2F;imgui_impl_opengl3.h&quot;

&#x2F;&#x2F;初始化
void initIMGUI()
&#123;
    ImGui::CreateContext();&#x2F;&#x2F;创建imgui上下文
    ImGui::StyleColorsDark();&#x2F;&#x2F;设置ui界面的主题
    &#x2F;&#x2F;ImGui::StyleColorsLight();

    &#x2F;&#x2F;将imgui与glfw的窗口和对应版本的opengl进行绑定
    ImGui_ImplGlfw_InitForOpenGL(app.getWindow(), true);
    ImGui_ImplOpenGL3_Init(&quot;#version 460&quot;);
&#125;

&#x2F;&#x2F;渲染
void renderIMGUI()
&#123;
    &#x2F;&#x2F;开启一帧的渲染
    ImGui_ImplOpenGL3_NewFrame();
    ImGui_ImplGlfw_NewFrame();
    ImGui::NewFrame();

    &#x2F;&#x2F;设置控件
    ImGui::Begin(&quot;hello world&quot;);
    ImGui::End();

    ImGui::Begin(&quot;hello c++&quot;);
    ImGui::End();

    &#x2F;&#x2F;执行渲染
    ImGui::Render();
    int display_w, display_h;
    glfwGetFramebufferSize(app.getWindow(), &amp;display_w, &amp;display_h);
    glViewport(0, 0, display_w, display_h);
    ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());
&#125;

&#x2F;&#x2F;推出前清理
ImGui_ImplOpenGL3_Shutdown();
ImGui_ImplGlfw_Shutdown();
ImGui::DestroyContext();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="各种控件"><a class="header-anchor" href="#各种控件"></a>各种控件</h2>
<h3 id="窗体区域"><a class="header-anchor" href="#窗体区域"></a>窗体区域</h3>
<p><strong>Begin</strong>函数会在屏幕上创建一块窗体区域，里面的参数是该窗体的名称。任何在Begin和End之间的控件都会在同一个窗体区域内，并且里面的<strong>控件</strong>都会<strong>随着窗体一起移动</strong>。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ImGui::Begin(&quot;hello world&quot;);
ImGui::Button(&quot;world&quot;, ImVec2(60, 40));
ImGui::End();

ImGui::Begin(&quot;hello c++&quot;);
ImGui::Button(&quot;c++&quot;, ImVec2(40, 40));
ImGui::End();
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到调用了两次Begin和End函数且两个窗体<strong>名称不同</strong>，创建了两个不同的窗体，并且各自里面的组件也都在各自的窗体里。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250717172954002.png" alt="image-20250717172954002" style="zoom:60%;" />
<p>imgui区分窗体的<strong>标识</strong>为<strong>创建的名称</strong>，也就是Begin函数传入的参数。如果两个窗体的<strong>名称一样</strong>，那么就会被认作是<strong>一个窗体</strong>。如下的代码所示，两段代码的运行结果是一样的，都是两个按钮一起出现在了&quot;hello world&quot;窗体里。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;下面两段代码运行结果一样
&#x2F;&#x2F;两个窗体名称一样
ImGui::Begin(&quot;hello world&quot;);
ImGui::Button(&quot;world&quot;, ImVec2(60, 40));
ImGui::End();

ImGui::Begin(&quot;hello world&quot;);
ImGui::Button(&quot;c++&quot;, ImVec2(40, 40));
ImGui::End();

&#x2F;&#x2F;一个单独窗体
ImGui::Begin(&quot;hello world&quot;);
ImGui::Button(&quot;world&quot;, ImVec2(60, 40));
ImGui::Button(&quot;c++&quot;, ImVec2(40, 40));
ImGui::End();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250717173401824.png" alt="image-20250717173401824" style="zoom:67%;" />
<h1 id="Assimp"><a class="header-anchor" href="#Assimp"></a>Assimp</h1>
<h2 id="介绍-k5"><a class="header-anchor" href="#介绍-k5"></a>介绍</h2>
<p><strong>Assimp</strong>（<strong>Open Asset Import Library</strong>）是一个开源的 <strong>3D 模型导入库</strong>，用于加载和处理多种 3D 文件格式。它广泛应用于游戏开发、计算机图形学、3D 建模工具等领域，能够解析模型数据（如网格、材质、动画等），并转换为统一的内部数据结构，方便在程序中使用。</p>
<p>Assimp 可以读取多种常见的 3D 模型文件格式，包括：</p>
<ul>
<li><strong>静态模型格式</strong>：OBJ, STL, PLY, FBX, DAE (Collada), 3DS, Blender (.blend)</li>
<li><strong>动画模型格式</strong>：FBX, DAE, GLTF/GLB, X (DirectX)</li>
<li><strong>游戏引擎格式</strong>：Unreal Engine (.ase), Quake (.mdl, .md2, .md3)</li>
</ul>
<p>Assimp 解析 3D 文件后，可以提取以下数据：</p>
<ul>
<li><strong>网格（Mesh）</strong>：顶点、法线、UV 坐标、三角形面片</li>
<li><strong>材质（Material）</strong>：漫反射/镜面反射/环境光颜色、纹理路径（漫反射贴图、法线贴图等）</li>
<li><strong>骨骼动画（Bone Animation）</strong>：骨骼层次结构、关键帧动画</li>
<li><strong>场景结构（Scene Graph）</strong>：节点层次结构（如父子关系）</li>
</ul>
<p>具体使用流程如下：我们使用Assimp库导入一个3D模型文件，Assimp会解析文件数据并将其转换为Assimp规定的数据结构，我们拿到Assimp的数据结构后要根据自己的需求转换为自己可以使用的数据结构。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250717221457130.png" alt="image-20250717221457130" style="zoom:50%;" />
<h2 id="Assimp数据结构"><a class="header-anchor" href="#Assimp数据结构"></a>Assimp数据结构</h2>
<p>当使用Assimp导入一个模型的时候，它通常会将整个模型加载进一个<strong>场景</strong>(Scene)对象，它会包含导入的模型/场景中的所有数据。Assimp会将场景载入为一系列的节点(Node)，每个节点包含了场景对象中所储存数据的索引，每个节点都可以有任意数量的子节点。Assimp数据结构的（简化）模型如下：</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/assimp_structure.png" alt="img" style="zoom: 80%;" />
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250717222711536.png" alt="image-20250717222711536" style="zoom:50%;" />
<ul>
<li>
<p>aiScene中包含了该模型文件中的所有物体。</p>
</li>
<li>
<p>aiScene.mMeshes数组包含了该场景中所有mesh的信息。</p>
</li>
<li>
<p>aiMesh是存放mesh信息的，包含顶点信息(mVertices)、法线信息(mNormals)、uv坐标(mTextureCoords)、顶点索引(mFaces)、材质索引(mMaterialIndex)。其中材质可以根据材质索引去aiScene.mMaterials中获得指定的material。</p>
</li>
<li>
<p>aiMesh.aiFace表示Mesh中一个三角形面元，aiFace.mIndices存放的是该三角形的顶点索引。</p>
</li>
<li>
<p>aiScene.mMaterials数组包含了场景中所有material的信息。</p>
</li>
<li>
<p>RootNode是场景的根节点，可以把每个Node当做一个空的Object（空Object当中父物体挂载其他mesh）。Node.mMeshes数组表示挂载在当前Node的物体的mesh，里面存放的是索引值，可以使用这个索引值去aiScene.mMeshes数组中获得指定的mesh；Node.mChildren表示挂载在当前Node的子Node。</p>
</li>
</ul>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250717223840702.png" alt="image-20250717223840702" style="zoom:50%;" />
<h2 id="使用-k3"><a class="header-anchor" href="#使用-k3"></a>使用</h2>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;assimp&#x2F;Importer.hpp&gt;
#include &lt;assimp&#x2F;scene.h&gt;
#include &lt;assimp&#x2F;postprocess.h&gt;

&#x2F;&#x2F;1.读取模型必须要使用Assimp提供的导入器importer
Assimp::Importer importer;

&#x2F;&#x2F;2.调用导入器的ReadFile函数即可获取到Assimp读取模型文件的aiScene
const aiScene* scene &#x3D; importer.ReadFile(path, aiProcess_GenNormals | aiProcess_Triangulate);

&#x2F;&#x2F;3.检查是否读取成功
if (!scene || scene-&gt;mFlags &amp; AI_SCENE_FLAGS_INCOMPLETE || !scene-&gt;mRootNode)
&#123;
    cout &lt;&lt; &quot;ERROR::ASSIMP::&quot; &lt;&lt; import.GetErrorString() &lt;&lt; endl;
    return;
&#125;

&#x2F;&#x2F;4.如果正确读取模型文件，则可以用拿到的aiScene获取里面的数据
&#x2F;&#x2F;...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><em><em>importer.ReadFile(const char</em> path,  unsigned int flags)</em>*</p>
<p>第一个参数<strong>path</strong>，是模型的读取路径；</p>
<p>第二个参数<strong>flags</strong>，是读取模型的一些设置。<strong>aiProcess_Triangulate</strong>设置如果模型不是（全部）由三角形组成，它需要将模型所有的图元形状变换为三角形；<strong>aiProcess_GenNormals</strong>设置如果模型不包含法向量的话，就为每个顶点创建法线。</p>
<h1 id="OpenGL初级"><a class="header-anchor" href="#OpenGL初级"></a>OpenGL初级</h1>
<h2 id="初始程序"><a class="header-anchor" href="#初始程序"></a>初始程序</h2>
<p>使用glfw创建窗口并使用glad加载函数成功后，我们先使用OpenGL API编写一个最基础程序。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;glad&#x2F;glad.h&gt;
#include &lt;GLFW&#x2F;glfw3.h&gt;

void init()
&#123;
    &#x2F;&#x2F;初始化
	glfwInit();
	&#x2F;&#x2F;配置
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);
	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    &#x2F;&#x2F;创建窗体对象
    GLFWwindow* window &#x3D; glfwCreateWindow(800, 600, &quot;OpenGLStudy&quot;, NULL, NULL);
    &#x2F;&#x2F;设置OpenGL绘制的窗口
    glfwMakeContextCurrent(window);
    &#x2F;&#x2F;加载当前所有版本的opengl的函数实现
    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
    &#123;
        std::cout &lt;&lt; &quot;加载函数失败&quot; &lt;&lt; std::endl;
        return -1;
    &#125;
&#125;

int main()
&#123;
    &#x2F;&#x2F;初始化操作
	init();


    &#x2F;&#x2F;设置视口大小
    glViewport(0, 0, 800, 600);
    &#x2F;&#x2F;设置画布清理颜色(背景颜色)
    glClearColor(0.5f, 0.5f, 0.5f, 1.0f);

    &#x2F;&#x2F;执行循环，窗口关闭时退出循环
    while (!glfwWindowShouldClose(window))
    &#123;
        &#x2F;&#x2F;处理事件队列
        glfwPollEvents();

        &#x2F;&#x2F;每一帧清理上一帧画布的内容
        glClear(GL_COLOR_BUFFER_BIT);
        &#x2F;&#x2F;绘制其他内容(渲染内容)
        &#x2F;&#x2F;...

        &#x2F;&#x2F;切换双缓存
        glfwSwapBuffers(window);
    &#125;

    &#x2F;&#x2F;退出程序前的清理工作
    glfwTerminate();

    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="OpenGL函数错误处理"><a class="header-anchor" href="#OpenGL函数错误处理"></a>OpenGL函数错误处理</h2>
<p>OpenGL是一个相对稳定的状态机，不会因为我们给函数传入错误的参数而随便崩溃，这也就导致了我们在开发中更难观察到代码中的错误。</p>
<p>以下面的代码为例：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;glad&#x2F;glad.h&gt;
#include &lt;GLFW&#x2F;glfw3.h&gt;

int main()
&#123;
    &#x2F;&#x2F;假设所有初始化操作都在这个函数里
    init();

    &#x2F;&#x2F;设置视口大小
    glViewport(0, 0, 800, 600);
    &#x2F;&#x2F;设置画布清理颜色(背景颜色)
    glClearColor(0.5f, 0.5f, 0.5f, 1.0f);


    &#x2F;&#x2F;执行循环，窗口关闭时退出循环
    while (!glfwWindowShouldClose(window))
    &#123;
        &#x2F;&#x2F;处理事件
        glfwPollEvents();

        &#x2F;&#x2F;每一帧清理上一帧画布的内容
        &#x2F;&#x2F;正确写法是 glClear(GL_COLOR_BUFFER_BIT);
        glClear(-1);
        &#x2F;&#x2F;绘制其他内容
        

        &#x2F;&#x2F;切换双缓存
        glfwSwapBuffers(window);
    &#125;

    &#x2F;&#x2F;退出程序前的清理工作
    glfwTerminate();

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250415191049509.png" alt="image-20250415191049509" style="zoom: 50%;" />
<p>可以看到代码中的glCLear(-1)明显传入了一个错误的参数，但是我们的程序还是能正常运行，没有什么报错信息。而且前面设置的清除颜色是灰色的，运行时确实黑色。对于一个大型项目来说，出现这样一个错误是非常难维护的，所有我们在开发时就必须处理好程序的报错问题。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;glGetError()可以获得离自己最近的一个报错情况的错误代码
&#x2F;&#x2F;GLenum是glad定义的枚举类型，本质就是int
GLenum errCode &#x3D; glGetError();

&#x2F;&#x2F;1
glClear(-1);
&#x2F;&#x2F;2
glClear(GL_COLOR_BUFFER_BIT);
&#x2F;&#x2F;3
glClear(-1);
&#x2F;&#x2F;因为只会获得距离自己最近的错误情况，所以会得到第3句的错误代码
GLenum errCode &#x3D; glGetError();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250415194926089.png" alt="image-20250415194926089" style="zoom: 80%;" />
<p>如上图所示，每一个错误代码都有一个与之对应的宏，获得错误代码后可以比较这些宏从而找到错误原因。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250415200448883.png" alt="image-20250415200448883" style="zoom:67%;" />
<p>如上图所示，在项目中新建一个wrapper文件夹，用来存放我们自己写的包装好的工具，创建一个CMakeLists.txt文件，配置方法和CMake的多文件夹编译一节一样。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;------------------------------------------------------checkError.h文件
#pragma once
&#x2F;&#x2F;该宏只在DEBUG模式下起检查错误的作用
#ifdef DEBUG
&#x2F;&#x2F;定义GL_CALL宏，简化代码操作
#define GL_CALL(func) func;checkError();

#else

#define GL_CALL(func) func;

#endif

void checkError();

&#x2F;&#x2F;------------------------------------------------------checkError.cpp文件
#include &quot;checkError.h&quot;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;glad&#x2F;glad.h&gt;

void checkError()
&#123;
	GLenum errCode &#x3D; glGetError();
	std::string errStr &#x3D; &quot;&quot;;
	if (errCode)
	&#123;
		switch (errCode)
		&#123;
		case GL_INVALID_ENUM:errStr &#x3D; &quot;INVALID_ENUM&quot;; break;
		case GL_INVALID_VALUE:errStr &#x3D; &quot;INVALID_VALUE&quot;; break;
		case GL_INVALID_OPERATION:errStr &#x3D; &quot;INVALID_OPERATION&quot;; break;
		case GL_OUT_OF_MEMORY:errStr &#x3D; &quot;OUT_OF_MEMORY&quot;; break;
		default:errStr &#x3D; &quot;UNKNOWN_ERROR&quot;; break;
		&#125;
		&#x2F;&#x2F;出现错误就输出错误原因并终止运行
		std::cout &lt;&lt; errStr &lt;&lt; std::endl;
		assert(false);
	&#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于每次调用checkError()函数都会消耗计算资源，每一行代码都调用一次会大大影响性能，所以使用条件编译的方式只在开发中使用（CMake中使用add_definitions(-DDEBUG)指令定义该宏表面开发模式）。我们的宏和检错函数定义好之后，在其他源文件引入之后，可以直接使用。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;每一条语句被GL_CALL包裹后会先只执行里面的语句，随后就执行我们的checkError函数，可以随时检查出错误所在
GL_CALL(glClear(GL_COLOR_BUFFER_BIT));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="NDC-Normalized-Device-Coordinates"><a class="header-anchor" href="#NDC-Normalized-Device-Coordinates"></a>NDC(Normalized Device Coordinates)</h2>
<p>把屏幕坐标划分为[-1,1]的范围，0表示中点位置，-1是左边界或下边界，1是右边界或上边界。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240204164555512.png" alt="image-20240204164555512" style="zoom: 50%;" />
<p>使用这种坐标的好出是在屏幕中显示的图像会随着屏幕的大小进行相应比例的缩放，最终我们在OpenGL中给出的坐标也都是NDC中的坐标。</p>
<h2 id="VBO-Vertex-Buffer-Objects"><a class="header-anchor" href="#VBO-Vertex-Buffer-Objects"></a>VBO(Vertex Buffer Objects)</h2>
<h3 id="创建"><a class="header-anchor" href="#创建"></a>创建</h3>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240204165607889.png" alt="image-20240204165607889" style="zoom:67%;" />
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240204165839066.png" alt="image-20240204165839066" style="zoom:67%;" />
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">   &#x2F;&#x2F;在此过程中并未开辟显存
&#x2F;&#x2F;创建1个VBO
   GLuint n &#x3D; 1;
   GLuint vbo1&#x3D;0;
&#x2F;&#x2F;创建1个vbo时(传入这个变量的地址)
   glGenBuffers(n, &amp;vbo1);
   &#x2F;&#x2F;删除1个VBO
   glDeleteBuffers(n, &amp;vbo1);

   &#x2F;&#x2F;创建多个VBO
   n &#x3D; 3;
   GLuint vbo2[] &#x3D; &#123;0,0,0&#125;;
   glGenBuffers(n, vbo2);
   &#x2F;&#x2F;删除多个VBO
   glDeleteBuffers(n, vbo2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="绑定和数据填入"><a class="header-anchor" href="#绑定和数据填入"></a>绑定和数据填入</h3>
<p>使用glGenBuffers函数创建vbo时并不会开辟显存空间，<strong>填入数据</strong>时会真正的<strong>开辟显存空间</strong>。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250417172543086.png" alt="image-20250417172543086" style="zoom:33%;" />
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240204173148411.png" alt="image-20240204173148411" style="zoom: 50%;" />
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;准备数据
float vertices[] &#x3D; &#123;
    0.5f,0.3f,0,
    -0.5f,-0.3f,0,
    0.1f,0.1f,0,
&#125;;
&#x2F;&#x2F;创建VBO
GLuint vbo;
glGenBuffers(1, &amp;vbo);
&#x2F;&#x2F;将创建的vbo绑定到OpenGL状态机的当前vbo插槽位置
&#x2F;&#x2F;GL_ARRAY_BUFFER:表示OpenGL中当前vbo的插槽
glBindBuffer(GL_ARRAY_BUFFER, vbo);
&#x2F;&#x2F;传输数据(第二个参数是指传入数据的字节大小)，将数据填入到当前绑定的vbo中
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

glDeleteBuffers(1, &amp;vbo);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="存储多属性数据"><a class="header-anchor" href="#存储多属性数据"></a>存储多属性数据</h3>
<p>对于一个三角形来说，其包含的数据不止有三个顶点的坐标信息，还有类似颜色、深度等的其他信息，也就是说明一个点是多属性数据，下面介绍两种vbo中存储多属性的策略。</p>
<h4 id="single-buffer"><a class="header-anchor" href="#single-buffer"></a>single buffer</h4>
<p>该策略是为每一个属性分配一个vbo对象存储，即创建多个vbo对象，每个vbo对象只负责记录所有点的某一个属性的信息。如下图所示，我们可以创建两个vbo对象，分别存储点的坐标信息和颜色信息。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240204174550438.png" alt="image-20240204174550438" style="zoom: 50%;" />
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void prepaerSingleBuffer() &#123;
    float pos[] &#x3D; &#123;
    0.5f,0.3f,0,
    -0.5f,-0.3f,0,
    0.1f,0.1f,0,
    &#125;;
    float colors[] &#x3D; &#123;
    1.0f,1.0f,1.0f,
    1.0f,1.0f,1.0f,
    1.0f,1.0f,1.0f,
    &#125;;
    &#x2F;&#x2F;创建两个vbo，分别存储顶点的坐标信息和顶点的颜色信息
    GLuint posVbo &#x3D; 0, colorVbo &#x3D; 0;
    &#x2F;&#x2F;创建
    glGenBuffers(1, &amp;posVbo);
    &#x2F;&#x2F;绑定
    glBindBuffer(GL_ARRAY_BUFFER, posVbo);
    &#x2F;&#x2F;传输数据
    glBufferData(GL_ARRAY_BUFFER, sizeof(pos), pos, GL_STATIC_DRAW);

    &#x2F;&#x2F;创建
    glGenBuffers(1, &amp;colorVbo);
    &#x2F;&#x2F;绑定
    glBindBuffer(GL_ARRAY_BUFFER, colorVbo);
    &#x2F;&#x2F;传输数据
    glBufferData(GL_ARRAY_BUFFER, sizeof(colors), colors, GL_STATIC_DRAW);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="interleaved-buffer"><a class="header-anchor" href="#interleaved-buffer"></a>interleaved buffer</h4>
<p>该策略是将所有的信息放到一个数组里，只创建一个vbo对象存储。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240204192206098.png" alt="image-20240204192206098" style="zoom:67%;" />
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void prepaerInterleavedBuffer() &#123;
    float vertices[] &#x3D; &#123;
        0.5f,0.3f,0,1.0f,1.0f,1.0f,
        -0.5f,0.2f,0,1.0f,1.0f,1.0f,
        -0.3f,0.2f,0,1.0f,1.0f,1.0f,
    &#125;;

    GLuint vbo &#x3D; 0;
    glGenBuffers(1, &amp;vbo);
    glBindBuffer(GL_ARRAY_BUFFER, vbo);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="VAO-Vertex-Array-Object"><a class="header-anchor" href="#VAO-Vertex-Array-Object"></a>VAO(Vertex Array Object)</h2>
<p>VAO（Vertex Array Object）：顶点数组对象，用于存储一个Mesh网格所有的<strong>顶点属性描述信息</strong>。</p>
<p>我们可以通过把信息存储在VBO中，然后VBO再传送到显存中，显卡得到了这些数据后只是一堆数据，并不知道如何操作。而VAO就是用来<strong>描述</strong>VBO中数据的存放的，比如数据的类型，几个数据为一组之类的信息，让显卡可以根据我们的定义存取数据。</p>
<p>在OpenGL程序中，<strong>VBO</strong>可能会有多个，但<strong>VAO</strong>只有一个。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">   &#x2F;&#x2F;左边三列是坐标信息，右边三列是颜色信息
float vertices[] &#x3D; &#123;
        0.5f,0.3f,0,   1.0f,1.0f,1.0f,
       -0.5f,0.2f,0,   1.0f,1.0f,1.0f,
       -0.3f,0.2f,0,   1.0f,1.0f,1.0f
   &#125;;
&#x2F;&#x2F;显卡接收到的数据就是一堆展开的数字，需要使用VAO描述这些数据
&#x2F;&#x2F;几个数字为一组，数据是什么类型，存储在几号VBO中等等
0.5f,0.3f,0,1.0f,1.0f,1.0f,  -0.5f,0.2f,0,1.0f,1.0f,1.0f,   -0.3f,0.2f,0,1.0f,1.0f,1.0f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240204194640180.png" alt="image-20240204194640180" style="zoom:67%;" />
<p>下面就具体说明如何使用代码绑定VAO。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240204194816949.png" alt="image-20240204194816949" style="zoom: 50%;" />
<p>当前OpenGL中绑定的是哪一个VBO，调用这个函数设置的VAO就是对哪一个VBO的信息的描述。要想设置特定的VBO的信息描述前，一定要记得先绑定对应的VBO。</p>
<p>对于<strong>stride</strong>属性，是说明一个顶点的所有属性数据有多长。例如vbo中存储了3个顶点的坐标信息(float类型)，那么stride=3* sizeof(float)=<strong>12字节</strong>；vbo中存储了3个顶点的坐标信息和颜色信息(float类型)，那么stride=6*sizeof(float)=<strong>24字节</strong>。</p>
<p>对于<strong>pointer</strong>属性，是说明该属性数据在顶点所有属性数据内的偏移量。例如vbo中存储了3个顶点的坐标信息和颜色信息(float类型)，对于坐标信息，偏移量为0；但是对于颜色信息，由于每个顶点的数据中，颜色信息在坐标信息之后，所以会有一个偏移量，即pointer = 3*sizeof(float) = 12字节的便宜。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240204195042028.png" alt="image-20240204195042028" style="zoom:50%;" />
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void prepaerVAO() &#123;
    &#x2F;&#x2F;准备数据
    &#x2F;&#x2F;对应这样的数据假设每一个顶点有6个数据，分别是坐标信息和颜色信息，所以stride的值为6*sizeof(float)&#x3D;24字节
    float vertices[] &#x3D; &#123;
    0.5f,0.3f,0,1.0f,1.0f,1.0f,
    -0.5f,0.2f,0,1.0f,1.0f,1.0f,
    -0.3f,0.2f,0,1.0f,1.0f,1.0f,
    &#125;;
    &#x2F;&#x2F;创建一个VBO并绑定
    GLuint vbo &#x3D; 0;
    glGenBuffers(1, &amp;vbo);
    glBindBuffer(GL_ARRAY_BUFFER, vbo);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

    &#x2F;&#x2F;创建一个VAO
    GLuint vao &#x3D; 0;
    glGenVertexArrays(1, &amp;vao);

    &#x2F;&#x2F;绑定VAO
    glBindVertexArray(vao);

    &#x2F;&#x2F;设置VAO中的坐标属性
    glEnableVertexAttribArray(0);&#x2F;&#x2F;选择要设置在VAO中哪个位置，每个属性放在VAO中的不同位置
    &#x2F;&#x2F;            VAO中的位置，该属性数据个数，数据类型，是否归一化，步长，偏移量
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * (sizeof(float)), (void*)0);

    &#x2F;&#x2F;设置VAO中的颜色属性,为了能正确找到颜色数据，需要设置偏移量
    glEnableVertexAttribArray(1);
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3 * sizeof(float)));

    &#x2F;&#x2F;解绑VAO
    glBindVertexArray(0);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面是具体的练习题：</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240204203237223.png" alt="image-20240204203237223" style="zoom:67%;" />
<h2 id="EBO-Element-Buffer-Object"><a class="header-anchor" href="#EBO-Element-Buffer-Object"></a>EBO(Element Buffer Object)</h2>
<p>之前我们用VBO存储数据进行绘制多个点时，如果有两个三角形共用了一个或两个点，我们只能按顺序写6个点才能绘制成功，我们可以发现VBO的方式这些点<strong>不能复用</strong>，这就造成了<strong>空间的浪费</strong>。我们可以把用到的点的信息还是都放在VBO中，但是通过索引值获取到要绘制的点，在点的数量很多的情况下可以大大的减少空间的浪费，于是便有了EBO。</p>
<p><strong>EBO：用于存储顶点绘制顺序索引号的GPU显存区域。</strong></p>
<p>我们通过将EBO与VAO绑定，在绘制点的时候根据EBO中的索引序号再向VBO中获取到点。EBO的创建与VBO的也类似，只是模式参数不同。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250511210537587.png" alt="image-20250511210537587" style="zoom: 67%;" />
<pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl">   <span class="token comment">//创建VBO</span>
   GLuint vbo<span class="token punctuation">;</span>
   <span class="token function">glGenBuffers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>vbo<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> vbo<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token function">glBufferData</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>vertices<span class="token punctuation">)</span><span class="token punctuation">,</span> vertices<span class="token punctuation">,</span> GL_STATIC_DRAW<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//创建EBO</span>
   GLuint ebo<span class="token punctuation">;</span>
   <span class="token function">glGenBuffers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ebo<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ELEMENT_ARRAY_BUFFER<span class="token punctuation">,</span> ebo<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//只有第一个参数与VBO创建时不同</span>
   <span class="token function">glBufferData</span><span class="token punctuation">(</span>GL_ELEMENT_ARRAY_BUFFER<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>idxs<span class="token punctuation">)</span><span class="token punctuation">,</span> idxs<span class="token punctuation">,</span> GL_STATIC_DRAW<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//只有第一个参数与VBO创建时不同</span>


   <span class="token comment">//使用EBO实现绘制</span>
   <span class="token comment">//选择绘制程序</span>
   <span class="token function">glUseProgram</span><span class="token punctuation">(</span>program<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token comment">//绑定vao</span>
   <span class="token function">glBindVertexArray</span><span class="token punctuation">(</span>vao<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token comment">//使用ebo时用这个方法绘制，参数依次：绘制图形，绘制图形的点数，索引数据类型，偏移量（一般写0）</span>
   <span class="token function">glDrawElements</span><span class="token punctuation">(</span>GL_TRIANGLES<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> GL_UNSIGNED_INT<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面就是完整的使用EBO进行绘制的代码</p>
<p>使用EBO参与绘制后，绘制命令就不能再使用<strong>glDrawArrays</strong>了，要使用<strong>glDrawElements</strong>才可以。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250511211731635.png" alt="image-20250511211731635" style="zoom: 50%;" />
<pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token comment">//声明全局变量</span>
GLuint vao<span class="token punctuation">,</span> program<span class="token punctuation">;</span>

<span class="token comment">//准备工作</span>
<span class="token keyword">void</span> <span class="token function">prepaerEBO</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">float</span> vertices<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
        <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span><span class="token number">0.0f</span><span class="token punctuation">,</span>
         <span class="token number">0.5f</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span><span class="token number">0.0f</span><span class="token punctuation">,</span>
         <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.5f</span><span class="token punctuation">,</span><span class="token number">0.0f</span><span class="token punctuation">,</span>
         <span class="token number">1.0f</span><span class="token punctuation">,</span><span class="token number">1.0f</span><span class="token punctuation">,</span><span class="token number">0.0f</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> idxs<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
        <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span>
        <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token comment">//创建VBO</span>
    GLuint vbo<span class="token punctuation">;</span>
    <span class="token function">glGenBuffers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>vbo<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> vbo<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glBufferData</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>vertices<span class="token punctuation">)</span><span class="token punctuation">,</span> vertices<span class="token punctuation">,</span> GL_STATIC_DRAW<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//创建EBO</span>
    GLuint ebo<span class="token punctuation">;</span>
    <span class="token function">glGenBuffers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ebo<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ELEMENT_ARRAY_BUFFER<span class="token punctuation">,</span> ebo<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glBufferData</span><span class="token punctuation">(</span>GL_ELEMENT_ARRAY_BUFFER<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>idxs<span class="token punctuation">)</span><span class="token punctuation">,</span> idxs<span class="token punctuation">,</span> GL_STATIC_DRAW<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//创建VAO</span>
    <span class="token function">glGenVertexArrays</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>vao<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glBindVertexArray</span><span class="token punctuation">(</span>vao<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//绑定属性信息</span>
    <span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> vbo<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glEnableVertexAttribArray</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glVertexAttribPointer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">,</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//绑定ebo到vao中(先绑定vao后再执行绑定ebo的代码即可完成绑定)</span>
    <span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ELEMENT_ARRAY_BUFFER<span class="token punctuation">,</span> ebo<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//解绑vao</span>
    <span class="token function">glBindVertexArray</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>


 <span class="token comment">//-------------------------------------------渲染操作----------------------------------</span>

<span class="token keyword">void</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">//清理画布</span>
    <span class="token function">glClear</span><span class="token punctuation">(</span>GL_COLOR_BUFFER_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//绘制</span>
    <span class="token comment">//选择绘制程序</span>
    <span class="token function">glUseProgram</span><span class="token punctuation">(</span>program<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//绑定vao</span>
    <span class="token function">glBindVertexArray</span><span class="token punctuation">(</span>vao<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//使用ebo时用这个方法绘制，参数依次：绘制图形，绘制索引数组中几个点，索引的数据类型，偏移量（一般写0）</span>
    <span class="token function">glDrawElements</span><span class="token punctuation">(</span>GL_TRIANGLES<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> GL_UNSIGNED_INT<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//解除绑定</span>
    <span class="token function">glBindVertexArray</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="shader-着色器程序-入门"><a class="header-anchor" href="#shader-着色器程序-入门"></a>shader(着色器程序)入门</h2>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240205161612785.png" alt="image-20240205161612785" style="zoom:67%;" />
<h3 id="GLSL-Graphic-Library-Shader-Language"><a class="header-anchor" href="#GLSL-Graphic-Library-Shader-Language"></a>GLSL(Graphic Library Shader Language)</h3>
<p>着色器的编写要使用专门的语言来完成，这里使用的是GLSL，这是一种类C语言写成的，包含一些对向量和矩阵的操作的有用的特性。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240205161939253.png" alt="image-20240205161939253" style="zoom:67%;" />
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250704180609917.png" alt="image-20250704180609917" style="zoom: 50%;" />
<h4 id="简单数据类型"><a class="header-anchor" href="#简单数据类型"></a>简单数据类型</h4>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240206145951400.png" alt="image-20240206145951400" style="zoom: 50%;" />
<p>在三维向量中，前三个数字可用xyz或者rgb分别表示。</p>
<p>在四维向量中，前四个数字可用xyzw或者rgba分别表示。</p>
<pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token keyword">vec3</span> color<span class="token operator">=</span><span class="token keyword">vec3</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">,</span><span class="token number">1.0</span><span class="token punctuation">,</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//每一个分量可以单独拿出来</span>
color<span class="token punctuation">.</span>x <span class="token operator">==</span> color<span class="token punctuation">.</span>r<span class="token punctuation">;</span>
color<span class="token punctuation">.</span>y <span class="token operator">==</span> color<span class="token punctuation">.</span>g<span class="token punctuation">;</span>
color<span class="token punctuation">.</span>z <span class="token operator">==</span> color<span class="token punctuation">.</span>b<span class="token punctuation">;</span>
<span class="token comment">//也可以直接取多个指定分量</span>
<span class="token keyword">vec3</span> temp1<span class="token operator">=</span>color<span class="token punctuation">.</span>xxx<span class="token punctuation">;</span>
<span class="token keyword">vec3</span> temp2<span class="token operator">=</span>color<span class="token punctuation">.</span>xyz<span class="token punctuation">;</span>
<span class="token keyword">vec3</span> temp3<span class="token operator">=</span>temp1<span class="token punctuation">.</span>xxx <span class="token operator">+</span> temp2<span class="token punctuation">.</span>yyy<span class="token punctuation">;</span><span class="token comment">//可以用这种方式直接计算再赋值</span>
<span class="token comment">//四维向量操作方法同上</span>
<span class="token comment">//也可以只取一部分分量，对应变量的个数会被取出来，可用于初始化向量</span>
<span class="token keyword">vec4</span> v1<span class="token operator">=</span><span class="token keyword">vec4</span><span class="token punctuation">(</span>temp1<span class="token punctuation">,</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">vec4</span> v2<span class="token operator">=</span><span class="token keyword">vec4</span><span class="token punctuation">(</span>temp1<span class="token punctuation">.</span>xyz<span class="token punctuation">,</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">vec4</span> v3<span class="token operator">=</span><span class="token keyword">vec4</span><span class="token punctuation">(</span>temp1<span class="token punctuation">.</span>xy<span class="token punctuation">,</span><span class="token number">1.0</span><span class="token punctuation">,</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="Uniform"><a class="header-anchor" href="#Uniform"></a>Uniform</h4>
<p>Uniform变量可以被当前Shader运行的所有运算单元<strong>共享</strong>的变量，Uniform变量是<strong>全局</strong>的，因此每一个变量必须<strong>唯一</strong>。Uniform变量可以被着色器程序的任意着色器在任意阶段访问，无论把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。</p>
<p>由于uniform是全局变量，我们可以在任何着色器中定义它们，定义后可以在任何着色器中使用它们。</p>
<p>下面的代码就是利用<strong>Uniform</strong>根据时间用正弦函数设置三角形的颜色周期性变化。</p>
<pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token comment">//在vs中定义一个uniform变量表示颜色,并将该值交给color变量输出到fs中</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">460</span> core</span></span>
<span class="token keyword">layout</span><span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token keyword">vec3</span> aPosition<span class="token punctuation">;</span>
<span class="token keyword">layout</span><span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token keyword">vec3</span> aColor<span class="token punctuation">;</span>
<span class="token comment">//最终输出的颜色向量</span>
<span class="token keyword">out</span> <span class="token keyword">vec3</span> color<span class="token punctuation">;</span>
<span class="token comment">//外部通过代码设置uniform变量的值</span>
<span class="token keyword">uniform</span> <span class="token keyword">vec3</span> uColor<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	gl_Position <span class="token operator">=</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span>aPosition<span class="token punctuation">.</span>x<span class="token punctuation">,</span> aPosition<span class="token punctuation">.</span>y<span class="token punctuation">,</span> aPosition<span class="token punctuation">.</span>z<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	color<span class="token operator">=</span>uColor<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    
<span class="token comment">//在fs中获取到颜色并输出颜色</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">460</span> </span></span>
<span class="token keyword">out</span> <span class="token keyword">vec4</span> fColor<span class="token punctuation">;</span>
<span class="token keyword">in</span> <span class="token keyword">vec3</span> color<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	fColor <span class="token operator">=</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span>color<span class="token punctuation">,</span><span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>首先要使用<strong>glGetUniformLocation(program, name)<strong>方法获取着色器程序中指定名称的Uniform变量的位置（是一个无符号整型，可以理解为每个Uniform变量的唯一id值）。获取到的变量位置</strong>location</strong>的取值范围为<strong>0</strong>到<strong>GL_MAX_UNIFORM_LOCATIONS - 1</strong>。</p>
<p>然后再使用glUniform3f(location, x, y, z)设置对应Uniform变量的值。其中函数名最后两个字符中的<strong>3表示3维向量</strong>、<strong>f表示float类型的数据</strong>，类似的glUniform4i就表示设置4维int类型的Uniform变量的数值，第一个参数表示Uniform变量的位置编号，后面的数据就是按照顺序设置该变量的分量值。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;在Shader类中新增函数修改uniform变量的值
void Shader::setUniform3Float(const char* name, float x, float y, float z) &#123;
    &#x2F;&#x2F;在当前program中查找名字为name的uniform变量的位置
    GLint vertexColorLocation &#x3D; glGetUniformLocation(mProgram, name);
    &#x2F;&#x2F;调用方法修改对应位置的uniform变量的值
    glUniform3f(vertexColorLocation, x, y, z);
&#125;



&#x2F;&#x2F;------------------------------------------
&#x2F;&#x2F;在渲染的循环了调用
GLfloat timeValue &#x3D; glfwGetTime();&#x2F;&#x2F;获取时间
GLfloat greenValue &#x3D; (sin(timeValue)+1)&#x2F;2;&#x2F;&#x2F;根据实际的正弦值计算颜色
shader-&gt;setUniform3Float(&quot;uColor&quot;, 0.0f, greenValue, 0.0f);&#x2F;&#x2F;设置uniform变量的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到三角形的颜色会随时间进行周期性的变化。</p>
<p>​                        <img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240206161838490.png" alt="image-20240206161838490" style="zoom:50%;" /><img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240206161857442.png" alt="image-20240206161857442" style="zoom:50%;" /></p>
<h3 id="Vertex-Shader"><a class="header-anchor" href="#Vertex-Shader"></a>Vertex Shader</h3>
<p>顶点着色器(Vertex Shader)是几个可编程着色器中的一个。如果我们打算做渲染的话，现代OpenGL需要我们至少设置一个顶点和一个片段着色器。着色器的编写需要用到上面的GLSL来实现，下面是一个简单的实现。顶点着色器是将三维世界的左边转化成NDC坐标的，这里我们默认输入的数据就是NDC坐标，所以不用做任何处理，就实现了一个最简单的顶点着色器。</p>
<pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token comment">//opengl版本为4.6核心模式</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">460</span> core</span></span>

<span class="token comment">//layout(location=0)表明的是想接收的属性数据的描述信息所在VAO中的位置 在VAO中对应0号位置</span>
<span class="token comment">//in表示该数据是接收外部的输入数据(就是我们代码中vbo中指向的那些数据)</span>
<span class="token keyword">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token keyword">vec3</span> position<span class="token punctuation">;</span>
<span class="token comment">//如果我们的vbo中还存储了颜色属性，该属性描述信息绑定在了VAO的1号位置，就要写location = 1</span>
<span class="token keyword">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token keyword">vec3</span> color<span class="token punctuation">;</span>
<span class="token comment">//out表示该shader向后输出的变量</span>
<span class="token keyword">out</span> <span class="token keyword">vec3</span> mColor<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">//gl_Position是GLSL内置变量，是每个顶点的最终位置(变量名只能是这个)，我们可以将各个点处理后再赋值给这个变量，该变量向后续阶段传递坐标信息，以此可以实现图形的变换操作</span>
    <span class="token comment">//gl_Position的坐标为NDC坐标，因为我们代码中使用的就是NDC坐标，所以可以直接赋值</span>
    gl_Position <span class="token operator">=</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span>position<span class="token punctuation">.</span>x<span class="token punctuation">,</span> position<span class="token punctuation">.</span>y<span class="token punctuation">,</span> position<span class="token punctuation">.</span>z<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//输出变量赋值后向后传递</span>
    mColor <span class="token operator">=</span> color<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="Fragment-Shader"><a class="header-anchor" href="#Fragment-Shader"></a>Fragment Shader</h3>
<p>片段着色器(Fragment Shader)是第二个也是最后一个我们打算创建的用于渲染三角形的着色器。片段着色器计算每个像素最后的<strong>颜色输出</strong>。</p>
<p>GLSL老版本中的FS有内置变量gl_FragColor表示输出，但在新版已经被废弃。</p>
<p><strong>gl_FragCoord</strong>是 OpenGL <strong>片段着色器（Fragment Shader）</strong> 的内置变量，只能在FragmentShader中使用。</p>
<p><code>gl_FragCoord</code> 是一个 <code>vec4</code> 类型的变量，表示当前片段的 <strong>窗口空间坐标</strong>，包含以下信息：</p>
<ul>
<li><strong><code>gl_FragCoord.x</code></strong>：当前片段的 x 坐标（像素位置，范围 <code>[0, viewportWidth]</code>）</li>
<li><strong><code>gl_FragCoord.y</code></strong>：当前片段的 y 坐标（像素位置，范围 <code>[0, viewportHeight]</code>）</li>
<li><strong><code>gl_FragCoord.z</code></strong>：当前片段的深度值（范围 <code>[0, 1]</code>，可用于深度测试）</li>
<li><strong><code>gl_FragCoord.w</code></strong>：<code>1 / gl_Position.w</code>（透视校正插值用）</li>
</ul>
<pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">460</span> core</span></span>
<span class="token comment">//颜色用四维向量表示，分别是r,g,b,a的值， 表示每个像素最后的颜色输出</span>
<span class="token comment">//out表示该shader输出的变量</span>
<span class="token keyword">out</span> <span class="token keyword">vec4</span> color<span class="token punctuation">;</span>
<span class="token comment">//接收Vertex Shader中out的输出变量mColor(变量名要和vs中out的变量名一样)</span>
<span class="token keyword">in</span> <span class="token keyword">vec3</span> mColor<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">//vec4表示的是rgba，在shader中颜色三个通道的值范围都是[0,1]</span>
    color <span class="token operator">=</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span>mColor<span class="token punctuation">.</span>x<span class="token punctuation">,</span> mColor<span class="token punctuation">.</span>y<span class="token punctuation">,</span> mColor<span class="token punctuation">.</span>z<span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250704155644324.png" alt="image-20250704155644324" style="zoom:50%;" />
<h3 id="shader的编译"><a class="header-anchor" href="#shader的编译"></a>shader的编译</h3>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240205164023977.png" alt="image-20240205164023977" style="zoom:67%;" />
<p>因为shader的编写是使用一门语言完成的，我们需要在OpenGL中手动编译和链接。</p>
<pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token keyword">void</span> <span class="token function">prepaerShader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">//shader源代码</span>
    <span class="token keyword">const</span> char<span class="token operator">*</span> vertexShaderSource <span class="token operator">=</span>
        <span class="token string">"#version 460 core\n"</span>
        <span class="token string">"layout(location = 0) in vec3 position;\n"</span>
        <span class="token string">"void main()\n"</span>
        <span class="token string">"&#123;\n"</span>
        <span class="token string">"gl_Position = vec4(position.x, position.y, position.z, 1.0);\n"</span>
        <span class="token string">"&#125;\n\0"</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> char<span class="token operator">*</span> fragmentShaderSource <span class="token operator">=</span>
        <span class="token string">"#version 460 core\n"</span>
        <span class="token string">"out vec4 color;\n"</span>
        <span class="token string">"void main()\n"</span>
        <span class="token string">"&#123;\n"</span>
        <span class="token string">"color = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n"</span>
        <span class="token string">"&#125;\n\0"</span><span class="token punctuation">;</span>
    <span class="token comment">// 1. 创建一个对应的shader，并返回对应编号</span>
    GLuint vertexShader<span class="token punctuation">,</span>fragmentShader<span class="token punctuation">;</span>
    vertexShader <span class="token operator">=</span> <span class="token function">glCreateShader</span><span class="token punctuation">(</span>GL_VERTEX_SHADER<span class="token punctuation">)</span><span class="token punctuation">;</span>
    fragmentShader <span class="token operator">=</span><span class="token function">glCreateShader</span><span class="token punctuation">(</span>GL_FRAGMENT_SHADER<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 2. 给对应的shader注入源代码</span>
    <span class="token comment">//参数分别为:对应shader编号，源码字符串的个数，存储字符串的二维数组，存储每一个字符串长度的数组</span>
    <span class="token function">glShaderSource</span><span class="token punctuation">(</span>vertexShader<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>vertexShaderSource<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glShaderSource</span><span class="token punctuation">(</span>fragmentShader<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>fragmentShaderSource<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 3. 编译shader</span>
    <span class="token function">glCompileShader</span><span class="token punctuation">(</span>vertexShader<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//检查shader的编译是否出错</span>
    GLint success<span class="token punctuation">;</span>
    GLchar infoLog<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">glGetShaderiv</span><span class="token punctuation">(</span>vertexShader<span class="token punctuation">,</span> GL_COMPILE_STATUS<span class="token punctuation">,</span> <span class="token operator">&amp;</span>success<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>success<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">//获取shader的错误信息</span>
        <span class="token function">glGetShaderInfoLog</span><span class="token punctuation">(</span>vertexShader<span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> infoLog<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取错误信息</span>
        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"vertexShader Complie Error\n"</span> <span class="token operator">&lt;&lt;</span> infoLog <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
	<span class="token comment">//编译shader</span>
    <span class="token function">glCompileShader</span><span class="token punctuation">(</span>fragmentShader<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//检查shader的编译是否出错</span>
    <span class="token function">glGetShaderiv</span><span class="token punctuation">(</span>fragmentShader<span class="token punctuation">,</span> GL_COMPILE_STATUS<span class="token punctuation">,</span> <span class="token operator">&amp;</span>success<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>success<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">//获取shader的错误信息</span>
        <span class="token function">glGetShaderInfoLog</span><span class="token punctuation">(</span>fragmentShader<span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> infoLog<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取错误信息</span>
        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"fragmentShader Complie Error\n"</span> <span class="token operator">&lt;&lt;</span> infoLog <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="shader的链接"><a class="header-anchor" href="#shader的链接"></a>shader的链接</h3>
<p>编译完成后，我们需要创建一个Program(程序)，将编译生成的中间文件链接在一起，生成一个可执行的shader程序。</p>
<pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token keyword">void</span> <span class="token function">prepaerShader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">//shader源代码</span>
    <span class="token keyword">const</span> char<span class="token operator">*</span> vertexShaderSource <span class="token operator">=</span>
        <span class="token string">"#version 460 core\n"</span>
        <span class="token string">"layout(location = 0) in vec3 position;\n"</span>
        <span class="token string">"void main()\n"</span>
        <span class="token string">"&#123;\n"</span>
        <span class="token string">"gl_Position = vec4(position.x, position.y, position.z, 1.0);\n"</span>
        <span class="token string">"&#125;\n\0"</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> char<span class="token operator">*</span> fragmentShaderSource <span class="token operator">=</span>
        <span class="token string">"#version 460 core\n"</span>
        <span class="token string">"out vec4 color;\n"</span>
        <span class="token string">"void main()\n"</span>
        <span class="token string">"&#123;\n"</span>
        <span class="token string">"color = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n"</span>
        <span class="token string">"&#125;\n\0"</span><span class="token punctuation">;</span>
    GLuint vertexShader<span class="token punctuation">,</span>fragmentShader<span class="token punctuation">;</span>
    <span class="token comment">//创建一个vertex shader，并返回对应编号</span>
    vertexShader <span class="token operator">=</span> <span class="token function">glCreateShader</span><span class="token punctuation">(</span>GL_VERTEX_SHADER<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//创建一个fragment shader，并返回对应编号</span>
    fragmentShader <span class="token operator">=</span><span class="token function">glCreateShader</span><span class="token punctuation">(</span>GL_FRAGMENT_SHADER<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//给对应的shader注入源代码</span>
    <span class="token comment">//参数分别为:对应shader编号，源码字符串的个数，存储字符串的二维数组，存储每一个字符串长度的数组</span>
    <span class="token function">glShaderSource</span><span class="token punctuation">(</span>vertexShader<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>vertexShaderSource<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glShaderSource</span><span class="token punctuation">(</span>fragmentShader<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>fragmentShaderSource<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//编译shader</span>
    <span class="token function">glCompileShader</span><span class="token punctuation">(</span>vertexShader<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//检查shader的编译是否出错</span>
    GLint success<span class="token punctuation">;</span>
    GLchar infoLog<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">glGetShaderiv</span><span class="token punctuation">(</span>vertexShader<span class="token punctuation">,</span> GL_COMPILE_STATUS<span class="token punctuation">,</span> <span class="token operator">&amp;</span>success<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>success<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">glGetShaderInfoLog</span><span class="token punctuation">(</span>vertexShader<span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> infoLog<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取错误信息</span>
        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"VertexShader Complie Error\n"</span> <span class="token operator">&lt;&lt;</span> infoLog <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">glCompileShader</span><span class="token punctuation">(</span>fragmentShader<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glGetShaderiv</span><span class="token punctuation">(</span>fragmentShader<span class="token punctuation">,</span> GL_COMPILE_STATUS<span class="token punctuation">,</span> <span class="token operator">&amp;</span>success<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>success<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">glGetShaderInfoLog</span><span class="token punctuation">(</span>fragmentShader<span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> infoLog<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取错误信息</span>
        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"FragmentShader Complie Error\n"</span> <span class="token operator">&lt;&lt;</span> infoLog <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    
    
    <span class="token comment">//-------------------------------------------链接工作----------------------------------</span>
    <span class="token comment">//创建一个program</span>
    GLuint program<span class="token punctuation">;</span>
    program<span class="token operator">=</span><span class="token function">glCreateProgram</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//将上面编译好的结果与program相关联</span>
    <span class="token function">glAttachShader</span><span class="token punctuation">(</span>program<span class="token punctuation">,</span> vertexShader<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glAttachShader</span><span class="token punctuation">(</span>program<span class="token punctuation">,</span> fragmentShader<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//开始链接</span>
    <span class="token function">glLinkProgram</span><span class="token punctuation">(</span>program<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//检查是否有链接错误</span>
    <span class="token function">glGetProgramiv</span><span class="token punctuation">(</span>program<span class="token punctuation">,</span> GL_LINK_STATUS<span class="token punctuation">,</span> <span class="token operator">&amp;</span>success<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>success<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">glGetProgramInfoLog</span><span class="token punctuation">(</span>program<span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> infoLog<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取错误信息</span>
        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Link Error\n"</span> <span class="token operator">&lt;&lt;</span> infoLog <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">//链接完成后创建的shader就不需要了，释放资源</span>
    <span class="token function">glDeleteShader</span><span class="token punctuation">(</span>vertexShader<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glDeleteShader</span><span class="token punctuation">(</span>fragmentShader<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>shader经过编译和链接后就会形成一个程序(program)，可以有多个shader，使用函数glUseProgram(int programId)就可以选择我们绘制时所使用的shander了。</p>
<h3 id="Shader类的封装"><a class="header-anchor" href="#Shader类的封装"></a>Shader类的封装</h3>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;-------------------------------------------------shader.h文件
#pragma once
#include &quot;core.h&quot;
#include &lt;string&gt;

class Shader
&#123;
private:
	GLuint mProgram&#123; 0 &#125;;
	GLuint mVs&#123; 0 &#125;;
	GLuint mFs&#123; 0 &#125;;

private:
	void checkShaderErrors(GLuint id, const std::string&amp; type);

public:
	Shader(const char* vsPath, const char* fsPath);
	~Shader();
	void begin();
	void end();

public:
	void setUniform1f(const char* name, float x);
	void setUniform1i(const char* name, int x);
	void setUniformMatrix4(const char* name, const float* val);

&#125;;

&#x2F;&#x2F;-------------------------------------------------shader.cpp文件
#include &quot;shader.h&quot;
#include&lt;iostream&gt;
#include&lt;sstream&gt;
#include&lt;fstream&gt;

void Shader::checkShaderErrors(GLuint id, const std::string&amp; type)
&#123;
	int success &#x3D; 0;
	char infoLog[512];

	if (type &#x3D;&#x3D; &quot;PROGRAM&quot;)
	&#123;
		&#x2F;&#x2F;检查链接阶段是否有错误
		GL_CALL(glGetProgramiv(mProgram, GL_LINK_STATUS, &amp;success));
		if (!success)
		&#123;
			GL_CALL(glGetProgramInfoLog(mProgram, 512, NULL, infoLog));
			std::cout &lt;&lt; &quot;链接错误:&quot; &lt;&lt; infoLog &lt;&lt; std::endl;

		&#125;
	&#125;
	else if (type &#x3D;&#x3D; &quot;VS&quot;)
	&#123;
		&#x2F;&#x2F;检查编译是否出错
		GL_CALL(glCompileShader(id));
		&#x2F;&#x2F;获取报错信息
		GL_CALL(glGetShaderiv(id, GL_COMPILE_STATUS, &amp;success));
		if (!success)
		&#123;
			&#x2F;&#x2F;如果出错输出报错信息
			GL_CALL(glGetShaderInfoLog(id, 512, NULL, infoLog));
			std::cout &lt;&lt; &quot;VS编译错误:&quot; &lt;&lt; infoLog &lt;&lt; std::endl;
		&#125;
	&#125;
	else
	&#123;
		&#x2F;&#x2F;检查编译是否出错
		GL_CALL(glCompileShader(id));
		&#x2F;&#x2F;获取报错信息
		GL_CALL(glGetShaderiv(id, GL_COMPILE_STATUS, &amp;success));
		if (!success)
		&#123;
			&#x2F;&#x2F;如果出错输出报错信息
			GL_CALL(glGetShaderInfoLog(id, 512, NULL, infoLog));
			std::cout &lt;&lt; &quot;FS编译错误:&quot; &lt;&lt; infoLog &lt;&lt; std::endl;
		&#125;
	&#125;
&#125;

Shader::Shader(const char* vertexShaderPath, const char* fragmentShaderPath)
&#123;
	&#x2F;&#x2F;存储代码的字符串
	std::string vertexShaderCode;
	std::string fragmentShaderCode;
	&#x2F;&#x2F;读取文件的流
	std::ifstream vertexShaderFileStream(vertexShaderPath);
	std::ifstream fragmentShaderFileStream(fragmentShaderPath);
	&#x2F;&#x2F;检查文件是否成功打开
	if (!vertexShaderFileStream.is_open() || !fragmentShaderFileStream.is_open()) 
	&#123;
		std::cout &lt;&lt; &quot;Failed to open shader file: &quot; &lt;&lt; std::endl;
	&#125;
	&#x2F;&#x2F;将文件流转为字符串的中转站
	std::stringstream vertexShaderStringStream;
	vertexShaderStringStream &lt;&lt; vertexShaderFileStream.rdbuf();
	vertexShaderFileStream.close();
	std::stringstream fragmentShaderStringStream;
	fragmentShaderStringStream &lt;&lt; fragmentShaderFileStream.rdbuf();
	fragmentShaderFileStream.close();

	vertexShaderCode &#x3D; vertexShaderStringStream.str();
	fragmentShaderCode &#x3D; fragmentShaderStringStream.str();

	&#x2F;&#x2F;将string类型的源码转为我们需要的const char*类型
	const char* vertexShaderSource &#x3D; vertexShaderCode.c_str();
	const char* fragmentShaderSource &#x3D; fragmentShaderCode.c_str();


	&#x2F;&#x2F;创建shader和program
	mVs &#x3D; GL_CALL(glCreateShader(GL_VERTEX_SHADER));
	mFs &#x3D; GL_CALL(glCreateShader(GL_FRAGMENT_SHADER));
	mProgram &#x3D; GL_CALL(glCreateProgram());

	&#x2F;&#x2F;为shader注入源码
	GL_CALL(glShaderSource(mVs, 1, &amp;vertexShaderSource, NULL));
	GL_CALL(glShaderSource(mFs, 1, &amp;fragmentShaderSource, NULL));

	&#x2F;&#x2F;检查VS编译是否出错
	checkShaderErrors(mVs, &quot;VERTEX_SHADER&quot;);
	&#x2F;&#x2F;检查FS编译是否出错
	checkShaderErrors(mFs, &quot;FRAGMENT_SHADER&quot;);

	&#x2F;&#x2F;将shader装入progroam准备链接
	GL_CALL(glAttachShader(mProgram, mVs));
	GL_CALL(glAttachShader(mProgram, mFs));
	&#x2F;&#x2F;链接程序
	GL_CALL(glLinkProgram(mProgram));
	&#x2F;&#x2F;检查链接阶段是否有错误
	checkShaderErrors(mProgram, &quot;PROGRAM&quot;);

	&#x2F;&#x2F;连接成功后，创建的shader不再需要了，应删除释放资源
	GL_CALL(glDeleteShader(mVs));
	GL_CALL(glDeleteShader(mFs));
&#125;
Shader::~Shader()
&#123;
	GL_CALL(glDeleteShader(mVs));
	GL_CALL(glDeleteShader(mFs));
	GL_CALL(glDeleteProgram(mProgram));
&#125;
void Shader::begin()
&#123;
	GL_CALL(glUseProgram(mProgram));
&#125;
void Shader::end()
&#123;
	GL_CALL(glUseProgram(0));
&#125;


void Shader::setUniform1f(const char* name, float x)
&#123;
	GLint location &#x3D; GL_CALL(glGetUniformLocation(mProgram, name));
	GL_CALL(glUniform1f(location, x));
&#125;

void Shader::setUniform1i(const char* name, int x)
&#123;
	GLint location &#x3D; GL_CALL(glGetUniformLocation(mProgram, name));
	GL_CALL(glUniform1i(location, x));
&#125;

void Shader::setUniformMatrix4(const char* name, const float* val)
&#123;
	GLint location &#x3D; GL_CALL(glGetUniformLocation(mProgram, name));
	GL_CALL(glUniformMatrix4fv(location, 1, GL_FALSE, val));
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="绘制简单的三角形"><a class="header-anchor" href="#绘制简单的三角形"></a>绘制简单的三角形</h2>
<p>我们链接成功后就获得了shader程序的可执行文件，就告诉显卡我们要怎么绘制点了，下面我们就用OpenGL里的绘制命令<strong>glDrawArrays</strong>绘制一个简单的三角形。</p>
<p>当我们的顶点数据（VBO和VAO）和材质数据（VS和FS），都准备好之后我们需要告诉GPU开始绘制。</p>
<p>绘制前需要先用<strong>glUseProgram和glBindVertexArray</strong>指令指定绘制使用哪一个已经<strong>编译链接好</strong>的shader程序和哪一个VAO，然后调用<strong>glDrawArrays</strong>指令告诉GPU绘制的详细内容。</p>
<pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token comment">//渲染操作</span>
<span class="token keyword">void</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">//清理画布</span>
    <span class="token function">glClear</span><span class="token punctuation">(</span>GL_COLOR_BUFFER_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//绘制</span>
    <span class="token comment">//选择绘制程序</span>
    <span class="token function">glUseProgram</span><span class="token punctuation">(</span>program<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//绑定vao</span>
    <span class="token function">glBindVertexArray</span><span class="token punctuation">(</span>vao<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//函数参数依次为：绘制模式，绘制的起始顶点，参与绘制顶点的个数</span>
    <span class="token comment">//这俩我们绘制的是三角形，从0号顶点开始选择，共选择3个顶点</span>
    <span class="token function">glDrawArrays</span><span class="token punctuation">(</span>GL_TRIANGLES<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//解除VAO绑定</span>
    <span class="token function">glBindVertexArray</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在三角形的绘制模式中，因为一个三角形有3个点，所以当点的个数是3的倍数的时候，屏幕中会绘制出对应倍数个三角形。当点的个数<strong>不足三个</strong>时，会因为无法构成三角形而被<strong>忽略不绘制</strong>。</p>
<p>举个例子：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;假设有6个顶点,从0号顶点开始
glDrawArrays(GL_TRIANGLES, 0, 6);&#x2F;&#x2F;最终会绘制出两个三角形

&#x2F;&#x2F;假设有5个顶点，从0号顶点开始绘制
glDrawArrays(GL_TRIANGLES, 0, 5);&#x2F;&#x2F;最终会绘制出一个三角形，因为在三角形绘制模式下最后两个顶点无法构成三角形<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面列举出<strong>glDrawArrays</strong>中一些绘制模式，不同的绘制模式连接顶点的方式不一样：</p>
<p><strong>绘制三角形：</strong></p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250424211839314.png" alt="image-20250424211839314" style="zoom: 50%;" />
<p><strong>绘制直线：</strong></p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250424211915083.png" alt="image-20250424211915083" style="zoom:67%;" />
<h2 id="绘制一个彩色的三角形"><a class="header-anchor" href="#绘制一个彩色的三角形"></a>绘制一个彩色的三角形</h2>
<p>当我们三个点的颜色各不相同时，内部已经实现的渲染管线会把三角形内部的点按照用插值算法进行计算，使得三个顶点之间的颜色1有一个平滑的过渡，就绘制出了彩色的三角形。下面是具体代码：</p>
<pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token comment">//声明全局变量</span>
GLuint vao<span class="token punctuation">,</span> program<span class="token punctuation">;</span>

<span class="token comment">//准备VAO、program和VBO</span>
<span class="token keyword">void</span> <span class="token function">prepaerEBO</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">float</span> pos<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
        <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span><span class="token number">0.0f</span><span class="token punctuation">,</span>
         <span class="token number">0.5f</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span><span class="token number">0.0f</span><span class="token punctuation">,</span>
         <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.5f</span><span class="token punctuation">,</span><span class="token number">0.0f</span><span class="token punctuation">,</span>
         <span class="token number">1.0f</span><span class="token punctuation">,</span><span class="token number">1.0f</span><span class="token punctuation">,</span><span class="token number">0.0f</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> colors<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
        <span class="token number">1.0f</span><span class="token punctuation">,</span><span class="token number">0.0f</span><span class="token punctuation">,</span><span class="token number">0.0f</span><span class="token punctuation">,</span>
        <span class="token number">0.0f</span><span class="token punctuation">,</span><span class="token number">1.0f</span><span class="token punctuation">,</span><span class="token number">0.0f</span><span class="token punctuation">,</span>
        <span class="token number">0.0f</span><span class="token punctuation">,</span><span class="token number">0.0f</span><span class="token punctuation">,</span><span class="token number">1.0f</span><span class="token punctuation">,</span>
        <span class="token number">0.5f</span><span class="token punctuation">,</span><span class="token number">0.5f</span><span class="token punctuation">,</span><span class="token number">0.5f</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> idxs<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
        <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span>
        <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token comment">//创建VBO</span>
    GLuint posVbo<span class="token punctuation">,</span>colorVbo<span class="token punctuation">;</span>
        <span class="token comment">//位置VBO</span>
    <span class="token function">glGenBuffers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>posVbo<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> posVbo<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glBufferData</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">,</span> pos<span class="token punctuation">,</span> GL_STATIC_DRAW<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//颜色VBO</span>
    <span class="token function">glGenBuffers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>colorVbo<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> colorVbo<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glBufferData</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>colors<span class="token punctuation">)</span><span class="token punctuation">,</span> colors<span class="token punctuation">,</span> GL_STATIC_DRAW<span class="token punctuation">)</span><span class="token punctuation">;</span>


    <span class="token comment">//创建EBO</span>
    GLuint ebo<span class="token punctuation">;</span>
    <span class="token function">glGenBuffers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ebo<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ELEMENT_ARRAY_BUFFER<span class="token punctuation">,</span> ebo<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glBufferData</span><span class="token punctuation">(</span>GL_ELEMENT_ARRAY_BUFFER<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>idxs<span class="token punctuation">)</span><span class="token punctuation">,</span> idxs<span class="token punctuation">,</span> GL_STATIC_DRAW<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//创建VAO</span>
    <span class="token function">glGenVertexArrays</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>vao<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glBindVertexArray</span><span class="token punctuation">(</span>vao<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//绑定位置描述信息</span>
    <span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> posVbo<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glEnableVertexAttribArray</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glVertexAttribPointer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">,</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//绑定颜色描述信息</span>
    <span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> colorVbo<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glEnableVertexAttribArray</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glVertexAttribPointer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">,</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//绑定ebo到vao</span>
    <span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ELEMENT_ARRAY_BUFFER<span class="token punctuation">,</span> ebo<span class="token punctuation">)</span><span class="token punctuation">;</span>


    <span class="token function">glBindVertexArray</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>


 <span class="token comment">//-------------------------------------------shader的编译与链接----------------------------------</span>
<span class="token keyword">void</span> <span class="token function">prepaerShader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">//shader源代码</span>
    <span class="token keyword">const</span> char<span class="token operator">*</span> vertexShaderSource <span class="token operator">=</span>
        <span class="token string">"#version 460 core\n"</span>
        <span class="token string">"layout(location = 0) in vec3 aPosition;\n"</span>
        <span class="token string">"layout(location = 1) in vec3 aColor;\n"</span>
        <span class="token string">"out vec3 color;\n"</span>
        <span class="token string">"void main()\n"</span>
        <span class="token string">"&#123;\n"</span>
        <span class="token string">"gl_Position = vec4(aPosition.x, aPosition.y, aPosition.z, 1.0);\n"</span>
        <span class="token string">"color=aColor;\n"</span>
        <span class="token string">"&#125;\n\0"</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> char<span class="token operator">*</span> fragmentShaderSource <span class="token operator">=</span>
        <span class="token string">"#version 460 core\n"</span>
        <span class="token string">"out vec4 fColor;\n"</span>
        <span class="token string">"in vec3 color;\n"</span>
        <span class="token string">"void main()\n"</span> 
        <span class="token string">"&#123;\n"</span>
        <span class="token string">"fColor = vec4(color,1.0f);\n"</span>
        <span class="token string">"&#125;\n\0"</span><span class="token punctuation">;</span>
    GLuint vertexShader<span class="token punctuation">,</span>fragmentShader<span class="token punctuation">;</span>
    <span class="token comment">//创建一个vertex shader，并返回对应编号</span>
    vertexShader <span class="token operator">=</span> <span class="token function">glCreateShader</span><span class="token punctuation">(</span>GL_VERTEX_SHADER<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//创建一个fragment shader，并返回对应编号</span>
    fragmentShader <span class="token operator">=</span><span class="token function">glCreateShader</span><span class="token punctuation">(</span>GL_FRAGMENT_SHADER<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//给对应的shader注入源代码</span>
    <span class="token comment">//参数分别为:对应shader编号，源码字符串的个数，存储字符串的二维数组，存储每一个字符串长度的数组</span>
    <span class="token function">glShaderSource</span><span class="token punctuation">(</span>vertexShader<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>vertexShaderSource<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glShaderSource</span><span class="token punctuation">(</span>fragmentShader<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>fragmentShaderSource<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//编译shader</span>
    <span class="token function">glCompileShader</span><span class="token punctuation">(</span>vertexShader<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//检查shader的编译是否出错</span>
    <span class="token keyword">int</span> success<span class="token punctuation">;</span>
    GLchar infoLog<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">glGetShaderiv</span><span class="token punctuation">(</span>vertexShader<span class="token punctuation">,</span> GL_COMPILE_STATUS<span class="token punctuation">,</span> <span class="token operator">&amp;</span>success<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>success<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">glGetShaderInfoLog</span><span class="token punctuation">(</span>vertexShader<span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> infoLog<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取错误信息</span>
        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"VertexShader Complie Error\n"</span> <span class="token operator">&lt;&lt;</span> infoLog <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token function">glCompileShader</span><span class="token punctuation">(</span>fragmentShader<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glGetShaderiv</span><span class="token punctuation">(</span>fragmentShader<span class="token punctuation">,</span> GL_COMPILE_STATUS<span class="token punctuation">,</span> <span class="token operator">&amp;</span>success<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>success<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">glGetShaderInfoLog</span><span class="token punctuation">(</span>fragmentShader<span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> infoLog<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取错误信息</span>
        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"FragmentShader Complie Error\n"</span> <span class="token operator">&lt;&lt;</span> infoLog <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    program<span class="token operator">=</span><span class="token function">glCreateProgram</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//将上面编译好的结果与program相关联</span>
    <span class="token function">glAttachShader</span><span class="token punctuation">(</span>program<span class="token punctuation">,</span> vertexShader<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glAttachShader</span><span class="token punctuation">(</span>program<span class="token punctuation">,</span> fragmentShader<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//开始链接</span>
    <span class="token function">glLinkProgram</span><span class="token punctuation">(</span>program<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//检查是否有链接错误</span>
    <span class="token function">glGetProgramiv</span><span class="token punctuation">(</span>program<span class="token punctuation">,</span> GL_LINK_STATUS<span class="token punctuation">,</span> <span class="token operator">&amp;</span>success<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>success<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">glGetProgramInfoLog</span><span class="token punctuation">(</span>program<span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> infoLog<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取错误信息</span>
        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Link Error\n"</span> <span class="token operator">&lt;&lt;</span> infoLog <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">//链接完成后创建的shader就不需要了，释放资源</span>
    <span class="token function">glDeleteShader</span><span class="token punctuation">(</span>vertexShader<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glDeleteShader</span><span class="token punctuation">(</span>fragmentShader<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>



 <span class="token comment">//-------------------------------------------渲染操作----------------------------------</span>
<span class="token comment">//渲染操作</span>
<span class="token keyword">void</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">//清理画布</span>
    <span class="token function">glClear</span><span class="token punctuation">(</span>GL_COLOR_BUFFER_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//绘制</span>
    <span class="token comment">//选择绘制程序</span>
    <span class="token function">glUseProgram</span><span class="token punctuation">(</span>program<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//绑定vao</span>
    <span class="token function">glBindVertexArray</span><span class="token punctuation">(</span>vao<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//开始绘制，参数依次为：绘制的图形，起始点，点的个数</span>
    <span class="token comment">//这俩我们绘制的是三角形，从0号开始选择，共选择3个顶点</span>
    <span class="token comment">//glDrawArrays(GL_LINES, 0, 2);</span>
    

    <span class="token comment">//使用ebo时用这个方法绘制，参数依次：绘制模式，绘制图形的点数，索引数据类型，偏移量（一般写0）</span>
    <span class="token function">glDrawElements</span><span class="token punctuation">(</span>GL_TRIANGLES<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> GL_UNSIGNED_INT<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//接触绑定</span>
    <span class="token function">glBindVertexArray</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在glsl中，我们可以使用<strong>in</strong>或者<strong>out</strong>关键字控制程序接收的输入和输出，并且在<strong>Vexter Shander中out输出</strong>的变量最终在<strong>Fragment Shader</strong>可以用<strong>in</strong>关键字声明<strong>同名的变量</strong>接收到。</p>
<pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token comment">//Vexter Shader</span>
<span class="token comment">//用VAO 0号位置的描述性信息从VBO中取坐标数据输入</span>
<span class="token keyword">layout</span><span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token keyword">vec3</span> aPosition<span class="token punctuation">;</span>
<span class="token comment">//用VAO 1号位置的描述性信息从VBO中取颜色数据输入</span>
<span class="token keyword">layout</span><span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token keyword">vec3</span> aColor<span class="token punctuation">;</span>
<span class="token comment">//输出一个三维向量 color</span>
<span class="token keyword">out</span> <span class="token keyword">vec3</span> color<span class="token punctuation">;</span>
<span class="token comment">//给color赋值后Fragment Shader就能拿到数据</span>
<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token comment">//将我们的颜色信息交给Fragment Shader处理</span>
    color<span class="token operator">=</span>aColor<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//Fragment Shader</span>
<span class="token comment">//输出最终的颜色</span>
<span class="token keyword">out</span> <span class="token keyword">vec4</span> fColor<span class="token punctuation">;</span>
<span class="token comment">//接收从Vexter Shader输出的color向量(变量名要一致)</span>
<span class="token keyword">in</span> <span class="token keyword">vec3</span> color<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token comment">//用从Vexter Shader接收到的颜色控制最终输出的颜色</span>
    fColor <span class="token operator">=</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span>color<span class="token punctuation">,</span><span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面因为三个点的颜色不一致，所以会在内部自动进行三角形内每个点的插值运算，得到一个彩色的三角形，如下图所示：</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240206114956358.png" alt="image-20240206114956358" style="zoom:50%;" />
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250511214654845.png" alt="image-20250511214654845" style="zoom:67%;" />
<h2 id="texture-纹理"><a class="header-anchor" href="#texture-纹理"></a>texture(纹理)</h2>
<h3 id="UV坐标"><a class="header-anchor" href="#UV坐标"></a>UV坐标</h3>
<p>在OpenGL中，<strong>左下角为坐标原点</strong>，图片的大都为左上角为坐标原点，因此在OpenGL中存储图片必须反转一下图片的Y轴。</p>
<p>在纹理中，我们使用的是UV坐标。通常U表示横向，V表示纵向，两个方向的取值都是<strong>0到1</strong>之间，用以表示当前像素对应图片上百分比位置。</p>
<p>以前的屏幕像素与纹理像素一一对应的方法不灵活且效果差，采用UV坐标后就改为了<strong>比例对应</strong>的方式。首先找到屏幕中某一像素所在位置的百分比，将横向和纵向的百分比分别乘以纹理图片的宽和高，就得到了与屏幕中该像素对应的纹理图片中的像素。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250704220905713.png" alt="image-20250704220905713" style="zoom:50%;" />
<p>从上面可以得知，在为我们的图形贴上贴图时，需要知道每个顶点的UV坐标。也就是说，<strong>UV坐标需要作为每个顶点的属性存储在VBO中</strong>。知道了顶点的UV坐标后，光栅化后的每个像素块的UV坐标都会由插值算法计算出，这样就可以为图形贴上纹理了。</p>
<h3 id="纹理对象与采样"><a class="header-anchor" href="#纹理对象与采样"></a>纹理对象与采样</h3>
<p>纹理对象（Texture）是在GPU端按照<strong>一定的格式</strong>存储纹理图片的<strong>描述信息</strong>和<strong>数据信息</strong>的对象。（在cpu端，描述图片的格式有多种，例如jpg、png等。当我们读取到纹理图片到内存后需要发送到显存中，而在显存中用来描述纹理图片信息的对象就叫做纹理对象。）</p>
<p>在GPU端<strong>根据UV坐标</strong>按照<strong>一定的算法</strong>从<strong>纹理图片中获取颜色</strong>的过程称为采样，执行采样的对象叫做采样器（sampler）。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250704222728529.png" alt="image-20250704222728529" style="zoom:67%;" />
<h3 id="Texture-Units-纹理单元"><a class="header-anchor" href="#Texture-Units-纹理单元"></a>Texture Units(纹理单元)</h3>
<p>纹理与单元绑定后，采样器可以选择使用哪一个单元并获取与之对应的纹理对象。</p>
<p>具体来说，纹理单元是采样器和纹理对象之间的桥梁。纹理对象绑定某个纹理单元后，采样器可以对这个单元所绑定的纹理对象进行采样。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240220104327355.png" alt="image-20240220104327355" style="zoom:50%;" />
<p>使用下面的函数可以进行纹理对象的创建、纹理单元的激活以及纹理对象和纹理单元的绑定操作。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240220104357382.png" alt="image-20240220104357382" style="zoom:50%;" />
<p>如果我们先执行纹理单元的激活操作，再执行<strong>glBindTexture</strong>函数，此时会将该<strong>纹理对象绑定到前面激活的纹理单元</strong>上。</p>
<p>glBindTexture函数不仅会将纹理对象绑定到纹理单元上，也会将纹理对象绑定到Opengl对应的插槽上，以便将图片数据发送到指定的纹理对象身上。</p>
<p>如果执行<strong>glBindTexture</strong>函数时没有激活任何纹理单元，则此时会<strong>默认激活0号纹理单元</strong>，该纹理对象绑定到0号单元。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240220104438107.png" alt="image-20240220104438107" style="zoom:50%;" />
<p>执行glTexImage2D函数后，会向当前绑定在状态机中的纹理对象中发送图片数据。</p>
<p>其中<strong>type</strong>参数是指我们每一个通道的数据是什么格式的，因为每个通道取值都是0-255，所以8位的unsigned_byte类型足够了。</p>
<p><strong>pixels</strong>参数就是读取到的图片数据的指针，将读取到的数据直接传过去即可。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240220104946423.png" alt="image-20240220104946423" style="zoom:67%;" />
<pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl">GLuint texture<span class="token punctuation">;</span>
<span class="token comment">//----------------------------------旧版（OpenGL 4.5之前）创建纹理方式</span>
<span class="token keyword">void</span> <span class="token function">prepaerTextures</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
     <span class="token keyword">int</span> width<span class="token punctuation">,</span> height<span class="token punctuation">,</span> channel<span class="token punctuation">;</span>
    <span class="token comment">//读取图片</span>
    <span class="token function">stbi_set_flip_vertically_on_load</span><span class="token punctuation">(</span><span class="token keyword">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> char<span class="token operator">*</span> data <span class="token operator">=</span> <span class="token function">stbi_load</span><span class="token punctuation">(</span><span class="token string">"Assets/Textures/a.png"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>width<span class="token punctuation">,</span> <span class="token operator">&amp;</span>height<span class="token punctuation">,</span> <span class="token operator">&amp;</span>channel<span class="token punctuation">,</span> STBI_rgb_alpha<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">//生成纹理对象并绑定单元</span>
    <span class="token function">glGenTextures</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>texture<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">//激活纹理单元（必须要先激活指定的纹理单元再绑定纹理对象才能将纹理对象绑定到指定单元身上）</span>
    <span class="token function">glActiveTexture</span><span class="token punctuation">(</span>GL_TEXTURE0<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//绑定纹理对象到OpenGL插槽中</span>
    <span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> texture<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//开辟显存传输图片数据</span>
    <span class="token function">glTexImage2D</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> GL_RGBA<span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> GL_RGBA<span class="token punctuation">,</span> GL_UNSIGNED_BYTE<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>


    <span class="token comment">//释放内存中的图片数据</span>
    <span class="token function">stbi_image_free</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//----------------------------------新版（OpenGL 4.5之后）创建纹理方式，函数参数都大同小异</span>
<span class="token keyword">void</span> <span class="token function">prepaerTextures</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    
    	<span class="token keyword">int</span> width<span class="token punctuation">,</span> height<span class="token punctuation">,</span> channels<span class="token punctuation">;</span>
		stbi_uc<span class="token operator">*</span> data <span class="token operator">=</span> <span class="token function">stbi_load</span><span class="token punctuation">(</span>filePath<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>width<span class="token punctuation">,</span> <span class="token operator">&amp;</span>height<span class="token punctuation">,</span> <span class="token operator">&amp;</span>channels<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
   		<span class="token comment">//直接创建纹理对象并绑定到GL_TEXTURE_2D插槽</span>
		<span class="token function">glCreateTextures</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>m_RendererId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    	
    	<span class="token comment">//将纹理对象直接绑定到指定纹理单元(不用先激活纹理单元再绑定纹理对象了，可以一步到位)</span>
    	<span class="token function">glBindTextureUnit</span><span class="token punctuation">(</span>unit<span class="token punctuation">,</span> m_RendererId<span class="token punctuation">)</span><span class="token punctuation">;</span>	
    
    	<span class="token comment">//分配显存，设置纹理的存储格式，但不填充数据(使用glTextureSubImage2D填充或更新数据)</span>
		<span class="token comment">//第二个参数levels设为1表示不启用mipmap</span>
		<span class="token function">glTextureStorage2D</span><span class="token punctuation">(</span>m_RendererId<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> GL_RGB8<span class="token punctuation">,</span> m_Width<span class="token punctuation">,</span> m_Height<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//将纹理数据传送到GPU</span>
		<span class="token function">glTextureSubImage2D</span><span class="token punctuation">(</span>m_RendererId<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> m_Width<span class="token punctuation">,</span> m_Height<span class="token punctuation">,</span> GL_RGB<span class="token punctuation">,</span> GL_UNSIGNED_BYTE<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>

    
		<span class="token comment">//设置纹理过滤方式(新旧方式一致)</span>
		<span class="token function">glTextureParameteri</span><span class="token punctuation">(</span>m_RendererId<span class="token punctuation">,</span> GL_TEXTURE_MIN_FILTER<span class="token punctuation">,</span> GL_LINEAR<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">glTextureParameteri</span><span class="token punctuation">(</span>m_RendererId<span class="token punctuation">,</span> GL_TEXTURE_MAG_FILTER<span class="token punctuation">,</span> GL_LINEAR<span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token function">stbi_image_free</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="纹理过滤"><a class="header-anchor" href="#纹理过滤"></a>纹理过滤</h3>
<p>这其实就是之前计算机图形学中纹理问题的内容，当图片大小确定，而展示区域比图片大或者比图片小时都会出现绘制的问题，而纹理过滤就是为了解决这样的问题。</p>
<p>总共有两种问题会出现：</p>
<ol>
<li>展示区域过大（屏幕像素&gt;图片像素），图片需要放大。一般会使用**双线性插值(Bilinear)**创造缺少的像素，这样会使图片放大后变得模糊，而不会出现明显的颗粒感。</li>
<li>展示区域过小（屏幕像素&lt;图片像素），图片需要缩小。一般使用**临近法(Nearest)**优先选择离屏幕像素更近的图片像素，使得小的区域能展示更多的图片信息。</li>
</ol>
<p>下面是在OpenGL中设置纹理过滤的方式，通过<strong>glTexParameteri</strong>函数进行设置。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240220113239049.png" alt="image-20240220113239049" style="zoom:67%;" />
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;设置纹理过滤方式
&#x2F;&#x2F;展示区域 &lt; 图片大小  纹理图片需要缩小  线性插值
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
&#x2F;&#x2F;展示区域 &gt; 图片大小  纹理图片需要放大  就近
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="纹理包裹"><a class="header-anchor" href="#纹理包裹"></a>纹理包裹</h3>
<p>在前面的介绍中，opengl中的uv坐标是要在<code>[0, 1]</code> 范围内的，但是实际应用中uv坐标可能会出现大于1的情况。</p>
<p><strong>纹理包裹（Texture Wrapping）</strong> 定义了当纹理坐标（UV）超出默认范围 <code>[0, 1]</code> 时，如何采样纹理边缘的行为。它是控制纹理重复、拉伸或截断的关键参数。可以通过<strong>glTexParameteri</strong>函数进行设置，共有四种策略可供使用。</p>
<p>在设置时，主要分为 <strong>S（水平）</strong> 和 <strong>T（垂直）</strong> 两个方向，不难看出S和U同一个方向，T</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>行为描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>GL_REPEAT</code></strong></td>
<td>重复纹理（默认模式）</td>
</tr>
<tr>
<td><strong><code>GL_MIRRORED_REPEAT</code></strong></td>
<td>镜像重复</td>
</tr>
<tr>
<td><strong><code>GL_CLAMP_TO_EDGE</code></strong></td>
<td>截取边缘颜色</td>
</tr>
<tr>
<td><strong><code>GL_CLAMP_TO_BORDER</code></strong></td>
<td>超出部分填充自定义边框色  需配合 <code>glTexParameterfv(GL_TEXTURE_BORDER_COLOR)</code></td>
</tr>
</tbody>
</table>
<p><img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250705165048770.png" alt="image-20250705165048770" style="zoom:50%;display:inline" /><img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250705165210016.png" alt="image-20250705165210016" style="zoom:50%;display:inline" /></p>
<p><img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250705165428936.png" alt="image-20250705165428936" style="zoom:40%;display:inline" /><img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250705165647969.png" alt="image-20250705165647969" style="zoom:40%;display:inline" /></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;设置纹理包裹方式
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);&#x2F;&#x2F;S -&gt; U
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);&#x2F;&#x2F;T -&gt; V<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="使用采样器"><a class="header-anchor" href="#使用采样器"></a>使用采样器</h3>
<p>这部分就要在shader中使用采样器对纹理进行采样获取每个像素的颜色。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 1. 因为uv坐标每个顶点都是不一样的，所以要先在vbo中将uv坐标作为顶点属性传到显存中
void prepare()
&#123;
    &#x2F;&#x2F;准备数据（坐标，颜色，uv坐标）
    float data[] &#x3D; &#123; 
        -0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f,
        0.5f, 0.5f, 0.0f,   0.0f, 1.0f, 0.0f, 1.0f, 1.0f,
        -0.5f, 0.5f, 0.0f,  0.0f, 0.0f, 1.0f, 0.0f, 1.0f,
        0.5f, -0.5f, 0.0f,  0.5f, 0.5f, 0.5f, 1.0f, 0.0f
    &#125;;
    unsigned int idxs[] &#x3D; &#123;
        0,1,2,
        1,0,3
    &#125;;



    &#x2F;&#x2F;创建vbo
    GL_CALL(glGenBuffers(1, &amp;vbo));
    &#x2F;&#x2F;绑定vbo
    GL_CALL(glBindBuffer(GL_ARRAY_BUFFER, vbo));
    &#x2F;&#x2F;传输数据
    GL_CALL(glBufferData(GL_ARRAY_BUFFER, sizeof(data), data, GL_STATIC_DRAW));


    &#x2F;&#x2F;创建vao
    GL_CALL(glGenVertexArrays(1, &amp;vao));
    &#x2F;&#x2F;绑定vao
    GL_CALL(glBindVertexArray(vao));
    &#x2F;&#x2F;设置坐标属性描述
    GL_CALL(glEnableVertexAttribArray(0));
    GL_CALL(glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0));
    &#x2F;&#x2F;设置颜色属性描述
    GL_CALL(glEnableVertexAttribArray(1));
    GL_CALL(glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float))));
    &#x2F;&#x2F;设置uv坐标描述
    GL_CALL(glEnableVertexAttribArray(2));
    GL_CALL(glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float))));
    
    &#x2F;&#x2F;创建ebo
    GL_CALL(glGenBuffers(1, &amp;ebo));
    &#x2F;&#x2F;绑定ebo到vao上
    GL_CALL(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo));
    GL_CALL(glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(idxs), idxs, GL_STATIC_DRAW));

    &#x2F;&#x2F;解绑vao
    GL_CALL(glBindVertexArray(0));

    &#x2F;&#x2F;准备shader
    shader &#x3D; new Shader(&quot;assets&#x2F;shaders&#x2F;vertex.glsl&quot;, &quot;assets&#x2F;shaders&#x2F;fragment.glsl&quot;);
&#125;

&#x2F;&#x2F; 2. 准备纹理对象、绑定纹理单元等操作
void prepareTexture()
&#123;
    &#x2F;&#x2F;读取图片
    int height, width, channels;
    stbi_set_flip_vertically_on_load(true);
    unsigned char* imageData &#x3D; stbi_load(&quot;assets&#x2F;textures&#x2F;box.png&quot;, &amp;height, &amp;width, &amp;channels, STBI_rgb_alpha);

    &#x2F;&#x2F;创建纹理对象
    glGenTextures(1, &amp;texture);
    &#x2F;&#x2F;激活0号纹理单元（如果不手动激活纹理单元，在绑定纹理对象时默认激活0号纹理单元）
    glActiveTexture(GL_TEXTURE0);
    &#x2F;&#x2F;绑定纹理对象
    glBindTexture(GL_TEXTURE_2D, texture);
    &#x2F;&#x2F;向纹理对象传递数据
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, imageData);

    &#x2F;&#x2F;释放内存中读取的的图片数据（已经发送到显存了，CPU端没有必要再保存数据了）
    stbi_image_free(imageData);
    
    &#x2F;&#x2F;设置纹理过滤方式
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    &#x2F;&#x2F;设置纹理包裹方式
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);&#x2F;&#x2F;S -&gt;U
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);&#x2F;&#x2F;T -&gt;V
&#125;

&#x2F;&#x2F; 3. 在vertexShader中接收uv坐标并传递到fragemntShader中
#version 460 core
layout(location &#x3D; 0) in vec3 aPosition;
layout(location &#x3D; 1) in vec3 aColor;
layout(location &#x3D; 2) in vec2 aUv;

out vec3 color;
out vec2 uv;

uniform float time;
void main()
&#123;
	color &#x3D; aColor;
	uv &#x3D; aUv;
	gl_Position &#x3D; vec4(aPosition.x, aPosition.y + sin(time) &#x2F; 2.0, aPosition.z, 1.0);
&#125;

&#x2F;&#x2F; 4. 在fragmentShader中增加一个sampler2D的uniform变量作为采样器对纹理进行采样
#version 460 core
out vec4 FragColor;

in vec3 color;
in vec2 uv;

uniform sampler2D sampler;
void main()
&#123;
	&#x2F;&#x2F;原始颜色设置
	&#x2F;&#x2F;FragColor &#x3D; vec4(color.x, color.y, color.z, 1.0f);
	
	&#x2F;&#x2F;使用texture函数选择一个采样器在指定uv坐标上采样，获取一个三维(rgb)或四维向量(rgba)
	FragColor &#x3D; texture(sampler, uv);
&#125;

&#x2F;&#x2F; 5. 外部设置采样器的值，将采样器与纹理单元进行绑定，以决定采样器要对哪个纹理单元采样
shader-&gt;setUniform1i(&quot;sampler&quot;, 0);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们在代码中可以给sampler赋一个int类型的数值（纹理单元的编号），将采样器与纹理单元进行绑定，表示这个采样器要对哪个纹理单元进行采样。</p>
<p><strong>注意：</strong><code>glTexParameteri</code> 修改的是<strong>当前绑定的纹理对象</strong>的状态。因此必须先使用glBindTexture绑定纹理对象到opengl插槽后才能正确执行纹理过滤方式和纹理包裹方式的设置，如果还未绑定纹理对象就先设置，那么纹理则无法正常显示。</p>
<h3 id="MipMap（多级渐远纹理）"><a class="header-anchor" href="#MipMap（多级渐远纹理）"></a>MipMap（多级渐远纹理）</h3>
<p>当视线逐渐远离一个物体时，根据进大远小的原理，物体也必然会变得越来越小，那么该物体在屏幕中所占的像素也会越来越少。那么问题来了，一开始物体表面的原始贴图必然是清晰的，随着物体越来越小，可显示的像素块页越来越少，就会导致在一块小区域对一张大图片进行采样，不仅会导致画面出现毛刺和摩尔纹等问题，也会浪费内存和带宽。</p>
<p>如下图所示，将一张贴图向远处重复延伸，近处显示的很清晰，但是远处的画面看起来非常模糊不舒服，问题所在就是前面所描述的。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250705214311994.png" alt="image-20250705214311994" style="zoom: 33%;" />
<p>为了解决这一问题，于是就有了MipMap。MipMap可以生成一系列的纹理图像，根据不同的距离为物体选择合适的纹理，即解决了远距离图像失真的情况，又节省了渲染资源。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250705214529896.png" alt="image-20250705214529896" style="zoom:50%;" />
<p>如果要使用OpenGL中提供的MipMap生成策略，只需要两句代码即可。</p>
<p><strong>glGenerateMipmap</strong>函数会为当前绑定的纹理贴图生成一系列不同level的Mipmap纹理。</p>
<p><strong>glTexParameteri</strong>函数是设置选择不同Mipmap纹理的策略，由于只有当<strong>展示区域像素&lt;纹理像素</strong>时才会出现这种情况，所以只需要设置<strong>GL_TEXTURE_MIN_FILTER</strong>情况时的Mipmap选择策略即可。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250706154430595.png" alt="image-20250706154430595" style="zoom: 50%;" />
<h3 id="Texture类的封装"><a class="header-anchor" href="#Texture类的封装"></a>Texture类的封装</h3>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;-------------------------------------------------texture.h文件
#pragma once
#include &quot;core.h&quot;

class Texture
&#123;
private:
	GLuint mTexture&#123; 0 &#125;;
	int mWidth&#123; 0 &#125;;
	int mHeight&#123; 0 &#125;;
	GLuint mUnit&#123; 0 &#125;;


public:
	Texture(const char* path, int unit);
	~Texture();

public:
	&#x2F;&#x2F;将当前纹理对象绑定到opengl状态机上
	void bind();

&#125;;



&#x2F;&#x2F;-------------------------------------------------texture.cpp文件
#define STB_IMAGE_IMPLEMENTATION
#include &lt;stb_image&#x2F;stb_image.h&gt;
#include &quot;texture.h&quot;

Texture::Texture(const char* path, int unit)
&#123;
    mUnit &#x3D; unit;
    &#x2F;&#x2F;读取图片
    int channels;
    stbi_set_flip_vertically_on_load(true);
    unsigned char* imageData &#x3D; stbi_load(path, &amp;mWidth, &amp;mHeight, &amp;channels, STBI_rgb_alpha);

    &#x2F;&#x2F;创建纹理对象
    GL_CALL(glGenTextures(1, &amp;mTexture));
    &#x2F;&#x2F;激活0号纹理单元（如果不手动激活纹理单元，在绑定纹理对象时默认激活0号纹理单元）
    GL_CALL(glActiveTexture(GL_TEXTURE0 + mUnit));

    &#x2F;&#x2F;绑定纹理对象
    GL_CALL(glBindTexture(GL_TEXTURE_2D, mTexture));

    &#x2F;&#x2F;向纹理对象传递数据
    GL_CALL(glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, mWidth, mHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, imageData));

    &#x2F;&#x2F;释放内存中读取的的图片数据（已经发送到显存了，CPU端没有必要再保存数据了）
    stbi_image_free(imageData);

    &#x2F;&#x2F;设置纹理过滤方式
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    &#x2F;&#x2F;设置纹理包裹方式
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);&#x2F;&#x2F;S -&gt;U
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);&#x2F;&#x2F;T -&gt;V
&#125;

Texture::~Texture()
&#123;
    if (mTexture !&#x3D; 0)
    &#123;
        glDeleteTextures(1, &amp;mTexture);
    &#125;

&#125;

void Texture::bind()
&#123;
    &#x2F;&#x2F;激活自己的纹理单元
    GL_CALL(glActiveTexture(GL_TEXTURE0 + mUnit));

    &#x2F;&#x2F;绑定纹理对象
    GL_CALL(glBindTexture(GL_TEXTURE_2D, mTexture));
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="变换"><a class="header-anchor" href="#变换"></a>变换</h2>
<h3 id="坐标系"><a class="header-anchor" href="#坐标系"></a>坐标系</h3>
<p><img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250706202159737.png" alt="image-20250706202159737"></p>
<p>世界坐标系是绝对的，永恒不变的。本地坐标系是物体身上附加的坐标系，用来表示物体的朝向等状态，当物体旋转或者移动时，其本地坐标系会随着物体改变。</p>
<h3 id="模型变换矩阵（ModelMatrix）"><a class="header-anchor" href="#模型变换矩阵（ModelMatrix）"></a>模型变换矩阵（ModelMatrix）</h3>
<p>glm变换函数的第一个参数是一个矩阵，表明了当前物体前面的所有变换。如下代码所示，在第一次变换时，由于还未进行变换，所以要传入单位矩阵，表面是原始状态。在第二次变换时，传入的是第一次变换后得到的transform矩阵，这个矩阵已经记录了第一次将物体选择了45度的状态，然后在此状态下进行平移变换。且<strong>平移时是按照旋转后的本地坐标系移动</strong>的。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250706203639109.png" alt="image-20250706203639109" style="zoom: 50%;" />
<p>旋转操作是围绕原点旋转的，<strong>glm中的旋转</strong>是以物体的<strong>本地坐标系原点</strong>为基准进行旋转的。一开始本地坐标系和世界坐标系重合，先将物体平移，再旋转45度，可以看到物体并没有绕着世界坐标系原点旋转，而是绕着本地坐标系原点旋转的。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250706204146727.png" alt="image-20250706204146727" style="zoom:50%;" />
<p>glm的平移变换要根据缩放变换的程度而定，假设我们先将x方向缩放为原来的0.5倍，那么再将物体向x轴平移1个单位距离时，就会只平移0.5个单位距离。这是因为x轴已经被缩放过了，实际平移的距离 = 输入平移的距离 * 对应轴缩放系数。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250706204420151.png" alt="image-20250706204420151" style="zoom:50%;" />
<p>模型变换就是对物体进行平移、缩放、旋转等变换操作，这一步骤会将物体的顶点坐标由<strong>模型坐标系</strong>转为<strong>世界坐标系</strong>下的坐标。简单来说，模型变换就是将物体从初始状态摆放在世界中的其他位置。</p>
<h3 id="视图变换矩阵（MiewMatrix）"><a class="header-anchor" href="#视图变换矩阵（MiewMatrix）"></a>视图变换矩阵（MiewMatrix）</h3>
<p>为了将物体投影出来，我们需要一个观察者来观察世界中的物体，这个观察者被称为<strong>摄像机</strong>(Camera)，这只是一个抽象的概念，并不实际存在。</p>
<p>对于一个摄像机来说，我们需要知道最基本的三个参数，即摄像机的<strong>位置</strong>、摄像机的<strong>朝向</strong>（看向哪个方向）和摄像机的<strong>穹顶方向</strong>（正上方的方向。因为当相机倒过来的时候看到的物体也会是倒的，我们需要知道摄像机是正的还是歪的）。</p>
<p>现在考虑最简单的情况：</p>
<ul>
<li>摄像机在<strong>世界坐标系的原点</strong></li>
<li>摄像机<strong>看向-Z方向</strong></li>
<li>穹顶方向维Y轴方向</li>
</ul>
<p>此时进行投影计算最为简单，因为所有的物体只需要<strong>沿z轴投影</strong>到摄像机的屏幕上即可。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250707163143623.png" alt="image-20250707163143623" style="zoom:50%;" />
<p>假设此时摄像机进行了旋转和平移等变换操作：</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250707163802275.png" alt="image-20250707163802275" style="zoom:50%;" />
<p>此时摄像机的朝向是一个较为复杂的方向，如果此时再将物体投影到摄像机的屏幕上，在数学计算上是一个非常麻烦的事情。在数学上，我们的的投影都喜欢沿着坐标轴投影，处理这样一个复杂方向的投影是比较困难的。</p>
<p>为了解决这一问题，可以将<strong>物体</strong>的顶点坐标由<strong>世界坐标系</strong>转为到<strong>摄像机坐标系</strong>（就是摄像机自己的本地坐标系）中。这样的好处是，在摄像机坐标系中摄像机所在的<strong>位置始终是原点</strong>，其<strong>朝向始终是-Z轴</strong>，物体可以直接在摄像机坐标系下沿Z轴进行投影。</p>
<p>所以我们只需要求出摄像机变换后，物体在摄像机坐标系下的坐标即可，即将<strong>物体顶点坐标</strong>从<strong>世界坐标系</strong>转到<strong>摄像机坐标系</strong>下。</p>
<p>相机的变换位置可由旋转变换和平移变换叠加而来。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250707165401188.png" alt="image-20250707165401188" style="zoom: 33%;" />
<p>这里我们让物体的顶点和摄像机做相同的变换，经过推导可得物体顶点的世界坐标系坐标和摄像机坐标系坐标的关系。</p>
<p>即已知某点的<strong>摄像机坐标系坐标</strong>和<strong>摄像机变换矩阵</strong>可以求得<strong>该点的世界坐标系坐标</strong>；</p>
<p>反之，已知某点的<strong>世界坐标系坐标</strong>和<strong>摄像机变换矩阵</strong>也可以求出<strong>该点的摄像机坐标系坐标</strong>。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250707171022603.png" alt="image-20250707171022603" style="zoom: 50%;" />
<p>这样以来，我们只需要知道了摄像机的变换矩阵，便可通过下面的公式求出顶点的<strong>摄像机坐标系坐标</strong>。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250707171758859.png" alt="image-20250707171758859" style="zoom:50%;" />
<p>知道计算公式以后，我们还需要计算出摄像机变换矩阵中的<strong>旋转部分</strong>和<strong>平移部分</strong>，因为变换矩阵是由旋转矩阵和平移矩阵叠加而来的。</p>
<p>由旋转矩阵的几何意义可知：旋转矩阵的<strong>前三列</strong>是旋转后物体<strong>本地坐标的三个轴</strong>。<br>
$$<br>
单位矩阵可以视为物体不做旋转的旋转矩阵：\<br>
R_{\text{初始}} = I = \begin{bmatrix}<br>
1 &amp; 0 &amp; 0 \<br>
0 &amp; 1 &amp; 0 \<br>
0 &amp; 0 &amp; 1 \<br>
\end{bmatrix}\<br>
此时前三列分别为(1,0,0)，(0,1,0),(0,0,1)，分别是x,y,z轴方向\<br>
\<br>
假设物体绕Y轴旋转90°，得到旋转矩阵：\<br>
R = \begin{bmatrix}<br>
0 &amp; 0 &amp; 1 \<br>
0 &amp; 1 &amp; 0 \<br>
-1 &amp; 0 &amp; 0 \<br>
\end{bmatrix}\<br>
物体新X轴方向（第一列）：(0,0,−1)→ 指向世界Z轴负方向\<br>
物体新Y轴方向（第二列）：(0,1,0) → 仍与世界Y轴同向\<br>
物体新Z轴方向（第三列）：(1,0,0) → 指向世界X轴正方\<br>
可以发现旋转矩阵的前三列就是该物体旋转后的本地坐标系的三个轴<br>
$$<br>
所以我们只需要知道摄像机当前的<strong>右向量</strong>、<strong>上向量</strong>和<strong>朝向</strong>（分别表示本地坐标系的x，y，-z方向），即可求出<strong>旋转矩阵R</strong>。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250707174921598.png" alt="image-20250707174921598" style="zoom:50%;" />
<p>因为是先在原点进行旋转，所以<strong>平移矩阵T</strong>直接将变换后的世界坐标和原点坐标相减即可求出。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250707175050664.png" alt="image-20250707175050664" style="zoom:50%;" />
<p>于是我们就可以求出摄像机的变换矩阵及其逆矩阵：</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250707175228123.png" alt="image-20250707175228123" style="zoom:50%;" />
<p>有了摄像机变换矩阵的逆矩阵，我们就可以根据<strong>物体顶点</strong>的<strong>世界坐标系坐标</strong>求出其摄像机坐标系坐标。知道了物体顶点在摄像机坐标系下的坐标后，那么就可以很方便的将物体沿摄像机坐标系的Z轴投影到摄像机屏幕上。</p>
<p>简单来说，<strong>视图变换矩阵</strong>就是将物体顶点坐标从<strong>世界坐标系</strong>转到<strong>摄像机坐标系</strong>下。</p>
<p>我们可以使用glm库的<strong>lookAt</strong>函数生成视图变换矩阵viewMatrix。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;第一个参数eye：当前摄像机所在位置
&#x2F;&#x2F;第二个参数center：当前摄像机看向那个点
&#x2F;&#x2F;第三个参数top：穹顶向量（定义摄像机的“向上”方向,正常摄像机为(0,1,0)，翻转摄像机为(0,-1,0)）
&#x2F;&#x2F;因为我们的摄像机在本地坐标下总是看向-Z方向，所以一般会将摄像机放置到+Z位置
mat4 viewMatrix &#x3D; lookAt(vec3 eye, vec3 center, vec3 top);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="投影变换矩阵（ProjectionMatrix）"><a class="header-anchor" href="#投影变换矩阵（ProjectionMatrix）"></a>投影变换矩阵（ProjectionMatrix）</h3>
<p>投影这个概念在数学中也很常见，就是将三维的物体沿某一坐标轴投影到二维平面上。在三维场景中的物体，必须投影到一块幕布上，才能显示出来。例如打游戏的时候，显示器的屏幕就是一个二维的屏幕，却能显示出三维的游戏场景，就是将场景中的物体最终投影到幕布上才能在二维的显示器屏幕上显示出来。</p>
<p>投影又分为正交投影（Orthographic Projection）和透视投影（Perspective Projection）两种投影方式，两种投影方式都有各自的应用场景。</p>
<p><strong>一、正交投影：</strong></p>
<p>正交投影中不存在人眼的概念，发出的都是平行光，就好比是在一堆物体前用平行光照射到一堵墙上一样。类似数学中立体几何的正视图、俯视图、侧视图那样的效果，无法体现物体间进大远小那种立体感的效果。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250707182324681.png" alt="image-20250707182324681" style="zoom:50%;" />
<p>在正交投影中，我们会定义一个投影盒（left，right，top，bottom，near，far），可以简单理解为物体能够显示的边界范围，oopengl只会显示在投影盒内的物体。</p>
<ul>
<li>
<p>如果物体<strong>全部顶点</strong>都在<strong>投影盒内</strong>，则完整显示物体；</p>
</li>
<li>
<p>如果物体<strong>全部顶点</strong>都在<strong>投影盒外</strong>，则不显示物体；</p>
</li>
<li>
<p>如果物体<strong>部分顶点</strong>在<strong>投影盒外</strong>，则opengl会求出物体与投影盒的交点，只显示投影盒内的部分，就好比物体用刀切去了一部分。</p>
</li>
</ul>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250707184523187.png" alt="image-20250707184523187" style="zoom:40%;" />
<p>投影盒投影面的四个角和屏幕的四个角是一一对应的，但是投影盒的大小是我们自己设置的，而且屏幕中采用的是NDC坐标系，X，Y，Z轴的范围都是[-1, 1]，所以还需要将投影盒内的顶点坐标转为NDC坐标。</p>
<p>不难发现，<strong>投影矩阵</strong>的作用就是将顶点的<strong>摄像机坐标系坐标</strong>转为屏幕上对应的<strong>NDC坐标系坐标</strong>。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250707183541524.png" alt="image-20250707183541524" style="zoom:40%;" />
<p>由于NDC坐标系的范围是[-1, 1]，为了使这些顶点坐标缩放到同样的范围：</p>
<ol>
<li>我们需要先将<strong>投影盒的中心</strong>平移到摄像机坐标系的<strong>原点</strong>，盒内的物体顶点也随着做同样的平移变换。</li>
<li>将投影盒的<strong>长宽高</strong>都缩放为<strong>长度为2</strong>的立方体，盒内的顶点也随着做同样的缩放变换。</li>
</ol>
<p>上面两个步骤<strong>盒内和盒外</strong>的顶点都会<strong>做一样的变换</strong>，只是<strong>盒外的顶点</strong>变换后<strong>仍然在盒外</strong>，会被去除不显示出来。</p>
<p>于是我们就将每个<strong>顶点坐标</strong>从<strong>摄像机坐标系</strong>坐标转换到了<strong>NDC坐标系坐标</strong>。</p>
<p><strong>注意：<strong>在缩放变换矩阵中，x和y方向的缩放因子都是正数，但是</strong>z轴</strong>的缩放因子是<strong>负数</strong>。这是因为opengl中使用的是<strong>右手</strong>坐标系，<strong>屏幕朝外</strong>是z轴正方向；但是NDC坐标系使用的是<strong>左手</strong>坐标系，<strong>屏幕朝内</strong>才是z轴正方向。两个坐标系的<strong>z轴相反</strong>，所以在转换为NDC坐标系时要翻转一下z轴方向。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250707212835860.png" alt="image-20250707212835860" style="zoom:45%;" />
<p>执行完投影变换后就会将顶点继续送入后续管线阶段，后面的过程是opengl自动实现的。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250707213303648.png" alt="image-20250707213303648" style="zoom:50%;" />
<p>在glm库中可以使用rotho函数生成我们的投影变换矩阵orthProjectionMatrix。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;函数的六个参数定义了投影盒的范围，盒内的顶点才会最终显示在屏幕上
mat4 orthProjectionMatrix &#x3D; ortho(float left, float right, float bottom, float top, float zNear, float zFar);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><strong>二、透视投影：</strong></p>
<p>透视投影是符合人眼的效果，前面介绍的摄像机就替代了人眼的功能，可以看到物体间进大远小的效果。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250707182839172.png" alt="image-20250707182839172" style="zoom: 50%;" />
<p>与正交投影一样，透视投影也有一个包裹盒，为了<strong>模仿人眼透视</strong>的功能实现<strong>近大远小</strong>的特点，这个包裹盒是一个<strong>锥体</strong>，叫做<strong>视锥体</strong>。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250707221330591.png" alt="image-20250707221330591" style="zoom: 50%;" />
<p>视锥体也由六个参数控制：</p>
<ul>
<li>可视范围：near，far（表示和摄像机坐标原点的<strong>距离</strong>，均为<strong>正数</strong>）</li>
<li>近平面范围：left，right，top，bottom（表示了近平面可视区域的坐标范围，<strong>可正可负</strong>）</li>
</ul>
<p>和正交投影一样，透视投影也是要将摄像机坐标系转为NDC坐标系，所以要将锥体包裹盒缩放为长度为2的立方体。由于距离摄像机原点越远，可视平面越大，当远平面也缩放到[-1, 1]范围时，远处的顶点坐标必然会缩放更多，也就造成了进大远小的效果。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250707221928121.png" alt="image-20250707221928121" style="zoom:50%;" />
<p>投影是沿z轴投影到xy平面，正交投影在投影时，x，y和z的值都不会变化。但是透视投影的包裹盒是一个锥体，在投影时远平面的坐标投影在近平面时x，y和z的值都会发生变化，不能简单的直接使用，要计算出远平面投影到近平面后的新坐标。</p>
<p>在glm库中我们可以使用perspective函数来创建投影变换矩阵perspectiveProjectionMatrix。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;为了方便使用，将参数简化为了四个来定义视锥体
&#x2F;&#x2F;fov 是y方向的视张角，模拟人眼睁开的角度,角度越大看到的东西越多
&#x2F;&#x2F;aspect 是近平面的横&#x2F;纵百分比，一般使用窗口的width&#x2F;height即可
&#x2F;&#x2F;zNear 是近平面距离摄像机坐标系原点的距离（正数）
&#x2F;&#x2F;zFar 是远平面距离摄像机坐标系原点的距离（正数）
mat4 perspectiveProjectionMatrix &#x3D; perspective(float fov, float aspect, float zNear, float zFar);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250707235241817.png" alt="image-20250707235241817" style="zoom:50%;" />
<p>知道了上述三种变换后，我们最终在vertexShader输出的顶点坐标是经过了完整的模型变换、视图变换和投影变换后的顶点。</p>
<pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl">gl_Position <span class="token operator">=</span> projectionMatrix <span class="token operator">*</span> viewMatrix <span class="token operator">*</span> modelMatrix <span class="token operator">*</span> aPos<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="相机系统"><a class="header-anchor" href="#相机系统"></a>相机系统</h2>
<p>了解了各种变换的原理，我们就可以使用glm提供的生成各个变换矩阵的功能函数创建我们的相机系统了。</p>
<h3 id="系统结构"><a class="header-anchor" href="#系统结构"></a>系统结构</h3>
<p>Camera是控制画面的显示的，而CameraControl是控制Camera移动、旋转和缩放等功能的。</p>
<p>由于投影共有透视投影和正交投影两种，所以派生出了两个子类PerspectiveCamera和OrthographicCamera，分别用来展示透视投影画面（2D）和正交投影画面（3D）。</p>
<p>相机的运动轨迹可以分为<strong>轨迹球</strong>方式和<strong>游戏</strong>方式，前者常在三维设计软件中见到，后者就是游戏中使用的方式，分别对应TraclBallControl和GameControl。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250709181840293.png" alt="image-20250709181840293" style="zoom:50%;" />
<p>相机类包含了定义一个相机所必须的<strong>参数</strong>，以及获取<strong>视图变化矩阵</strong>（viewMatrix）和<strong>投影变换矩阵</strong>（projectionMatrix）的方法。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;-------------------------------------------------Camera.h文件，Camera类是所有相机的父类
#pragma once
#include &quot;..&#x2F;..&#x2F;glframework&#x2F;core.h&quot;
class Camera
&#123;
public:
	Camera();
	~Camera();
    &#x2F;&#x2F;两种相机获取视图矩阵的方式一致
	glm::mat4 getViewMatrix();
    &#x2F;&#x2F;两种相机获取投影矩阵的方式不同，需要子类自己重写
	virtual glm::mat4 getProjectionMatrix();
    &#x2F;&#x2F;两种相机缩放的方式不同，无法在相机控制类中统一控制缩放，写在父类中让子类重写
	virtual void scale(float deltaScale);
public:
    &#x2F;&#x2F;定义一个相机所必须的参数
	&#x2F;&#x2F;摄像机位置
	glm::vec3 mPosition&#123; 0.0f, 0.0f, 1.0f &#125;;
	&#x2F;&#x2F;摄像机本地坐标系的上方向(y轴)
	glm::vec3 mUp&#123; 0.0f, 1.0f, 0.0f &#125;;
	&#x2F;&#x2F;摄像机的右向量(摄像机坐标系的x轴)
	glm::vec3 mRight&#123; 1.0f, 0.0f, 0.0f &#125;;
&#125;;

&#x2F;&#x2F;-------------------------------------------------Camera.cpp文件，各种函数的实现
#include &quot;camera.h&quot;
Camera::Camera()
&#123;&#125;

Camera::~Camera()
&#123;&#125;

glm::mat4 Camera::getViewMatrix()
&#123;
	glm::vec3 front &#x3D; glm::cross(mUp, mRight);
	glm::vec3 center &#x3D; mPosition + front;
	return glm::lookAt(mPosition, center, mUp);
&#125;
&#x2F;&#x2F;如果子类不重写，就默认返回一个单位矩阵，防止出错
glm::mat4 Camera::getProjectionMatrix()
&#123;
	return glm::identity&lt;glm::mat4&gt;();
&#125;

void Camera::scale(float deltaScale)
&#123;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;-------------------------------------------------orthographicCamera.h文件
#pragma once
#include &quot;..&#x2F;..&#x2F;glframework&#x2F;core.h&quot;
#include &quot;camera.h&quot;

class OrthographicCamera :public Camera
&#123;
public:
	OrthographicCamera(float left, float right, float top, float bottom, float near, float far);
	~OrthographicCamera();
	&#x2F;&#x2F;重写父类的获取投影矩阵函数
	glm::mat4 getProjectionMatrix()override;
	&#x2F;&#x2F;重写父类的缩放函数
	void scale(float deltaScale) override;

private:
    &#x2F;&#x2F;投影盒定义所需参数
	float mLeft &#x3D; 0.0f;
	float mRight &#x3D; 0.0f;
	float mTop &#x3D; 0.0f;
	float mBottom &#x3D; 0.0f;
	float mNear &#x3D; 0.0f;
	float mFar &#x3D; 0.0f;

	&#x2F;&#x2F;由于正交摄像机的缩放是对包裹盒的长和高进行缩放，需要变量记录当前的缩放级别
	&#x2F;&#x2F; 透视摄像机的缩放是向前向后移动摄像机实现的，不需要这个参数
	&#x2F;&#x2F;缩放程度 &#x3D; 2^mScale
	float mScale &#x3D; 0.0f;


&#125;;

&#x2F;&#x2F;-------------------------------------------------orthographicCamera.cpp文件，各种函数的实现和父类函数的重写
#include &quot;orthographicCamera.h&quot;

OrthographicCamera::OrthographicCamera(float left, float right, float top, float bottom, float near, float far)
	:mLeft(left), mRight(right), mTop(top), mBottom(bottom), mNear(near), mFar(far)
&#123;

&#125;

OrthographicCamera::~OrthographicCamera()
&#123;

&#125;

glm::mat4 OrthographicCamera::getProjectionMatrix()
&#123;
    &#x2F;&#x2F;正交相机的缩放方式是改变投影盒的长和高
	float x &#x3D; glm::pow(2.0f, mScale);
	return glm::ortho(mLeft * x, mRight * x, mBottom * x, mTop * x, mNear, mFar);
&#125;

void OrthographicCamera::scale(float deltaScale)
&#123;
	&#x2F;&#x2F;随着滚轮的滚动，缩放程度不断累加或累减
	mScale -&#x3D; deltaScale;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;-------------------------------------------------perspectiveCamera.h文件
#pragma once
#include &quot;..&#x2F;..&#x2F;glframework&#x2F;core.h&quot;
#include &quot;camera.h&quot;

class PerspectiveCamera :public Camera
&#123;
public:
	PerspectiveCamera(float fov, float aspect, float near, float far);
	~PerspectiveCamera();

	glm::mat4 getProjectionMatrix()override;
	void scale(float deltaScale) override;
private:
	float mFov &#x3D; 0.0f;
	float mAspect &#x3D; 0.0f;
	float mNear &#x3D; 0.0f;
	float mFar &#x3D; 0.0f;

&#125;;
&#x2F;&#x2F;-------------------------------------------------perspectiveCamera.cpp文件，各种函数的实现和父类函数的重写
#include &quot;perspectiveCamera.h&quot;

PerspectiveCamera::PerspectiveCamera(float fov, float aspect, float near, float far)
	:mFov(fov), mAspect(aspect), mNear(near), mFar(far)
&#123;

&#125;

PerspectiveCamera::~PerspectiveCamera()
&#123;

&#125;

glm::mat4 PerspectiveCamera::getProjectionMatrix()
&#123;
	&#x2F;&#x2F;glm函数使用的角度都是弧度，我们传进来的都是角度，要用radians转换一下
	return glm::perspective(glm::radians(mFov), mAspect, mNear, mFar);
&#125;

void PerspectiveCamera::scale(float deltaScale)
&#123;
    &#x2F;&#x2F;透视投影相机的缩放方式就是向前移动相机
	glm::vec3 front &#x3D; glm::cross(mUp, mRight);
	mPosition +&#x3D; deltaScale * front;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>相机控制类负责<strong>控制相机的运动</strong>，<strong>响应键盘事件</strong>，每当某个事件触发时，该类会根据键鼠操作及时<strong>更新相机的参数</strong>，相机就会用最新的参数创建视图变换矩阵和投影变换矩阵。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;-------------------------------------------------cameraControl.h文件，定义各种事件响应函数来更新相机的参数
#pragma once
#include &quot;..&#x2F;..&#x2F;glframework&#x2F;core.h&quot;
#include &quot;camera.h&quot;
#include &lt;map&gt;

class CameraControl
&#123;
public:
	CameraControl();
	~CameraControl();

	&#x2F;&#x2F;如果子类重写就用子类的，不重写就用父类默认统一的
	virtual void onKey(int key, int action, int mods);
	virtual void onMouse(int button, int action, double xPos, double yPos);
	virtual void onCursor(double xPos, double yPos);
	virtual void onScroll(double xOff, double yOff);

	void update();
	void setCamera(Camera* camera) &#123; mCamera &#x3D; camera; &#125;

protected:
	&#x2F;&#x2F;控制的相机
	Camera* mCamera &#x3D; nullptr;

	&#x2F;&#x2F;鼠标按键状态(记录鼠标左键、右键和中键是否被按下)
	bool mMouseLeftDown &#x3D; false;
	bool mMouseRightDown &#x3D; false;
	bool mMouseMiddleDown &#x3D; false;

	&#x2F;&#x2F;鼠标光标当前位置
	float mCurrentX &#x3D; 0.0f, mCurrentY &#x3D; 0.0f;

	&#x2F;&#x2F;相机旋转灵敏度
	float mSensitivity &#x3D; 0.2f;
	&#x2F;&#x2F;相机平移速度
	float mMoveSpeed &#x3D; 0.005f;


	&#x2F;&#x2F;记录键盘相关按键状态
	std::map&lt;int, bool&gt; mKeyMap;
&#125;;

&#x2F;&#x2F;-------------------------------------------------cameraControl.cpp文件，实现各种函数
#include &quot;cameraControl.h&quot;
#include &lt;iostream&gt;

CameraControl::CameraControl()
&#123;&#125;

CameraControl::~CameraControl()
&#123;&#125;

void CameraControl::onKey(int key, int action, int mods)
&#123;
	&#x2F;&#x2F;只记录第一次按下键的时候，重复按时不考虑，直接退出
	if (action &#x3D;&#x3D; GLFW_REPEAT)return;

	&#x2F;&#x2F;记录当前按键是按下状态还是释放状态
	bool pressrd &#x3D; (action &#x3D;&#x3D; GLFW_PRESS);
	mKeyMap[key] &#x3D; pressrd;
&#125;

void CameraControl::onMouse(int button, int action, double xPos, double yPos)
&#123;
	&#x2F;&#x2F;如果按下鼠标按键，记录此时的光标位置
	bool pressed &#x3D; (action &#x3D;&#x3D; GLFW_PRESS);
	if (pressed)
	&#123;
		mCurrentX &#x3D; xPos;
		mCurrentY &#x3D; yPos;
	&#125;

	&#x2F;&#x2F;更新鼠标按键状态
	switch (button)
	&#123;
	case GLFW_MOUSE_BUTTON_LEFT:
		mMouseLeftDown &#x3D; pressed;
		break;
	case GLFW_MOUSE_BUTTON_RIGHT:
		mMouseRightDown &#x3D; pressed;
		break;
	case GLFW_MOUSE_BUTTON_MIDDLE:
		mMouseMiddleDown &#x3D; pressed;
		break;
	&#125;

&#125;

void CameraControl::onCursor(double xPos, double yPos)
&#123;
	
&#125;

void CameraControl::onScroll(double xOff, double yOff)
&#123;
	
&#125;



void CameraControl::update()
&#123;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="TrackBallCameraController（轨迹球相机控制器）"><a class="header-anchor" href="#TrackBallCameraController（轨迹球相机控制器）"></a>TrackBallCameraController（轨迹球相机控制器）</h3>
<p>用户通过鼠标拖拽（类似在虚拟球面上滑动）来控制相机的旋转，适合自由观察3D物体或场景，在建模软件中经常可以看到这样的移动方式。</p>
<p>这样的实现方式是将相机锁定在一个半径固定的球面上运动，相机始终看向某一个点（一般是原点）。当我们使用鼠标移动时，将鼠标移动的距离转化为相机在对应方向旋转的角度，创建出一个旋转矩阵，对相机的各个参数进行调整。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250709164225962.png" alt="image-20250709164225962" style="zoom:40%;" />
<p>对于相机任意的移动，我们可以将其分解为左右沿纬线运动和上下沿经线运动。</p>
<p>绕着纬线<strong>左右运动</strong>是绕着<strong>世界坐标系的y轴</strong>旋转的，产生的角度叫做<strong>yaw</strong>角（类似人眼左右移动）。当相机绕着球面左右运动时，相机的<strong>position</strong>(位置)、<strong>up</strong>(相机本地坐标系的y轴)、<strong>right</strong>(相机本坐标系的x轴)参数都会<strong>发生变化</strong>，所以左右移动时需要更新这<strong>三</strong>个参数。</p>
<p>绕着经线<strong>上下运动</strong>是绕着<strong>摄像机本地坐标系的x轴</strong>旋转的，产生的角度叫做<strong>pitch</strong>角（类似人眼上下移动）。当相机绕着球面左右运动时，相机的<strong>position</strong>(位置)、<strong>up</strong>(相机本地坐标系的y轴)参数都会<strong>发生变化</strong>，所以上下移动时需要更新这<strong>两</strong>个参数。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250709165319540.png" alt="image-20250709165319540" style="zoom:50%;" />
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;-------------------------------------------------trackBallCameraControl.h文件
#pragma once
#include &quot;..&#x2F;..&#x2F;glframework&#x2F;core.h&quot;
#include &quot;cameraControl.h&quot;

class TrackBallCameraControl:public CameraControl
&#123;
public:
	TrackBallCameraControl();
	~TrackBallCameraControl();
	void onCursor(double xPos, double yPos) override;
	&#x2F;&#x2F;trackBall相机常用于设计软件中，需要滚轮缩放
	&#x2F;&#x2F;game相机一般用于游戏，不需要提供滚轮缩放功能
	void onScroll(double xOff, double yOff) override;
private:

	void yaw(float angle);
	void pitch(float angle);

private:
	&#x2F;&#x2F;相机缩放速度
	float mScaleSpeed &#x3D; 0.2f;

&#125;;

&#x2F;&#x2F;-------------------------------------------------trackBallCameraControl.cpp文件，实现各种函数
#include &quot;trackBallCameraControl.h&quot;

TrackBallCameraControl::TrackBallCameraControl()
&#123;
&#125;

TrackBallCameraControl::~TrackBallCameraControl()
&#123;
&#125;

void TrackBallCameraControl::onCursor(double xPos, double yPos)
&#123;
	if (mMouseLeftDown)
	&#123;
		&#x2F;&#x2F;计算两个方向移动的旋转角度
		float deltaX &#x3D; (mCurrentX - xPos) * mSensitivity;
		float deltaY &#x3D; (mCurrentY - yPos) * mSensitivity;

		&#x2F;&#x2F;分别计算两个方向的旋转
		yaw(deltaX);
		pitch(deltaY);
	&#125;
	else if (mMouseMiddleDown)
	&#123;
		float deltaX &#x3D; (mCurrentX - xPos) * mMoveSpeed;
		float deltaY &#x3D; (mCurrentY - yPos) * mMoveSpeed;

		mCamera-&gt;mPosition +&#x3D; deltaX * mCamera-&gt;mRight;
		mCamera-&gt;mPosition +&#x3D; -deltaY * mCamera-&gt;mUp;
	&#125;

	mCurrentX &#x3D; xPos;
	mCurrentY &#x3D; yPos;
&#125;

void TrackBallCameraControl::onScroll(double xOff, double yOff)
&#123;
	mCamera-&gt;scale(mScaleSpeed * yOff);
&#125;
&#x2F;&#x2F;因为每次旋转后新参数都保存到了相机里，所以这是一个增量式的改变
&#x2F;&#x2F;更新左右移动时变化的参数
void TrackBallCameraControl::yaw(float angle)
&#123;
	&#x2F;&#x2F;根据旋转角度绕世界坐标系的y轴旋转，创造旋转矩阵
	glm::mat4 rotation &#x3D; glm::rotate(glm::identity&lt;glm::mat4&gt;(), (float)glm::radians(angle), glm::vec3(0.0f, 1.0f, 0.0f));
	&#x2F;&#x2F;更新参数(相机旋转时本地坐标轴和位置也做同等旋转)
	mCamera-&gt;mPosition &#x3D; rotation * glm::vec4(mCamera-&gt;mPosition, 1.0f);
	mCamera-&gt;mUp &#x3D; rotation * glm::vec4(mCamera-&gt;mUp, 0.0f);
	mCamera-&gt;mRight &#x3D; rotation * glm::vec4(mCamera-&gt;mRight, 0.0f);
&#125;
&#x2F;&#x2F;更新上下移动时变化的参数
void TrackBallCameraControl::pitch(float angle)
&#123;
	&#x2F;&#x2F;根据旋转角度绕本地坐标系的x轴旋转，创造旋转矩阵
	glm::mat4 rotation &#x3D; glm::rotate(glm::identity&lt;glm::mat4&gt;(), (float)glm::radians(angle), mCamera-&gt;mRight);
	&#x2F;&#x2F;更新参数(上下移动时产生的旋转，不改变本地坐标系的x轴，故不用更新right向量)
	mCamera-&gt;mPosition &#x3D; rotation * glm::vec4(mCamera-&gt;mPosition, 1.0f);
	mCamera-&gt;mUp &#x3D; rotation * glm::vec4(mCamera-&gt;mUp, 0.0f);
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="GameCameraController（游戏相机控制器）"><a class="header-anchor" href="#GameCameraController（游戏相机控制器）"></a>GameCameraController（游戏相机控制器）</h3>
<p>游戏相机控制器可以类比第一人称游戏，可以使用WASD键进行前后左右移动，按下鼠标右键时可以转动视角。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250709214146965.png" alt="image-20250709214146965" style="zoom:50%;" />
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;-------------------------------------------------gameCameraControl.h文件
#pragma once
#include &quot;..&#x2F;..&#x2F;glframework&#x2F;core.h&quot;
#include &quot;cameraControl.h&quot;

class GameCameraControl:public CameraControl
&#123;
public:
	GameCameraControl();
	~GameCameraControl();

	void onKey(int key, int action, int mods) override;
	void onCursor(double xPos, double yPos) override;

private:
	&#x2F;&#x2F;pitch是控制上下角度的，范围是[-90,90]
	float mPitch &#x3D; 0.0f;
	float mSpeed &#x3D; 0.02f;

private:
	void pitch(float angle);
	void yaw(float angle);

&#125;;

&#x2F;&#x2F;-------------------------------------------------gameCameraControl.cpp文件
#include &quot;gameCameraControl.h&quot;

GameCameraControl::GameCameraControl()
&#123;

&#125;

GameCameraControl::~GameCameraControl()
&#123;

&#125;

&#x2F;&#x2F;控制移动
void GameCameraControl::onKey(int key, int action, int mods)
&#123;
    &#x2F;&#x2F;因为重写了父类函数，需要先调用父类的函数获取按键状态
	CameraControl::onKey(key, action, mods);
	
    &#x2F;&#x2F;考虑到会同时按下多个按键移动，使用direction作为最终的方向，按下哪个键就叠加对应的方向
	glm::vec3 direction(0.0f);
	glm::vec3 front &#x3D; glm::cross(mCamera-&gt;mUp, mCamera-&gt;mRight);
	glm::vec3 right &#x3D; mCamera-&gt;mRight;
	&#x2F;&#x2F;同时按下多键，叠加最终方向
	if (mKeyMap[GLFW_KEY_W])
	&#123;
		direction +&#x3D; front;
	&#125;
	if (mKeyMap[GLFW_KEY_S])
	&#123;
		direction -&#x3D; front;
	&#125;
	if (mKeyMap[GLFW_KEY_A])
	&#123;
		direction -&#x3D; right;
	&#125;
	if (mKeyMap[GLFW_KEY_D])
	&#123;
		direction +&#x3D; right;
	&#125;
	if (mKeyMap[GLFW_KEY_SPACE])
	&#123;
		direction +&#x3D; glm::vec3(0.0f, 1.0f, 0.0f);
	&#125;
	if (mKeyMap[GLFW_KEY_LEFT_SHIFT])
	&#123;
		direction -&#x3D; glm::vec3(0.0f, 1.0f, 0.0f);
	&#125;
	&#x2F;&#x2F;只有非零向量才可以归一化，否则会出错
	if (glm::length(direction) &#x3D;&#x3D; 0)return;
	&#x2F;&#x2F;单位向量叠加后的长度不为1，要归一化后再运算
	mCamera-&gt;mPosition +&#x3D; glm::normalize(direction) * mSpeed;
&#125;

&#x2F;&#x2F;控制旋转
void GameCameraControl::onCursor(double xPos, double yPos)
&#123;
	if (mMouseRightDown)
	&#123;
		float deltaX &#x3D; (mCurrentX - xPos) * mSensitivity;
		float deltaY &#x3D; (mCurrentY - yPos) * mSensitivity;
		mPitch +&#x3D; deltaY;
		&#x2F;&#x2F;控制pitch角度的范围（-90，90）
		if (mPitch &gt; 89.0f || mPitch &lt; -89.0f)
		&#123;
			&#x2F;&#x2F;加上此时的角度为不合法，此时需要再减去这个角度撤回累加
			mPitch -&#x3D; deltaY;
			pitch(0);
		&#125;
		else
			pitch(deltaY);

		yaw(deltaX);
		

	&#125;

	mCurrentX &#x3D; xPos;
	mCurrentY &#x3D; yPos;
&#125;


void GameCameraControl::pitch(float angle)
&#123;
	&#x2F;&#x2F;根据旋转角度绕世界坐标系的y轴旋转，创造旋转矩阵
	glm::mat4 rotation &#x3D; glm::rotate(glm::identity&lt;glm::mat4&gt;(), (float)glm::radians(angle), mCamera-&gt;mRight);
	&#x2F;&#x2F;更新参数(相机旋转时本地坐标轴和位置也做同等旋转)
	mCamera-&gt;mUp &#x3D; rotation * glm::vec4(mCamera-&gt;mUp, 0.0f);
&#125;
void GameCameraControl::yaw(float angle)
&#123;
	&#x2F;&#x2F;根据旋转角度绕世界坐标系的y轴旋转，创造旋转矩阵
	glm::mat4 rotation &#x3D; glm::rotate(glm::identity&lt;glm::mat4&gt;(), (float)glm::radians(angle), glm::vec3(0.f, 1.0f, 0.0f));
	&#x2F;&#x2F;更新参数(相机旋转时本地坐标轴和位置也做同等旋转)
	mCamera-&gt;mRight &#x3D; rotation * glm::vec4(mCamera-&gt;mRight, 0.0f);
	mCamera-&gt;mUp &#x3D; rotation * glm::vec4(mCamera-&gt;mUp, 0.0f);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="深度检测"><a class="header-anchor" href="#深度检测"></a>深度检测</h2>
<p>opengl中默认使用的绘制算法是<strong>画家算法</strong>，就像画画一样，先绘制的会被后绘制的遮挡住。这里的遮挡关系只和物体的绘制顺序有关，和距离摄像机远近没有关系。</p>
<p>在3维世界中，同一个地点，必然是距离摄像机近的物体会遮盖住距离摄像机远的物体。</p>
<p>就像下图所示，右边的三角形Z值为-1，左边的三角形Z值为0，在两个三角形重叠部分，应该是距离我们更近的左侧三角形露出来，但是却被右边的三角形遮盖住了，这显然是不合理的。之所以会出现这样的情况，是我们使用的是opengl默认的画家算法，右侧三角形是后绘制的，所以才遮盖住了左侧的三角形。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250709222709081.png" alt="image-20250709222709081" style="zoom:50%;" />
<h3 id="深度值"><a class="header-anchor" href="#深度值"></a>深度值</h3>
<p>为了解决这个问题，我们需要知道每个点距离摄像机的远近，这个值在opengl中叫做<strong>深度值</strong>(Depth)：表示当前绘制的Fragment（片元）<strong>距离相机的远近程度</strong>。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250709224250490.png" alt="image-20250709224250490" style="zoom:50%;" />
<h3 id="深度值插值"><a class="header-anchor" href="#深度值插值"></a>深度值插值</h3>
<p>我们得到了每个顶点的深度值后，需要进行插值计算出所有片元的深度值。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250709224516084.png" alt="image-20250709224516084" style="zoom:50%;" />
<h3 id="深度值检测"><a class="header-anchor" href="#深度值检测"></a>深度值检测</h3>
<p>创建一块和屏幕大小一样的缓存，存储每个像素的深度值。如果当前像素的深度值比缓存中的大，那么用新的颜色填充这个像素，同时更新该像素块的最小深度值。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250709225020623.png" alt="image-20250709225020623" style="zoom:50%;" />
<p>下面就是深度检测算法（Z-buffer算法）的伪代码：</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20240118132918032-1764076699327-1.png" alt="image-20240118132918032" style="zoom: 50%;" />
<h3 id="在opengl中开启和配置深度检测"><a class="header-anchor" href="#在opengl中开启和配置深度检测"></a>在opengl中开启和配置深度检测</h3>
<p>glEnable和glDisable函数允许我们启用或禁用某个OpenGL功能。这个功能会一直保持启用/禁用状态，直到另一个调用来禁用/启用它。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;1. 使用glEnable函数开启opengl的深度测试功能
glEnable(GL_DEPTH_TEST);

&#x2F;&#x2F;2. 设置深度测试方法(满足什么要求的片元才算通过深度测试)
&#x2F;&#x2F;策略有很多,GL_LESS就是上面介绍的深度值小的片元才能通过测试
glDepthFunc(GL_LESS);

&#x2F;&#x2F;3. 在每一帧清理画布颜色时也要清理深度缓存(默认将深度缓冲清理为1.0)
glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
&#x2F;&#x2F;也可以使用这个函数指定清理深度缓冲时设置的值
glCLearDepth(float val);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250709225839392.png" alt="image-20250709225839392" style="zoom:50%;" />
<h3 id="控制深度值写入权限"><a class="header-anchor" href="#控制深度值写入权限"></a>控制深度值写入权限</h3>
<p><strong>glDepthMask(GLboolean flag)</strong> 是 OpenGL 中用于控制深度缓冲区（Depth Buffer）写入状态的函数，它决定是否允许将片元（Fragment）的深度值写入深度缓冲区。</p>
<ul>
<li>当设置<strong>glDepthMask(GL_TRUE)<strong>时，此时是</strong>允许</strong>片元的深度值<strong>写入深度缓冲</strong>，是一般情况下的默认状态。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;允许写入深度缓冲
&#x2F;&#x2F;1.判断当前片元深度值是否小于此处深度缓冲区存入的深度值
if (z &lt; z-buffer[x,y,z])
&#123;
    &#x2F;&#x2F;2.如果深度值更小，这个像素的颜色变为该片元的颜色
    frameBuffer[x,y,z] &#x3D; rgb;
    &#x2F;&#x2F;3.将该片元的更小的深度值存入深度缓冲区
    z-buffer[x,y,z] &#x3D; z;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>当设置<strong>glDepthMask(GL_FALSE)<strong>时，此时是</strong>不允许</strong>片元的深度值<strong>写入深度缓冲</strong>。此时即使调用glClear( GL_DEPTH_BUFFER_BIT)函数也无法将深度缓冲区的值重置为1，因为当前深度缓存区已经禁止写入了。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;不允许写入深度缓冲
&#x2F;&#x2F;1.判断当前片元深度值是否小于此处深度缓冲区存入的深度值
if (z &lt; z-buffer[x,y,z])
&#123;
    &#x2F;&#x2F;2.如果深度值更小，这个像素的颜色变为该片元的颜色
    frameBuffer[x,y,z] &#x3D; rgb;
    &#x2F;&#x2F;不允许写入深度缓冲区将不会有这一步
    &#x2F;&#x2F;z-buffer[x,y,z] &#x3D; z;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下图左边是构建的测试场景，此时默认是允许写入深度缓冲区的，三个平面的遮盖关系可以正常显示。</p>
<p>下图右则是绘制<strong>box_specular</strong>时设置<strong>glDepthMask(GL_FALSE)</strong>，另外两个都是glDepthMask(GL_TRUE)，可以看到原先笑脸被遮盖住的部分全部都绘制出来了。这是因为在绘制box_specular时并没有写入深度缓存，所以二者重叠的部分深度缓存区的值仍然为1（或者其他表示无穷大的值）；当绘制笑脸时进行深度值比较时会直接和1比较，自然会显示出。（一般这种效果常常用来绘制透明物体）。</p>
<p>​                                      <img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250720202457242.png" alt="image-20250720202457242" style="zoom: 50%; display: inline;" /><img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250720202704709.png" alt="image-20250720202704709" style="zoom:50%;display: inline;" /></p>
<h3 id="zFighting（深度冲突）"><a class="header-anchor" href="#zFighting（深度冲突）"></a>zFighting（深度冲突）</h3>
<p>Z-Fighting（深度冲突）是计算机图形学中一种常见的渲染问题，表现为两个或多个表面在深度缓冲区（Z-Buffer）中具有<strong>非常接近或相同的深度值</strong>，导致GPU在深度测试时无法确定哪个表面应该被渲染，最终产生闪烁或交替覆盖的视觉瑕疵。</p>
<p>下图中两个平面之间的z轴距离仅为0.0000001个单位距离，当两个物体<strong>过于靠近</strong>时，由于计算机中浮点数<strong>精度有限</strong>，会导致深度缓存区对应两者深度值的比较出现问题，进而产生交替覆盖的现象。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250720204846469.png" alt="image-20250720204846469" style="zoom:50%;" />
<p>为了解决这一问题，我们可以使用<strong>更高的精度来处理深度缓存区的数据</strong>或者将<strong>两个物体的深度值进行调整让他们靠的不那么近</strong>。前者显然治标不治本，后者就可以使用opengl提供的<strong>polygonOffset</strong>函数实现。</p>
<p>polygonOffset函数<strong>只调整物体的深度值</strong>，但是并<strong>不改变物体的位置</strong>。（zFighting问题的本质就是物体的深度值太过接近无法精准判断，将深度值拉开差距即可）。</p>
<p>和深度测试一样，需要先使用glEnable开启该功能，在调用polygonOffset函数具体调整。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250720205851884.png" alt="image-20250720205851884" style="zoom:50%;" />
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250720205820673.png" alt="image-20250720205820673" style="zoom:50%;" />
<p>造成zFighting现象的会有两种情况：</p>
<ol>
<li>两个正常物体<strong>距离太过接近</strong>而产生zFighting现象</li>
<li>两个物体距离正常，但是会随着<strong>倾斜</strong>产生zFighting现象</li>
</ol>
<p>所以polygonOffset的第一个参数主要是为了解决倾斜问题的，第二个参数主要为了解决情况1的。</p>
<ul>
<li>当物体靠太近时，我们可以调整物体的深度值。但是当场景中的物体非常多时，对物体深度值的调整有可能会造成其他物体产生zFighting现象。所以对物体深度值的调整要尽可能的小，所以参数<strong>units要和数据最小值相乘，最小限度地调整深度值</strong>。</li>
<li>对于倾斜产生的zFighting现象，由深度值和z坐标的关系可知：距离镜头远的部分深度变换不明显，更容易产生zFighting现象，近处则不容易产生。所以可以将远处的部分多偏移一些，近处的部分少偏移一些就能解决这一问题。</li>
</ul>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250720211158975.png" alt="image-20250720211158975" style="zoom:50%;" />
<p>对于两个像素而言，倾斜放倒后，两个像素之间的深度值变化率较大（初始在一个平面，放倒后产生较大的深度值差距，且像素间的距离由于进大远小而缩小），距离镜头近的部分像素间深度变化率较小，于是就能根据深度变化率判断像素距离摄像机远近。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250720211820440.png" alt="image-20250720211820440" style="zoom:50%;" />
<h1 id="OpenGL中级"><a class="header-anchor" href="#OpenGL中级"></a>OpenGL中级</h1>
<h2 id="代码框架"><a class="header-anchor" href="#代码框架"></a>代码框架</h2>
<h2 id="光照"><a class="header-anchor" href="#光照"></a>光照</h2>
<p>在介绍光照之前，先简单说明一下颜色。对应<strong>光</strong>来说，颜色表示红绿蓝三种<strong>光的强度</strong>，对于一个<strong>物体</strong>来说，颜色表示对红绿蓝三种光的<strong>反射百分比</strong>。</p>
<p>所以<strong>反射光的颜色 = 光照颜色 * 物体颜色</strong>（因为人眼之所以能看到物体，就是靠反射光线进入人眼）。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250710210728390.png" alt="image-20250710210728390" style="zoom:50%;" />
<h3 id="光照类型"><a class="header-anchor" href="#光照类型"></a>光照类型</h3>
<h4 id="漫反射光（diffuse）"><a class="header-anchor" href="#漫反射光（diffuse）"></a>漫反射光（diffuse）</h4>
<p>漫反射是光从一定角度入射之后从入射点向四面八方反射，且每个不同方向反射的光的强度相等，而产生漫反射的原因是物体表面的粗糙，光线照射到粗糙表面后向<strong>各个方向均匀散射</strong>。从任何角度看亮度相同，与<strong>视线方向无关</strong>。</p>
<p>漫反射光是光线照射在物体身上后经过一次反射的光，漫反射光会使物体在光线下产生立体感。因为在计算漫反射光时，只需考虑光照方向和该点的法线方向即可，所以物体的不同区域由于跟光线角度不同，会出现明暗区域的平滑过渡，这种明亮变化就能是人看到立体感。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250710212933232.png" alt="image-20250710212933232" style="zoom:50%;" />
<p>下面介绍一下漫反射光的计算：</p>
<p>光的反射可以理解为光照射在物体表面，物体表面吸收部分光能后释放出去的过程（物体颜色的本质就是物体吸收光能后释放出去的百分比）。为此我们需要计算出一束光照射在物体表面时，物体能吸收多少光。</p>
<p>物体吸收光的多少与其接收到光照的面积有关，当物体表面倾斜一定角度时，需要计算表面面积的投影。</p>
<p>如下图所示，对于一格像素来说，当表面与光线倾角为theat时，吸收的光为<strong>power = light * cos(theta)</strong>。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250710215752130.png" alt="image-20250710215752130" style="zoom:40%;" />
<p>计算出吸收的光后，根据颜色就是物体反射光的百分比这一结论可知，最终反射出去的光为<strong>out = power * objectColor</strong>。</p>
<p>所以最终漫反射的反射光颜色为<strong>diffuseColor = lightColor * cos(θ) * objectColor</strong>。</p>
<p>还有一个问题就是我们如何计算倾角theta？</p>
<p>只要知道了物体表面一点的<strong>法线向量</strong>（normal），我们就能根据法线向量和光线方向两个向量计算出夹角theta。法线向量需要作为每一个顶点的顶点属性给出，这样所有像素的法线向量都会经过插值算法自动计算出来。</p>
<p>当法线向量和光线方向向量都是归一化的向量后，就可以利用向量点乘公式直接计算出<strong>cos(theta) = dot(-lightDir, normal)</strong>。</p>
<p>因为光线方向是从光源指向物体表面的，所以要正确计算出theta角，需要使用光线方向的反方向，如下图所示。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250710220204952.png" alt="image-20250710220204952" style="zoom:40%;" />
<pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">460</span> core</span></span>
<span class="token keyword">out</span> <span class="token keyword">vec4</span> FragColor<span class="token punctuation">;</span>

<span class="token keyword">in</span> <span class="token keyword">vec2</span> uv<span class="token punctuation">;</span>
<span class="token comment">//接收法线向量</span>
<span class="token keyword">in</span> <span class="token keyword">vec3</span> normal<span class="token punctuation">;</span>

<span class="token keyword">uniform</span> <span class="token keyword">sampler2D</span> sampler<span class="token punctuation">;</span>
<span class="token comment">//使用代码设置平行光的参数</span>
<span class="token keyword">uniform</span> <span class="token keyword">vec3</span> lightDirection<span class="token punctuation">;</span>
<span class="token keyword">uniform</span> <span class="token keyword">vec3</span> lightColor<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>

	<span class="token comment">//1. 对数据进行归一化</span>
	<span class="token keyword">vec3</span> normalN <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>normal<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">vec3</span> lightDirectionN <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>lightDirection<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//2. 获取该点颜色(shader中不允许将四维向量赋值给三维向量)</span>
	<span class="token keyword">vec3</span> objColor <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>sampler<span class="token punctuation">,</span> uv<span class="token punctuation">)</span><span class="token punctuation">.</span>xyz<span class="token punctuation">;</span>

	<span class="token comment">//3. 计算光线和法向量之间的夹角余弦值(颜色不能出现负数，要使用clamp函数控制在0到1之间)</span>
	<span class="token keyword">float</span> cosTheta <span class="token operator">=</span> <span class="token function">clamp</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span><span class="token operator">-</span>lightDirectionN<span class="token punctuation">,</span> normalN<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//4. 计算漫反射光颜色(lightColor * cosTheta)表示该点吸收了多少光，再乘以objColor表示反射了多少光，就是最终反射光的颜色</span>
	<span class="token keyword">vec3</span> diffuse <span class="token operator">=</span> lightColor <span class="token operator">*</span> cosTheta <span class="token operator">*</span> objColor<span class="token punctuation">;</span>
	
	<span class="token comment">//返回最终的颜色</span>
	FragColor <span class="token operator">=</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span>diffuse<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="镜面反射光（specular）"><a class="header-anchor" href="#镜面反射光（specular）"></a>镜面反射光（specular）</h4>
<p>对于一个表面光滑的物体来说，当<strong>反射光</strong>的光线和<strong>人眼</strong>观看方向接近时，会产生刺眼的<strong>高光斑点</strong>，叫做镜面反射光。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250710213413431.png" alt="image-20250710213413431" style="zoom:67%;" />
<p>最终我们将三种光照叠加到一起，就模拟出了物体的光照情况。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250710213513238.png" alt="image-20250710213513238" style="zoom:50%;" />
<p>当一束光照射在光滑物体表面时，由物理知识可知，光线会被反射回去，且入射角等于反射角。由于表面光滑，光线并不会像漫反射那样均匀地向四面八方反射，而是主要集中在反射方向上（因为不存在绝对光滑，所以不可能只向一个方向反射，所以在不同的方向观察都能或多或少看见高光）。</p>
<p>当人眼朝不同的方向朝该点看去，视线方向和反射方向之间会有一个夹角，夹角越小就说明反射光的方向越解决人眼，所以此时产生的高光也更强。于是我们可以使用<strong>视线方向</strong>和<strong>反射方向</strong>之间的<strong>夹角</strong>来作为<strong>衡量高光大小的标准</strong>。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250711162255618.png" alt="image-20250711162255618" style="zoom:50%;" />
<p>为了计算镜面反射光，我们除了需要知道<strong>光照方向</strong>和<strong>法线</strong>，还需要知道此时的<strong>视线方向</strong>。</p>
<p>为了求出视线方向，我们需要知道每个<strong>像素的世界坐标位置</strong>和<strong>摄像机的世界坐标位置</strong>，前者在shader中就可以拿到，后者需要使用代码赋值到shader的uniform变量中。</p>
<pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token comment">//-------------------------------------------------------------vs</span>
<span class="token comment">//1. 为了获取每个像素的世界坐标位置，我们要把vertexShader拿到的坐标经过模型变换后传递给fragmentShader中</span>
<span class="token keyword">layout</span><span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token keyword">vec3</span> aPosition<span class="token punctuation">;</span>

<span class="token keyword">uniform</span> <span class="token keyword">mat4</span> model<span class="token punctuation">;</span>
<span class="token keyword">uniform</span> <span class="token keyword">mat4</span> view<span class="token punctuation">;</span>
<span class="token keyword">uniform</span> <span class="token keyword">mat4</span> projection<span class="token punctuation">;</span>

<span class="token keyword">out</span> <span class="token keyword">vec3</span> worldPosition<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">vec4</span> position <span class="token operator">=</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span>aPosition<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//计算当前顶点的世界坐标，并传递给fragmentShader</span>
	worldPosition <span class="token operator">=</span> <span class="token punctuation">(</span>model <span class="token operator">*</span> position<span class="token punctuation">)</span><span class="token punctuation">.</span>xyz<span class="token punctuation">;</span>

	gl_Position <span class="token operator">=</span> projection <span class="token operator">*</span> view <span class="token operator">*</span> model <span class="token operator">*</span> position<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//-------------------------------------------------------------fs</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">460</span> core</span></span>
<span class="token keyword">out</span> <span class="token keyword">vec4</span> FragColor<span class="token punctuation">;</span>

<span class="token keyword">in</span> <span class="token keyword">vec2</span> uv<span class="token punctuation">;</span>
<span class="token keyword">in</span> <span class="token keyword">vec3</span> normal<span class="token punctuation">;</span>
<span class="token comment">//2. 接收vertexShader中传来的像素世界坐标</span>
<span class="token keyword">in</span> <span class="token keyword">vec3</span> worldPosition<span class="token punctuation">;</span>

<span class="token keyword">uniform</span> <span class="token keyword">sampler2D</span> sampler<span class="token punctuation">;</span>
<span class="token keyword">uniform</span> <span class="token keyword">vec3</span> lightDirection<span class="token punctuation">;</span>
<span class="token keyword">uniform</span> <span class="token keyword">vec3</span> lightColor<span class="token punctuation">;</span>
<span class="token comment">//2. 为了获取摄像机的世界坐标系，需要在fragmentShader中设置uniform变量接收摄像机的坐标</span>
<span class="token keyword">uniform</span> <span class="token keyword">vec3</span> cameraPosition<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>

	<span class="token comment">//归一化</span>
	<span class="token keyword">vec3</span> normalN <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>normal<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">vec3</span> lightDirectionN <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>lightDirection<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//采样该点颜色(shader中不允许将四维向量赋值给三维向量)</span>
	<span class="token keyword">vec3</span> objColor <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>sampler<span class="token punctuation">,</span> uv<span class="token punctuation">)</span><span class="token punctuation">.</span>xyz<span class="token punctuation">;</span>

	<span class="token comment">//计算漫反射光</span>
	<span class="token comment">//计算光线和法向量之间的夹角余弦值(颜色不能出现负数，要控制在0到1之间)</span>
	<span class="token keyword">float</span> diffuse <span class="token operator">=</span> <span class="token function">clamp</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span><span class="token operator">-</span>lightDirectionN<span class="token punctuation">,</span> normalN<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//(lightColor * diffuse)表示该点吸收了多少光，再乘以objColor表示反射了多少光，就是最终反射光的颜色</span>
	<span class="token keyword">vec3</span> diffuseColor <span class="token operator">=</span> lightColor <span class="token operator">*</span> diffuse <span class="token operator">*</span> objColor<span class="token punctuation">;</span>
	
	<span class="token comment">//计算镜面反射光</span>
	<span class="token comment">//3. 计算视线方向(像素坐标-相机坐标)</span>
	<span class="token keyword">vec3</span> viewDirection <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>worldPosition <span class="token operator">-</span> cameraPosition<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//4. 计算反射光方向(reflect输入光照方向和法线方向会输出反射方向)</span>
	<span class="token keyword">vec3</span> reflectDirection <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span><span class="token function">reflect</span><span class="token punctuation">(</span>lightDirectionN<span class="token punctuation">,</span> normalN<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//5. 计算镜面反射光颜色</span>
	<span class="token keyword">float</span> specular <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span><span class="token operator">-</span>viewDirection<span class="token punctuation">,</span> reflectDirection<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">vec3</span> specularColor <span class="token operator">=</span> lightColor <span class="token operator">*</span> specular<span class="token punctuation">;</span>

	<span class="token comment">//使用texture函数选择一个采样器在指定uv坐标上采样，获取一个四维向量(rgba)</span>
	FragColor <span class="token operator">=</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span>diffuseColor <span class="token operator">+</span> specularColor<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果直接使用上面的代码，会出现一个问题。上面代码的光照方向为斜45度照向左下角的平行光，所以立方体的左下角会因为照射不到光照而变成黑色，但是在移动过程中会发现黑色阴影处出现了反射高光，这显然是不合理的。</p>
<p>这是因为我们计算时并未判断光照方向是从物体正面照射来的还是反面照射来的，而是直接将光照方向和反射光方向进行计算，导致阴影处出现高光。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250711173252647.png" alt="image-20250711173252647" style="zoom:33%;" />
<p>通过观察可以发现，如果光照方向是从背面照射到该点，那么光照方向的反方向和法线的夹角是一个钝角，可以利用这一点在shader中进行判断，从而提出背面的反射高光。</p>
<p>在shader中使用if else语句会损失性能，所以使用<strong>step</strong>函数实现判断功能。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250711172720468.png" alt="image-20250711172720468" style="zoom:50%;" />
<pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token comment">//处理背面高光线性</span>
<span class="token keyword">float</span> flag <span class="token operator">=</span> <span class="token function">step</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token function">dot</span><span class="token punctuation">(</span><span class="token operator">-</span>lightDirectionN<span class="token punctuation">,</span> normalN<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//使用texture函数选择一个采样器在指定uv坐标上采样，获取一个四维向量(rgba)</span>
FragColor <span class="token operator">=</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span>diffuse <span class="token operator">+</span> specular <span class="token operator">*</span> flag<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>添加代码后背面的高光就会被消除了。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250711173649961.png" alt="image-20250711173649961" style="zoom: 50%;" />
<p>通过上面的演示图可以看到，我们的镜面反射光有时会将高光铺满整个立方体面，着显然是不太合理的，我们希望看到的是一小块区域更集中的高光光斑。</p>
<p>代码中控制高光的是<strong>max(dot(-viewDirection, reflectDirection), 0.0)</strong>，其大致函数曲线大致形状类似于<strong>cos</strong>函数曲线。在曲线中我们可以看到，随着<strong>夹角的增大</strong>虽然<strong>值会变小</strong>，但是值<strong>不为0</strong>还是会<strong>出现高光</strong>，这就导致我们的高光范围比较大，不集中。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250711174907035.png" alt="image-20250711174907035" style="zoom:50%;" />
<p>如果我们为这个函数加上一个指数，变成y = a^x形式，由于取值范围是0到1，所以函数图形会随着指数的增大而变得更瘦，这就会让我们的高光变得更近集中，只会在看向点的附近出现集中的高光。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250711175326221.png" alt="image-20250711175326221" style="zoom:50%;" />
<p>将计算镜面反射光的代码按这样修改后就会形成区域集中的小范围光斑了。</p>
<pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token comment">//计算镜面反射光</span>
<span class="token comment">//计算视线方向</span>
<span class="token keyword">vec3</span> viewDirection <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>worldPosition <span class="token operator">-</span> cameraPosition<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//计算反射光方向</span>
<span class="token keyword">vec3</span> reflectDirection <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span><span class="token function">reflect</span><span class="token punctuation">(</span>lightDirectionN<span class="token punctuation">,</span> normalN<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//计算镜面反射光颜色</span>
<span class="token keyword">float</span> specular <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span><span class="token operator">-</span>viewDirection<span class="token punctuation">,</span> reflectDirection<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">vec3</span> specularColor <span class="token operator">=</span> lightColor <span class="token operator">*</span> <span class="token function">pow</span><span class="token punctuation">(</span>specular<span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//处理背面高光线性</span>
<span class="token keyword">float</span> flag <span class="token operator">=</span> <span class="token function">step</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token function">dot</span><span class="token punctuation">(</span><span class="token operator">-</span>lightDirectionN<span class="token punctuation">,</span> normalN<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250711175825796.png" alt="image-20250711175825796" style="zoom:50%;" />
<p>对于这样一个箱子，中间部分都是木头材质的，显然不可能像上面那样出现高光。正常情况下只会在箱子边的一圈金属部分才会出现高光，中间的木头部分不应该出现高光。为了实现这种效果，可以使用**镜面高光贴图（高光蒙版）**进行采样。</p>
<p>下图就是这个盒子纹理贴图所对应的镜面高光贴图，可以看到这张贴图是一个黑和白两种颜色的<strong>灰度图</strong>（<strong>rgb三个通道值一样</strong>），不难发现，中心的木头部分三个通道均为0，外侧金属部分的通道值也都在(0,1)之间。于是，我们可以对镜面高光贴图在shader中采样，三个通道的任一通道的值都可以看做这一点的镜面反射高光的强度。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250715202030389.png" alt="image-20250715202030389" style="zoom:40%;" />
<pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token comment">//在fragmentShader中新增采样器，专门采样镜面反射贴图</span>
<span class="token keyword">uniform</span> <span class="token keyword">sampler2D</span> specularSampler<span class="token punctuation">;</span>

<span class="token comment">//采样镜面反射贴图的颜色</span>
<span class="token keyword">vec3</span> specularMaskColor <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>specularSampler<span class="token punctuation">,</span> uv<span class="token punctuation">)</span><span class="token punctuation">.</span>xyz<span class="token punctuation">;</span>

<span class="token comment">//将最终的镜面反射光颜色乘以采样颜色的任一通道值</span>
FragColor <span class="token operator">=</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span>diffuseColor <span class="token operator">+</span> specularColor <span class="token operator">*</span> flag <span class="token operator">*</span> specularMaskColor<span class="token punctuation">.</span>x <span class="token operator">+</span> ambientColor<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>修改代码后可以看到，高光只出现在了金属部分，木头部分的高光已经消失了。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250715202631908.png" alt="image-20250715202631908" style="zoom:33%;" />
<h4 id="环境光（ambient）"><a class="header-anchor" href="#环境光（ambient）"></a>环境光（ambient）</h4>
<p>假设在一个场景中多个物体，那么对于一个物体来说，接收到的不止有阳光，还有经过其他物体多次反射的光，叫做环境光。环境光会将物体本身的轮廓或者颜色简单显示出来。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250710213212632.png" alt="image-20250710213212632" style="zoom:50%;" />
<p>在上面的演示中，我们可以看到没有被光照到的部分是完全黑色的，在现实生活中显然是不合理的。这就需要引入我们的环境光，由于真实的环境光是其他由物体反射多次的光，真实计算起来比较麻烦，所以目前采用较为简单的方法模拟环境光。</p>
<p>我们只需要设置一个三维变量ambient模拟环境光，再将其和objectColor相乘即可。引入环境光可以让物体没有被光照到的地方也能隐约被我们看到，而不是全黑的。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;外部设置环境光强度
uniform vec3 ambient;
&#x2F;&#x2F;计算环境光反射的颜色
vec3 ambientColor &#x3D; ambient * objColor;
&#x2F;&#x2F;将三种光都加上去
FragColor &#x3D; vec4(diffuseColor + specularColor * flag + ambient, 1.0);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>加入环境光之后，原本没被光照到的地方也能隐约看到，并不是之前的黑色，显得更加真实一点。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250711181725116.png" alt="image-20250711181725116" style="zoom: 67%;" />
<h3 id="法线矩阵"><a class="header-anchor" href="#法线矩阵"></a>法线矩阵</h3>
<p>使用前面的代码，我们可以创建一个简单的光照，随着摄像机的移动，可以看到立方体的高光也在变化。但是当我们将盒子绕y轴随时间不停旋转时就会出现问题。</p>
<p>我们让摄像机保持不动，让盒子的两面都选择到摄像机的面前，可以看到初始状态面对摄像机的部分是被光线照亮的，但是当另一面转到摄像机面前时，可以发现摄像机面前的盒子居然是黑色的。盒子的明暗就像固定在盒子上一样随着盒子转到，并没有像现实情况那样出现明暗交替的情况。</p>
<p>出现这种情况的原因就是我们在旋转时没有让法线随着物体转到，当物体旋转30度之后，法线方向还是初始的方向没有变化，明暗情况也自然不会发生变化了。</p>
<p><img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250711211222316.png" alt="image-20250711211222316" style="zoom:50%;display:inline" /><img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250711211251648.png" alt="image-20250711211251648" style="zoom:50%;display:inline" /></p>
<p>为了解决这一问题，我们就需要让每个顶点的法线随着顶点的变化而变化。</p>
<p>如果让法线随着顶点做<strong>同样的模型变换</strong>时，可以发现在进行<strong>旋转和平移</strong>时，都能<strong>正确</strong>的将变换应用到法线上；但是当我们对物体在某一个方向上进行<strong>缩放</strong>时，将缩放变换应用到法线上就会发生<strong>错误</strong>。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250711211914084.png" alt="image-20250711211914084" style="zoom:45%;" />
<p>所以必须想办法找到一个新的变换矩阵，使法线在变换后到达正确的方向，这个矩阵称为<strong>NormalMatrix（法线矩阵）</strong>。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250711212532930.png" alt="image-20250711212532930" style="zoom:40%;" />
<p>下图为法线矩阵的推导过程，由最终结果可知，法线矩阵的值为模型变换矩阵的逆矩阵再转置即可。这是经过严格推到出来的，不论经过上面变换，将法线乘以模型变换矩阵的逆转置矩阵，得到的新法线都会垂直于该点切面。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250711214237454.png" alt="image-20250711214237454" style="zoom:50%;" />
<p>这样修改代码后即可实现法线的正确变换，但是由于求逆矩阵运算复杂。</p>
<p>当<strong>顶点数量非常多</strong>时，在<strong>shader</strong>中调用<strong>求逆矩阵</strong>的函数会大大<strong>降低性能</strong>，所以最好的做法就是在<strong>cpu端计算好</strong>法线矩阵后，通过<strong>uniform变量</strong>的形式将矩阵<strong>传递到shader</strong>中和法线进行运算，会大大节省算力。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;最终在vertexShader中将传递给fragmentShader的法线处理一下即可
normal &#x3D; transpose(inverse(mat3(model))) * aNormal;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="光源类型"><a class="header-anchor" href="#光源类型"></a>光源类型</h3>
<h4 id="平行光"><a class="header-anchor" href="#平行光"></a>平行光</h4>
<p>平行光是最简单的光源，每一根光线的方向都一样，常用来模拟太阳光。</p>
<p>假设空间中只有平行光，那么对于物体上能照射到平行光的点来说，<strong>光线方向都一样</strong>。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250710211241870.png" alt="image-20250710211241870" style="zoom:50%;" />
<p>由于平行光模拟的是无限远处的光源所发出的光线，所以我们不需要知道光源的位置，只需要知道平行光照的<strong>光照强度</strong>和<strong>光线方向</strong>即可。所以在代码中我们只需要定义两个三维向量<strong>lightDirection</strong>和<strong>lightColor</strong>分别表示光照方向和光照强度即可。</p>
<h4 id="点光源-PointLight"><a class="header-anchor" href="#点光源-PointLight"></a>点光源(PointLight)</h4>
<p>点光源比较好理解，就是场景中的一盏台灯或者一个电灯泡向四面八方发出的光。</p>
<p>由于点光源是向四面八方发出光的，所以对于物体的一个顶点来说，该顶点接收到的点光源的光线方向在点光源位置和顶点位置的连线上，也就是说<strong>不同位置的顶点</strong>接收到的点光源<strong>光线方向</strong>是<strong>不同</strong>的。而且，对于更真实的点光源来说，光照的强度也会随着距离的增大而衰减。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250715202936084.png" alt="image-20250715202936084" style="zoom:50%;" />
<p>由于不同位置的顶点接收到的光线方向不一致，所以定义一个点光源，我们需要知道点光源的<strong>位置</strong>和其<strong>光照强度</strong>即可，根据点光源位置就能计算出点光源到某一个顶点的光照方向。</p>
<p>下面简单介绍一下点<strong>光源随距离而衰减</strong>的理论知识：</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250715204340070.png" alt="image-20250715204340070" style="zoom:40%;" />
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250715204400223.png" alt="image-20250715204400223" style="zoom:50%;" />
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250715204519254.png" alt="image-20250715204519254" style="zoom:40%;" />
<pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token comment">//除了共有的光源颜色属性外，点光源还需要光源位置和衰减系数</span>
<span class="token comment">//光源位置</span>
<span class="token keyword">uniform</span> <span class="token keyword">vec3</span> lightPosition<span class="token punctuation">;</span>
<span class="token comment">//点光源衰减参数</span>
<span class="token keyword">uniform</span> <span class="token keyword">float</span> k1<span class="token punctuation">,</span> k2<span class="token punctuation">,</span> kc<span class="token punctuation">;</span>

<span class="token comment">//计算衰减系数</span>
<span class="token keyword">float</span> dis <span class="token operator">=</span> <span class="token function">length</span><span class="token punctuation">(</span>worldPosition <span class="token operator">-</span> lightPosition<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">float</span> multi <span class="token operator">=</span> <span class="token number">1.0</span><span class="token operator">/</span><span class="token punctuation">(</span>kc <span class="token operator">+</span> k1<span class="token operator">*</span>dis <span class="token operator">+</span> k2<span class="token operator">*</span>dis<span class="token operator">*</span>dis<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//计算出衰减系数后，将最终得到的点光源光照颜色乘以该系数模拟光照衰退的效果（近亮远暗）</span>
<span class="token keyword">vec3</span> final <span class="token operator">=</span> <span class="token punctuation">(</span>diffuseColor <span class="token operator">+</span> specularColor<span class="token operator">*</span>flag<span class="token operator">*</span>specularMaskColor<span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token operator">*</span> multi<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="聚光灯-SpotLight"><a class="header-anchor" href="#聚光灯-SpotLight"></a>聚光灯(SpotLight)</h4>
<p>聚光灯不是像点光源那样向四面八方发射光线，而是只会在一定的角度范围内发射光线。如果把点光源发出的光线形状看左一个球形，那么聚光灯发出的光线形状就是一个圆锥体，类似于手电筒的效果。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250716152715092.png" alt="image-20250716152715092" style="zoom:50%;" />
<p>对于一个聚光灯，我们不仅需要知道<strong>光源位置</strong>，还要知道<strong>聚光灯的朝向</strong>和<strong>最大照射角度θ</strong>。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250716153455153.png" alt="image-20250716153455153" style="zoom:50%;" />
<pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token comment">//聚光灯目标朝向方向</span>
<span class="token keyword">uniform</span> <span class="token keyword">vec3</span> lightTargetDirection<span class="token punctuation">;</span>
<span class="token comment">//聚光灯最大可视角度</span>
<span class="token keyword">uniform</span> <span class="token keyword">float</span> visibleAngle<span class="token punctuation">;</span>
<span class="token comment">//光源位置</span>
<span class="token keyword">uniform</span> <span class="token keyword">vec3</span> lightPosition<span class="token punctuation">;</span>

<span class="token comment">//计算该点是否在最大可视角内</span>
<span class="token comment">//方向归一化</span>
<span class="token keyword">vec3</span> targetDirectionN <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>lightTargetDirection<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment">//计算当前点和光源位置连线与看向方向的夹角cos值</span>
<span class="token keyword">float</span> cosTheta <span class="token operator">=</span> <span class="token function">dot</span><span class="token punctuation">(</span>lightDirectionN<span class="token punctuation">,</span> targetDirectionN<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//计算最大可见角的cos值，传入的是弧度</span>
<span class="token keyword">float</span> cosVisible <span class="token operator">=</span> <span class="token function">cos</span><span class="token punctuation">(</span>visibleAngle<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//如果在可视角内值为1，不可见则为0</span>
<span class="token keyword">float</span> isVisible <span class="token operator">=</span> <span class="token function">step</span><span class="token punctuation">(</span>cosVisible<span class="token punctuation">,</span> cosTheta<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//将聚光灯下的漫反射和镜面反射结果都称以isVisible控制是否可见</span>
<span class="token keyword">vec3</span> final <span class="token operator">=</span> <span class="token punctuation">(</span>diffuseColor <span class="token operator">+</span> specularColor<span class="token operator">*</span>flag<span class="token operator">*</span>specularMaskColor<span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token operator">*</span> isVisible<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250716162447499.png" alt="image-20250716162447499" style="zoom:50%;" />
<p>虽然成功地显示出来手电筒类的光照，但是明显看起来很别扭。因为光照的边缘明暗过渡太过于生硬了，在边缘内的明亮直接变成了黑的，不符合现实情况。为了解决这个问题，我们还需要顶定义一个<strong>过渡角β</strong>。</p>
<p>当某点角度γ&lt;θ时，光照正常；当θ&lt;γ&lt;β时，光照会一定程度上进行衰减；当β&lt;γ时，认为该点不能接收到聚光灯光照。</p>
<p>于是我们就可以有一个平滑的明暗过渡效果，最终衰减系数的计算公式如下。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250716165355944.png" alt="image-20250716165355944" style="zoom:50%;" />
<pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token comment">//聚光灯目标朝向方向</span>
<span class="token keyword">uniform</span> <span class="token keyword">vec3</span> lightTargetDirection<span class="token punctuation">;</span>
<span class="token comment">//聚光灯可视范围的内边界和外边界</span>
<span class="token keyword">uniform</span> <span class="token keyword">float</span> innerLine<span class="token punctuation">;</span><span class="token comment">//cosθ</span>
<span class="token keyword">uniform</span> <span class="token keyword">float</span> outerLine<span class="token punctuation">;</span><span class="token comment">//cosβ</span>
<span class="token comment">//光源位置</span>
<span class="token keyword">uniform</span> <span class="token keyword">vec3</span> lightPosition<span class="token punctuation">;</span>

<span class="token comment">//根据角度计算衰减系数</span>
<span class="token comment">//方向归一化</span>
<span class="token keyword">vec3</span> targetDirectionN <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>lightTargetDirection<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment">//计算当前点和光源位置连线与看向方向的夹角cos值</span>
<span class="token keyword">float</span> cosGamma <span class="token operator">=</span> <span class="token function">dot</span><span class="token punctuation">(</span>lightDirectionN<span class="token punctuation">,</span> targetDirectionN<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//计算最大可见角的cos值，传入的是弧度</span>
<span class="token keyword">float</span> multi <span class="token operator">=</span> <span class="token function">clamp</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>cosGamma <span class="token operator">-</span> outerLine<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>innerLine <span class="token operator">-</span> outerLine<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//将聚光灯下的漫反射和镜面反射结果都称以multi以控制光照衰减</span>
<span class="token keyword">vec3</span> final <span class="token operator">=</span> <span class="token punctuation">(</span>diffuseColor <span class="token operator">+</span> specularColor<span class="token operator">*</span>flag<span class="token operator">*</span>specularMaskColor<span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token operator">*</span> multi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>修改后的效果不再像之前那么生硬，边界有了明显的明暗过渡效果。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250716170040608.png" alt="image-20250716170040608" style="zoom:50%;" />
<h2 id="模型读取"><a class="header-anchor" href="#模型读取"></a>模型读取</h2>
<h3 id="父子关系"><a class="header-anchor" href="#父子关系"></a>父子关系</h3>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250717181227698.png" alt="image-20250717181227698" style="zoom:40%;" />
<h2 id="模板测试（StencilTest）"><a class="header-anchor" href="#模板测试（StencilTest）"></a>模板测试（StencilTest）</h2>
<h3 id="介绍-k6"><a class="header-anchor" href="#介绍-k6"></a>介绍</h3>
<p>当片段着色器处理完一个片段之后，模板测试(Stencil Test)会开始执行，和深度测试一样，它也可能会丢弃片段。接下来，被<strong>保留的片段会进入深度测试</strong>，它可能会丢弃更多的片段。模板测试是根据又一个缓冲来进行的，它叫做<strong>模板缓冲</strong>(Stencil Buffer)，我们可以在渲染的时候更新它来获得一些很有意思的效果。</p>
<p>模板缓冲在绘制物体时决定该位置缓冲区的值，借由缓冲区的值做一些效果。例如制作物体的<strong>描边特效</strong>，首先绘制一个物体，并将绘制出物体对应的缓冲区设为1，然后再绘制一个稍微放大的同样形状的物体，设置其只能在缓冲区不为1的区域绘制。这样发大的物体就只能绘制在物体的边界处，也就形成了物体描边的效果。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250721162950358.png" alt="image-20250721162950358" style="zoom:50%;" />
<h3 id="API"><a class="header-anchor" href="#API"></a>API</h3>
<p>和深度测试一样，需要使用glEnable和glDisable函数来控制模板测试的开启和关闭。</p>
<p>当开启模板测试后，需要设置<strong>通过模板测试的条件（glStencilFunc）</strong>、<strong>模板缓冲区的更新策略（glStencilOp）</strong>、<strong>模板缓冲区的读写控制（glStencilMask）</strong>。大致都和深度测试的使用类似，只是多了模板缓冲区的更新策略（深度缓冲区的更新策略较为固定，只需通过深度测试的片元深度值替换缓冲区深度值即可），模板缓冲区的更新较为灵活，专门提供了设置更新策略的函数。</p>
<ul>
<li><strong>模板测试的开启和关闭</strong></li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void glEnable(GL_STENCIL_TEST);&#x2F;&#x2F;开启模板测试
void glDisable(GL_STENCIL_TEST);&#x2F;&#x2F;关闭模板测试

&#x2F;&#x2F;由于存在缓冲区，所以每帧绘制前要调用glClear清理上一帧的模板缓存值
glClear(GL_STENCIL_BUFFER_BIT);
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><strong>设置模板测试的条件(满足条件的片元才能通过模板测试，继续进行深度测试)</strong></li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;设置模板测试条件
&#x2F;&#x2F;func：模板缓存中的数值与ref如何比较才算通过测试。
&#x2F;&#x2F;ref：参考值，模板缓存值与其进行比较
&#x2F;&#x2F;mask：缓存值和ref比较之前，都要和mask做一次与运算（一般情况下为全1的数值，即0XFF）
void glStencilFunc(GLenum func, GLint ref, GLuint mask);


&#x2F;&#x2F;该设置表示缓冲区数值和参考值1如果”相等“则通过模板测试（二者和0XFF与运算值不变）
glStencilFunc(GL_EQUAL, 1, 0XFF);
&#x2F;&#x2F;缓冲区数值小于5才通过模板测试
glStencilFunc(GL_LESS, 5, 0XFF);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>参数<strong>func</strong>的可选值如下：</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250721164453127.png" alt="image-20250721164453127" style="zoom:50%;" />
<ul>
<li><strong>模板测试通过或失败后，如何更新模板缓冲区的值</strong></li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;设置模板缓冲更新策略
&#x2F;&#x2F;sfail：模板测试失败时对缓冲区执行什么操作
&#x2F;&#x2F;zfail：模板测试通过但深度测试失败时对缓冲区执行什么操作
&#x2F;&#x2F;zpass：模板测试通过且深度测试通过时对缓冲区执行什么操作
void glStencilOp(GLenum sfail, GLenum zfail, GLenum zpass);

&#x2F;&#x2F;该设置为不论什么情况都不改变缓冲区的值
glStencilOp(GL_KEEP, GL_KEEP, GL_KEEP);
&#x2F;&#x2F;该设置为只有模板测试和深度测试都通过时，就将缓冲区的值更新为ref（一般情况下使用的是该设置）
glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这三个参数的值可在下面选项中任意使用：</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250721170417176.png" alt="image-20250721170417176" style="zoom:50%;" />
<ul>
<li><strong>开启模板测试的情况下，设置模板缓存是否能写入</strong></li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;模板缓冲区的写入控制
&#x2F;&#x2F;mask：缓冲区值的更新是一位一位更新的，只有当mask中位是1的对应位置才会被改变
void glStencilMask(GLuint mask);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如下图所示，当更新缓冲区时，缓冲区的值只有在mask的比特位为1的位置允许被写入，mask比特位为0的位置保持原样。</p>
<p>一般常用的mask值有两种：</p>
<p>0x00：任何比特位都<strong>不允许</strong>写入（禁止更新模板缓冲区的值）。</p>
<p>0xFF：任何比特位都<strong>允许</strong>写入。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250721174213217.png" alt="image-20250721174213217" style="zoom:50%;" />
<h2 id="颜色混合（ColorBlending）"><a class="header-anchor" href="#颜色混合（ColorBlending）"></a>颜色混合（ColorBlending）</h2>
<h3 id="介绍-k7"><a class="header-anchor" href="#介绍-k7"></a>介绍</h3>
<p>OpenGL中，混合(Blending)通常是实现物体透明度(Transparency)的一种技术。透明就是说一个物体（或者其中的一部分）不是纯色(Solid Color)的，它的颜色是物体本身的颜色和它背后其它物体的颜色的不同强度结合。例如我们透过有色玻璃看向外面，我们看到的颜色就是外面的颜色和玻璃的颜色进行混合后的，就好像加了一层滤镜一样，所以透明度能让我们看穿物体。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/blending_transparency.png" alt="img" style="zoom: 67%;" />
<p>在各种软件中，透明程度会使用**opacity（不透明度）**表示，其取值范围是[0, 1]，0是完全透明，1是完全不透明。</p>
<p>图片中例如png格式的，其通道为rgba，最后一个通道<strong>alpha</strong>就表示了图片某个<strong>像素的透明度</strong>，其含义和opacity一样。</p>
<p>在opengl中，这种透明物体颜色叠加的效果叫做<strong>颜色混合（color blending）</strong>。</p>
<p>开启颜色混合后，会使用下图中的公式计算最终的混合颜色，其中：</p>
<ol>
<li><strong>源颜色(SrcColor)</strong>：当前片元着色器输出的颜色</li>
<li><strong>目标颜色(DestColor)</strong>：帧缓冲区中已经存在的颜色（颜色缓冲中的颜色）</li>
</ol>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250722173021366.png" alt="image-20250722173021366" style="zoom:50%;" />
<h3 id="API-k2"><a class="header-anchor" href="#API-k2"></a>API</h3>
<p>和深度测试一样，在opengl中要使用颜色混合，就要使用<strong>glEnable</strong>或者glDisanbe开启或关闭颜色混合功能。开启后再调用<strong>glBlendFunc</strong>函数设置最终混合颜色的计算公式。</p>
<ul>
<li><strong>开启或关闭</strong></li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void glEnable(GL_BLEND);&#x2F;&#x2F;开启
void glDisable(GL_BLEND);&#x2F;&#x2F;关闭<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li><strong>设置混合颜色计算公式的参数</strong></li>
</ul>
<p>两个参数均可从下面选项中任意使用：</p>
<ul>
<li><code>GL_ZERO</code>：因子为0.0</li>
<li><code>GL_ONE</code>：因子为1.0</li>
<li><code>GL_SRC_COLOR</code>：因子等于源颜色</li>
<li><code>GL_ONE_MINUS_SRC_COLOR</code>：因子等于1-源颜色</li>
<li><code>GL_DST_COLOR</code>：因子等于目标颜色</li>
<li><code>GL_ONE_MINUS_DST_COLOR</code>：因子等于1-目标颜色</li>
<li><code>GL_SRC_ALPHA</code>：因子等于源颜色的alpha分量</li>
<li><code>GL_ONE_MINUS_SRC_ALPHA</code>：因子等于1-源颜色的alpha分量</li>
<li><code>GL_DST_ALPHA</code>：因子等于目标颜色的alpha分量</li>
<li><code>GL_ONE_MINUS_DST_ALPHA</code>：因子等于1-目标颜色的alpha分量</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;混合颜色计算公式：blend_color &#x3D; src_color * sfactor + dest_color * dfactor
&#x2F;&#x2F;可用通过设置不同的参数，实现不同的混合效果
&#x2F;&#x2F;上图中的公式设置的是一般较为常用的参数
void glBlendFunc(GLenum sfactor, GLenum dfactor);


&#x2F;&#x2F;该设置为常用设置，根据源颜色的alpha值控制混合颜色
glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><strong>设置混合颜色的运算</strong></li>
</ul>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250722174155951.png" alt="image-20250722174155951" style="zoom:50%;" />
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;这个参数可用设置两种颜色和自己的因子相乘后，二者之间用什么运算（默认是相加）
void glBlendEquation(GLenum mode);

&#x2F;&#x2F;默认情况：blend_color &#x3D; src_color * sfactor + dest_color * dfactor
glBlendEquation(GL_FUNC_ADD);
&#x2F;&#x2F;二者相减：blend_color &#x3D; src_color * sfactor - dest_color * dfactor
glBlendEquation(GL_FUNC_SUBTRACT);
&#x2F;&#x2F;反向相减：blend_color &#x3D; dest_color * dfactor - src_color * sfactor
glBlendEquation(GL_FUNC_REVERSE_SUBTRACT);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="绘制顺序"><a class="header-anchor" href="#绘制顺序"></a>绘制顺序</h3>
<p>对于透明物体来说，不同的绘制顺序也会导致绘制结果的不同。</p>
<p>对于这样一个每个面都是透明有色玻璃的盒子来说，开启颜色混合后却出现了这样的问题。可用看到盒子明显只绘制出了三个面，另外三个面没有绘制出来，但是当摄像机移动到消失面的前面时，又能正确绘制出来。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250722174525969.png" alt="image-20250722174525969" style="zoom:50%;" />
<p>这是由于对于一个复杂物体来说，包含多个三角形，我们的绘制顺序是不确定的，才导致这一情况。</p>
<p>假设我们有三个<strong>有色透明三角形</strong>重叠在一起，只有<strong>z坐标不同</strong>，A距离摄像机最近，C最远。</p>
<p>如果按照<strong>CBA</strong>的顺序进行绘制，在开启颜色混合的情况下。先绘制C，再绘制B时将B的颜色和颜色缓冲中C的颜色进行混合，再绘制A的适合再将混合后的颜色和A的颜色进行混合，会得到正确的混合颜色。</p>
<p>如果按照<strong>ABC</strong>的顺序进行绘制，在开启颜色混合的情况下。先绘制A，在绘制B的时候会由于<strong>B被A遮挡</strong>而<strong>无法通过深度测试</strong>自然也无法进行后面的颜色混合，绘制C时也同理，所以此时透过A看去，看不到B和C的混合颜色。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250722174931892.png" alt="image-20250722174931892" style="zoom:50%;" />
<p>所以上面的透明玻璃盒子出现这一的原因就是因为透明物体之间的绘制顺序错误导致的。</p>
<p>为了解决这一问题，有两个方法：</p>
<ol>
<li>将<strong>透明物体的深度写入关闭</strong>，这样对于一个复杂物体来说即使先绘制前面的片元也<strong>不会更新深度缓冲区</strong>（但依然会将<strong>颜色混合后写入颜色缓冲区</strong>），<strong>后面的片元</strong>能够<strong>通过深度测试</strong>进行颜色混合。</li>
<li>调整绘制顺序，<strong>先绘制不透明物体</strong>，再按照距离摄像机的距离<strong>从远到近</strong>的顺序依次<strong>绘制透明物体</strong>。</li>
</ol>
<p>方法1是一种较为简单的解决方法，方法2调整顺序之后才是真正的透明效果。</p>
<p>方法1实现较为简单，只需要绘制该物体时关闭深度写入即可，所以在<strong>绘制透明物体</strong>时，应该<strong>关闭其深度写入</strong>。</p>
<p>方法2的实现则需要在导入模型时对所有的mesh按照摄像机坐标系下的z值进行排序，按顺序绘制。</p>
<h2 id="面剔除（FaceCulling）"><a class="header-anchor" href="#面剔除（FaceCulling）"></a>面剔除（FaceCulling）</h2>
<h3 id="介绍-k8"><a class="header-anchor" href="#介绍-k8"></a>介绍</h3>
<p>假设空间中有一个不透明的立方体盒子，不论我们从哪个角度看去，都不可能将六个面全部看到，事实上只能看到最多三个面。但是在绘制盒子的时候，我们确实是将六个面全部绘制出来了，没看到的部分只是由于深度关系被遮盖了，那部分的顶点仍然参与运算了。</p>
<p>如果将看不到的面直接不渲染，，将会节省一部分计算资源，提升程序的性能。</p>
<p>这正是**面剔除(Face Culling)<strong>所做的。OpenGL能够检查所有</strong>面向(Front Facing)<strong>观察者的面，并渲染它们，而</strong>丢弃那些背向(Back Facing)**的面，节省我们很多的片段着色器调用（它们的开销很大！）。但我们仍要告诉OpenGL哪些面是正向面(Front Face)，哪些面是背向面(Back Face)。OpenGL使用了一个很聪明的技巧，分析顶点数据的环绕顺序(Winding Order)。</p>
<p>当我们定义一个三角形时，会将三个顶点按照顺时针（Clockwise）或者逆时针（Counter-clockwise）的顺序给出。<strong>OpenGL</strong>在渲染图元的时候将使用这个信息来决定一个三角形是一个正向三角形还是背向三角形。<strong>默认</strong>情况下，<strong>逆时针顺序</strong>顶点所定义的三角形将会被处理为<strong>正向三角形</strong>。</p>
<p><img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/faceculling_windingorder.png" alt="img"></p>
<p>当定义好正向之后，我们在正面看的时候为正向，当移动到背面时，顶点的旋转顺序就会逆过来，就变成了背向。在3D物体中，背向观察者的面是看不到的，所以可以将其剔除。</p>
<h3 id="API-k3"><a class="header-anchor" href="#API-k3"></a>API</h3>
<p>opengl默认禁用面剔除，可用使用glEnable和glDisable函数开启和关闭。</p>
<ul>
<li><strong>开启和关闭</strong></li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void glEnable(GL_CULL_FACE);&#x2F;&#x2F;开启
void glDisable(GL_CULL_FACE);&#x2F;&#x2F;关闭<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li><strong>设置正向面（三角形顶点顺序逆时针为正向面还是顺时针为正向面）</strong></li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;GL_CW  顺时针的环绕顺序
&#x2F;&#x2F;GL_CCW 逆时针的环绕顺序（默认）
void glFrontFace(GL_CCW);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li><strong>设置剔除面（剔除正向面还是背向面）</strong></li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; GL_BACK： 只剔除背向面。
&#x2F;&#x2F; GL_FRONT：只剔除正向面。
&#x2F;&#x2F; GL_FRONT_AND_BACK：剔除正向面和背向面。
void glFrontFace(GL_BACK);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="帧缓冲（FrameBuffer）"><a class="header-anchor" href="#帧缓冲（FrameBuffer）"></a>帧缓冲（FrameBuffer）</h2>
<h3 id="介绍-k9"><a class="header-anchor" href="#介绍-k9"></a>介绍</h3>
<p>前面已经使用了很多屏幕缓冲了：用于写入颜色值的颜色缓冲、用于写入深度信息的深度缓冲和允许我们根据一些条件丢弃特定片段的模板缓冲。这些缓冲结合起来叫做帧缓冲(Framebuffer)，它被储存在GPU内存中的某处。</p>
<p>简单来说，帧缓冲就是一些屏幕缓冲（颜色缓冲、深度缓冲、模板缓冲等）的总和。</p>
<p>我们目前所做的所有操作都是在<strong>默认帧缓冲</strong>上进行的。默认的帧缓冲是在你创建窗口的时候生成和配置的（GLFW帮我们做了这些）。我们也创建我们自己的帧缓冲，实现一些酷炫的后期效果。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250727200339395.png" alt="image-20250727200339395" style="zoom:50%;" />
<p>帧缓冲的这些附件，我们可用使用2D纹理图片进行存储，绘制时可用直接从纹理中采样进行使用。</p>
<p>实现帧缓冲，我们需要进行两次绘制：</p>
<ul>
<li>第一次绘制：创建自己的帧缓冲，将要绘制的画面渲染后添加到自己的帧缓冲附件上</li>
<li>第二次绘制：使用上述帧缓冲的颜色附件（ColorBuffer）作为纹理进行采样，对图像进行后期处理，绘制到屏幕上</li>
</ul>
<h3 id="API-k4"><a class="header-anchor" href="#API-k4"></a>API</h3>
<ul>
<li><strong>创建帧缓冲</strong></li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">unsigned int fbo;
glGenFramebuffers(1, &amp;fbo);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li><strong>绑定帧缓冲</strong></li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">glBindFramebuffer(GL_FRAMEBUFFER, fbo);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li><strong>将颜色附件创建</strong></li>
</ul>
<p>首先要创建一个<strong>空的2D纹理</strong>作为帧缓冲的<strong>颜色附件</strong>，再将该颜色附件绑定到帧缓冲。当帧缓冲绑定后，最终的<strong>绘制结果</strong>会<strong>保存到该颜色附件</strong>中。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;创建一个普通的2D纹理作为颜色附件（纹理对象数据为空）
glGenTextures(1, &amp;colorAttachment);
&#x2F;&#x2F;激活0号纹理单元（如果不手动激活纹理单元，在绑定纹理对象时默认激活0号纹理单元）
glActiveTexture(GL_TEXTURE0 + unit);

&#x2F;&#x2F;绑定纹理对象
glBindTexture(GL_TEXTURE_2D, colorAttachment);

&#x2F;&#x2F;向纹理对象传递空数据(纹理大小要和绘制区域大小一样)
glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);

&#x2F;&#x2F;设置纹理过滤方式
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><strong>将颜色附件添加到帧缓冲</strong></li>
</ul>
<p>调用<strong>glFramebufferTexture2D</strong>函数可用将指定缓冲的附件添加到当前绑定的帧缓冲上。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;将颜色附件添加到帧缓冲上
&#x2F;&#x2F;第一个参数为固定值，表面向当前绑定的帧缓冲上添加缓冲附件
&#x2F;&#x2F;第二个参数是缓冲附件类型，表面向当前绑定的帧缓冲添加什么类型的附件(此处为颜色附件，允许有多个，只用到第一个即可)
&#x2F;&#x2F;第三个参数为固定值
&#x2F;&#x2F;第四个参数是颜色缓冲的id值
&#x2F;&#x2F;第五个参数是指把当前纹理哪个level的mipmap绑定进去（没有生成mipmap，使用0级的）
glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, colorAttachment, 0);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><strong>创建深度和模板附件</strong></li>
</ul>
<p>深度缓冲和模板缓冲一般情况下可以分配到<strong>同一个缓冲</strong>中，假设每个像素有32bit存储这些缓冲，前<strong>24bit深度缓冲</strong>使用，后<strong>8bit模板缓冲</strong>使用。由于两个缓冲共存在一个纹理中，所以调用<strong>glTexImage2D</strong>函数传输空数据时的<strong>数据格式</strong>也不同。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;创建一个普通的2D纹理作为颜色附件（纹理对象数据为空）
glGenTextures(1, &amp;depthStencilAttachment);
&#x2F;&#x2F;激活0号纹理单元（如果不手动激活纹理单元，在绑定纹理对象时默认激活0号纹理单元）
glActiveTexture(GL_TEXTURE0 + unit);

&#x2F;&#x2F;绑定纹理对象
glBindTexture(GL_TEXTURE_2D, depthStencilAttachment);

&#x2F;&#x2F;向纹理对象传递空数据(纹理大小要和绘制区域大小一样)
glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH24_STENCIL8, width, height, 0, GL_DEPTH_STENCIL, GL_UNSIGNED_INT_24_8, NULL);


&#x2F;&#x2F;设置纹理过滤方式
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><strong>将深度模板附件添加到帧缓冲上</strong></li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;将深度模板附件添加到帧缓冲上
glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_TEXTURE_2D, depthStencilAttachment, 0);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li><strong>检查fbo是否完整</strong></li>
</ul>
<p>创建fbo完成后，可用调用<strong>glCheckFramebufferStatus</strong>函数查看<strong>当前绑定</strong>的fbo<strong>是否创建完整</strong>。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;检查当前fbo是否完整
if (glCheckFramebufferStatus(GL_FRAMEBUFFER) !&#x3D; GL_FRAMEBUFFER_COMPLETE)
&#123;
    std::cout &lt;&lt; &quot;当前fbo缺少附件&quot; &lt;&lt; std::endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="后期效果"><a class="header-anchor" href="#后期效果"></a>后期效果</h3>
<p>在最初的绘制中，我们如果想对最终的绘制结果进行后期处理（调高亮度、模糊处理、灰度图等），是很难实现的，因为在着色器中无法得知其他片元的颜色或者其他数据。</p>
<p>使用我们自己创建的帧缓冲后，可用将绘制的最终结果保存到帧缓冲的颜色缓冲中，这样我们就相当于拿到了最终绘制结果的纹理图片，在对这个纹理采样时做一些后期处理就变得很容易了。</p>
<ol>
<li>首先要创建一个完全遮挡住屏幕的矩形。</li>
<li>创建一个完整的FBO。</li>
<li>绑定创建的FBO，执行场景的绘制操作。第一次渲染操作，会将场景的渲染结果作为2D纹理保存到当前FBO的颜色缓冲中。</li>
<li>绑定默认的帧缓冲（FBO为0），渲染矩形屏幕，其采样的纹理为创建的FBO的颜色缓冲。第二次渲染操作，用一个完全盖住屏幕的屏幕，纹理为颜色缓冲。</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;绑定创建的FBO
glBindFramebuffer(GL_FRAMEBUFFER, fbo);
&#x2F;&#x2F;执行第一次渲染，绘制正常场景
draw();

&#x2F;&#x2F;使用默认的帧缓冲
glBindFramebuffer(GL_FRAMEBUFFER, 0);
&#x2F;&#x2F;绘制盖住屏幕的屏幕，使用创建的FBO的颜色缓冲作为纹理采样，在shader采样时可做一些后期特效
draw();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token comment">//------------------------------vertexShader</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">460</span> core</span></span>
<span class="token keyword">layout</span><span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token keyword">vec3</span> aPosition<span class="token punctuation">;</span>
<span class="token keyword">layout</span><span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token keyword">vec2</span> aUv<span class="token punctuation">;</span>

<span class="token keyword">out</span> <span class="token keyword">vec2</span> uv<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	uv <span class="token operator">=</span> aUv<span class="token punctuation">;</span>
	<span class="token comment">//因为要完全盖住屏幕，外界传来的直接为NDC坐标，且顶点都在边界</span>
	gl_Position <span class="token operator">=</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span>aPosition<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>



<span class="token comment">//------------------------------fragmentShader</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">460</span> core</span></span>
<span class="token keyword">out</span> <span class="token keyword">vec4</span> FragColor<span class="token punctuation">;</span>

<span class="token keyword">in</span> <span class="token keyword">vec2</span> uv<span class="token punctuation">;</span>

<span class="token keyword">uniform</span> <span class="token keyword">sampler2D</span> screenSampler<span class="token punctuation">;</span>

<span class="token comment">//灰度图处理，输出颜色的rgb值都为原先颜色rgb值和的平均值</span>
<span class="token keyword">vec3</span> <span class="token function">gray</span><span class="token punctuation">(</span><span class="token keyword">vec3</span> color<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">float</span> ant <span class="token operator">=</span> <span class="token punctuation">(</span>color<span class="token punctuation">.</span>r <span class="token operator">+</span> color<span class="token punctuation">.</span>g <span class="token operator">+</span> color<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">3.0</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token keyword">vec3</span><span class="token punctuation">(</span>ant<span class="token punctuation">,</span> ant<span class="token punctuation">,</span> ant<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>


<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">vec3</span> color <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>screenSampler<span class="token punctuation">,</span> uv<span class="token punctuation">)</span><span class="token punctuation">.</span>rgb<span class="token punctuation">;</span>
	color <span class="token operator">=</span> <span class="token function">gray</span><span class="token punctuation">(</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span>

	FragColor <span class="token operator">=</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span>color<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​                     <img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250727205147193.png" alt="image-20250727205147193" style="zoom:50%;display=inline;" /><img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250727205130194.png" alt="image-20250727205130194" style="zoom:50%;display=inline;" /></p>
<h2 id="立方体贴图（CuebMap）"><a class="header-anchor" href="#立方体贴图（CuebMap）"></a>立方体贴图（CuebMap）</h2>
<h3 id="介绍-k10"><a class="header-anchor" href="#介绍-k10"></a>介绍</h3>
<p>纹理贴图中除了2D纹理贴图，还有立方体贴图，就好像是把一个立方体盒子展开了一样，共有六张图片，分为上下左右前后六个方向。立方体贴图常常用来实现天空盒，就好像是把摄像机盖在了盒子里，盒子作为天空始终作为背景显示在最后。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250727205356023.png" alt="image-20250727205356023" style="zoom:50%;" />
<p>假设我们有一个1x1x1的单位立方体，方向向量的原点位于它的中心。使用一个橘黄色的方向向量来从立方体贴图上采样一个纹理值会像是这样：</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/cubemaps_sampling.png" alt="img" style="zoom:67%;" />
<p>方向向量的<strong>大小并不重要</strong>，只要<strong>提供了方向</strong>，OpenGL就会获取方向向量盒立方体贴图相交位置的颜色。这样子，只要立方体的<strong>中心位于原点</strong>（可用将盒子的<strong>中心位置</strong>始终<strong>跟随摄像机位置</strong>，就能保证盒子中心始终位于摄像机坐标系的原点中），我们就能使用立方体的<strong>实际位置向量</strong>来对立方体贴图进行<strong>采样</strong>了，这样一来，可用直接使用<strong>顶点坐标</strong>作为每个顶点<strong>uv坐标</strong>进行采样即可。</p>
<h3 id="创建立方体贴图"><a class="header-anchor" href="#创建立方体贴图"></a>创建立方体贴图</h3>
<ul>
<li><strong>创建纹理</strong></li>
</ul>
<p>与普通纹理一样，直接使用glGenTextures函数创建一个纹理即可</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">glGenTextures(1, &amp;cubeMap);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li><strong>绑定纹理到opengl对应插槽</strong></li>
</ul>
<p>绑定流程与普通纹理类似，但是<strong>glBindTexture</strong>函数中要<strong>绑定</strong>到<strong>GL_TEXTURE_CUBE_MAP</strong>而非GL_TEXTURE_TEXTURE_2D。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">glActiveTexture(GL_TEXTURE0 + unit);&#x2F;&#x2F;激活对应纹理单元
glBindTexture(GL_TEXTURE_CUBE_MAP, cubeMap);&#x2F;&#x2F;绑定创建的立方体贴图到GL_TEXTURE_CUBE_MAP插槽<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li><strong>向纹理贴图中传输图片数据</strong></li>
</ul>
<p>cubeMap贴图读取时<strong>不需要翻转y轴</strong>，而且因为立方体贴图有六个面，必须为六个面都传输数据。</p>
<p>传输数据和普通纹理图片类似，都是读取数据后调用<strong>glTexImage2D</strong>函数，只是立方体贴图有六个面，所以需要调用<strong>六次函数</strong>。每次将纹理目标(<strong>target</strong>)参数（第一个参数）设置为立方体贴图的一个<strong>特定的面</strong>。</p>
<table>
<thead>
<tr>
<th style="text-align:left">纹理目标（target参数）</th>
<th style="text-align:left">方位</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code></td>
<td style="text-align:left">右</td>
</tr>
<tr>
<td style="text-align:left"><code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code></td>
<td style="text-align:left">左</td>
</tr>
<tr>
<td style="text-align:left"><code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code></td>
<td style="text-align:left">上</td>
</tr>
<tr>
<td style="text-align:left"><code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code></td>
<td style="text-align:left">下</td>
</tr>
<tr>
<td style="text-align:left"><code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code></td>
<td style="text-align:left">后</td>
</tr>
<tr>
<td style="text-align:left"><code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code></td>
<td style="text-align:left">前</td>
</tr>
</tbody>
</table>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;cubeMap不需要翻转y轴
stbi_set_flip_vertically_on_load(false);

&#x2F;&#x2F;右左上下前后
&#x2F;&#x2F;六个面的均为无符号整型定义，且数值连续，可用循环设置
for (int i &#x3D; 0; i &lt; paths.size(); i++)
&#123;
    int channels;
    &#x2F;&#x2F;根据路径读取图片数据
    unsigned char* imageData &#x3D; stbi_load(paths[i].c_str(), &amp;width, &amp;height, &amp;channels, STBI_rgb_alpha);
    if (imageData)
    &#123;
        &#x2F;&#x2F;按照右左上下前后，依次向各个面传输数据
        glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, imageData);
        &#x2F;&#x2F;释放数据
        stbi_image_free(imageData);
    &#125;
    else
    &#123;
        std::cout &lt;&lt; &quot;无法读取CubeMap图片&quot; &lt;&lt; std::endl;
    &#125;

&#125;


&#x2F;&#x2F;设置立方体贴图的纹理过滤方式和包裹方式
glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="显示立方体贴图"><a class="header-anchor" href="#显示立方体贴图"></a>显示立方体贴图</h3>
<p>立方体贴图的绘制需要依附于一个立方体盒子，所以也需要一个shader，复杂绘制天空盒。</p>
<p>之前已经介绍过，可用直接使用立方体盒子<strong>每个顶点的位置作为其uv坐标</strong>进行采样，<strong>立方体的变换和正常物体一样</strong>，只是我们将立方体的中心位置始终设置为摄像机的位置，就实现了天空盒包裹住摄像机的效果。</p>
<p>由于立方体贴图是立体的，采样器要使用<strong>samplerCube</strong>类型进行采样，<strong>texture</strong>函数中传入的<strong>uv坐标也是三维</strong>的。</p>
<p>由于立方体贴图作为天空盒绘制在屏幕中，所以<strong>立方体贴图</strong>应该在场景中<strong>所有物体之后</strong>，我们只需要将该立方体的<strong>深度值</strong>始终<strong>设置为最大的1</strong>即可。</p>
<p>由下图流程可知，<strong>vertexShader</strong>输出的顶点坐标<strong>除以w</strong>后转化为NDC坐标，再将<strong>Z的NDC</strong>坐标<strong>加1除2</strong>可转化为最终的<strong>深度值</strong>，所以想让天空盒的深度值始终为一，只需<strong>vertexShader输出的Z坐标等于w</strong>即可。</p>
<p>所以在vertexShader的最后用<strong>gl_Position = gl_Position.xyww</strong>，让输出的<strong>z值等于w</strong>。</p>
<p><img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250727230227272.png" alt="image-20250727230227272"></p>
<pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token comment">//------------------------------vertexShader</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">460</span> core</span></span>
<span class="token keyword">layout</span><span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token keyword">vec3</span> aPosition<span class="token punctuation">;</span>
<span class="token keyword">layout</span><span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token keyword">vec2</span> aUv<span class="token punctuation">;</span>

<span class="token keyword">out</span> <span class="token keyword">vec3</span> uvw<span class="token punctuation">;</span>

<span class="token keyword">uniform</span> <span class="token keyword">mat4</span> model<span class="token punctuation">;</span>
<span class="token keyword">uniform</span> <span class="token keyword">mat4</span> view<span class="token punctuation">;</span>
<span class="token keyword">uniform</span> <span class="token keyword">mat4</span> projection<span class="token punctuation">;</span>


<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">//顶点坐标作为uv坐标采样</span>
	uvw <span class="token operator">=</span> aPosition<span class="token punctuation">;</span>

	<span class="token keyword">vec4</span> pos <span class="token operator">=</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span>aPosition<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	gl_Position <span class="token operator">=</span> projection <span class="token operator">*</span> view <span class="token operator">*</span> model <span class="token operator">*</span> pos<span class="token punctuation">;</span>
	gl_Position <span class="token operator">=</span> gl_Position<span class="token punctuation">.</span>xyww<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>


<span class="token comment">//------------------------------fragmentShader</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">460</span> core</span></span>

<span class="token keyword">out</span> <span class="token keyword">vec4</span> FragColor<span class="token punctuation">;</span>

<span class="token keyword">in</span> <span class="token keyword">vec3</span> uvw<span class="token punctuation">;</span>

<span class="token keyword">uniform</span> <span class="token keyword">samplerCube</span> cubeSampler<span class="token punctuation">;</span>


<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	FragColor <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>cubeSampler<span class="token punctuation">,</span> uvw<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>同时在绘制天空盒时，由于深度缓冲盒天空盒的深度值都为1，深度测试时会出现zFighting现象。所以需要将深度测试函数设置为<strong>glDepthFunc(GL_LEQUAL)</strong>，让深度值等于1时也可用通过深度测试，这样场景中没有物体的部分会被填充为天空盒的颜色。</p>
<h3 id="环境映射"><a class="header-anchor" href="#环境映射"></a>环境映射</h3>
<p>我们将立方体贴图当作我们的天空盒，我们也同样可用将该<strong>立方体贴图</strong>应用在物体的<strong>环境光</strong>上。通过使用环境的立方体贴图，我们可以给物体<strong>反射</strong>和<strong>折射</strong>的属性。这样使用<strong>环境立方体贴图</strong>的技术叫做环境映射(Environment Mapping)</p>
<p>本质上就是给物体再加上一个立方体贴图用作环境光贴图，通过计算视线方向盒法线向量的反射方向，根据反射方向去立方体贴图上采样，作为环境光叠加到物体身上。</p>
<pre class="line-numbers language-glsl" data-language="glsl"><code class="language-glsl"><span class="token comment">//---------------------------------------vertexShader</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">460</span> core</span></span>
<span class="token keyword">layout</span><span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token keyword">vec3</span> aPosition<span class="token punctuation">;</span>
<span class="token keyword">layout</span><span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token keyword">vec2</span> aUv<span class="token punctuation">;</span>
<span class="token keyword">layout</span><span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token keyword">vec3</span> aNormal<span class="token punctuation">;</span>

<span class="token keyword">out</span> <span class="token keyword">vec2</span> uv<span class="token punctuation">;</span>
<span class="token keyword">out</span> <span class="token keyword">vec3</span> normal<span class="token punctuation">;</span>
<span class="token keyword">out</span> <span class="token keyword">vec3</span> worldPosition<span class="token punctuation">;</span>

<span class="token keyword">uniform</span> <span class="token keyword">mat4</span> model<span class="token punctuation">;</span>
<span class="token keyword">uniform</span> <span class="token keyword">mat4</span> view<span class="token punctuation">;</span>
<span class="token keyword">uniform</span> <span class="token keyword">mat4</span> projection<span class="token punctuation">;</span>
<span class="token keyword">uniform</span> <span class="token keyword">mat3</span> normalMatrix<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	uv <span class="token operator">=</span> <span class="token keyword">vec2</span><span class="token punctuation">(</span>aUv<span class="token punctuation">.</span>x<span class="token punctuation">,</span> aUv<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
	normal <span class="token operator">=</span> normalMatrix <span class="token operator">*</span> aNormal<span class="token punctuation">;</span>

	<span class="token keyword">vec4</span> position <span class="token operator">=</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span>aPosition<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	worldPosition <span class="token operator">=</span> <span class="token punctuation">(</span>model <span class="token operator">*</span> position<span class="token punctuation">)</span><span class="token punctuation">.</span>xyz<span class="token punctuation">;</span>

	gl_Position <span class="token operator">=</span> projection <span class="token operator">*</span> view <span class="token operator">*</span> model <span class="token operator">*</span> position<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>



<span class="token comment">//---------------------------------------fragmentShader</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">460</span> core</span></span>
<span class="token keyword">out</span> <span class="token keyword">vec4</span> FragColor<span class="token punctuation">;</span>

<span class="token keyword">in</span> <span class="token keyword">vec2</span> uv<span class="token punctuation">;</span>
<span class="token keyword">in</span> <span class="token keyword">vec3</span> normal<span class="token punctuation">;</span>
<span class="token keyword">in</span> <span class="token keyword">vec3</span> worldPosition<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">DirectionLight</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">vec3</span> direction<span class="token punctuation">;</span>
	<span class="token keyword">vec3</span> color<span class="token punctuation">;</span>
	<span class="token keyword">float</span> specularIntensity<span class="token punctuation">;</span>

<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">PointLight</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">vec3</span> position<span class="token punctuation">;</span>
	<span class="token keyword">vec3</span> color<span class="token punctuation">;</span>
	<span class="token keyword">float</span> specularIntensity<span class="token punctuation">;</span>
	<span class="token keyword">float</span> k1<span class="token punctuation">;</span>
	<span class="token keyword">float</span> k2<span class="token punctuation">;</span>
	<span class="token keyword">float</span> kc<span class="token punctuation">;</span>

<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">SpotLight</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">vec3</span> position<span class="token punctuation">;</span>
	<span class="token keyword">vec3</span> color<span class="token punctuation">;</span>
	<span class="token keyword">vec3</span> targetDirection<span class="token punctuation">;</span>
	<span class="token keyword">float</span> innerLine<span class="token punctuation">;</span><span class="token comment">//cosθ</span>
	<span class="token keyword">float</span> outerLine<span class="token punctuation">;</span><span class="token comment">//cosβ</span>
	<span class="token keyword">float</span> specularIntensity<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">uniform</span> <span class="token keyword">sampler2D</span> diffuseSampler<span class="token punctuation">;</span>
<span class="token keyword">uniform</span> <span class="token keyword">sampler2D</span> specularSampler<span class="token punctuation">;</span>
<span class="token keyword">uniform</span> <span class="token keyword">samplerCube</span> cubeEnvSampler<span class="token punctuation">;</span><span class="token comment">//立方体贴图采样器</span>

<span class="token keyword">uniform</span> <span class="token keyword">float</span> shiness<span class="token punctuation">;</span>
<span class="token keyword">uniform</span> <span class="token keyword">vec3</span> cameraPosition<span class="token punctuation">;</span>

<span class="token keyword">uniform</span> DirectionLight directionLight<span class="token punctuation">;</span>
<span class="token keyword">uniform</span> SpotLight spotLight<span class="token punctuation">;</span>
<span class="token keyword">uniform</span> PointLight pointLight<span class="token punctuation">;</span>

<span class="token comment">//整体不透明度</span>
<span class="token keyword">uniform</span> <span class="token keyword">float</span> opacity<span class="token punctuation">;</span>

<span class="token comment">//计算漫反射</span>
<span class="token keyword">vec3</span> <span class="token function">calculateDiffuse</span><span class="token punctuation">(</span><span class="token keyword">vec3</span> lightDir<span class="token punctuation">,</span> <span class="token keyword">vec3</span> normal<span class="token punctuation">,</span> <span class="token keyword">vec3</span> lightColor<span class="token punctuation">,</span> <span class="token keyword">vec3</span> objColor<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token comment">//计算漫反射光</span>
	<span class="token comment">//计算光线和法向量之间的夹角余弦值(颜色不能出现负数，要控制在0到1之间)</span>
	<span class="token keyword">float</span> diffuse <span class="token operator">=</span> <span class="token function">clamp</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span><span class="token operator">-</span>lightDir<span class="token punctuation">,</span> normal<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//(lightColor * diffuse)表示该点吸收了多少光，再乘以objColor表示反射了多少光，就是最终反射光的颜色</span>
	<span class="token keyword">vec3</span> diffuseColor <span class="token operator">=</span> lightColor <span class="token operator">*</span> diffuse <span class="token operator">*</span> objColor<span class="token punctuation">;</span>

	<span class="token keyword">return</span> diffuseColor<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">//计算镜面反射</span>
<span class="token keyword">vec3</span> <span class="token function">calculateSpecular</span><span class="token punctuation">(</span><span class="token keyword">vec3</span> lightDir<span class="token punctuation">,</span> <span class="token keyword">vec3</span> viewDir<span class="token punctuation">,</span> <span class="token keyword">vec3</span> normal<span class="token punctuation">,</span> <span class="token keyword">vec3</span> lightColor<span class="token punctuation">,</span> <span class="token keyword">float</span> specularIntensity<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token comment">//采样镜面反射纹理贴图的颜色</span>
	<span class="token keyword">vec3</span> specularMaskColor <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>specularSampler<span class="token punctuation">,</span> uv<span class="token punctuation">)</span><span class="token punctuation">.</span>xyz<span class="token punctuation">;</span>

	<span class="token comment">//计算镜面反射光</span>
	<span class="token comment">//计算反射光方向</span>
	<span class="token keyword">vec3</span> reflectDirection <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span><span class="token function">reflect</span><span class="token punctuation">(</span>lightDir<span class="token punctuation">,</span> normal<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//计算镜面反射光颜色</span>
	<span class="token keyword">float</span> specular <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span><span class="token operator">-</span>viewDir<span class="token punctuation">,</span> reflectDirection<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">vec3</span> specularColor <span class="token operator">=</span> lightColor <span class="token operator">*</span> <span class="token function">pow</span><span class="token punctuation">(</span>specular<span class="token punctuation">,</span> shiness<span class="token punctuation">)</span> <span class="token operator">*</span> specularIntensity<span class="token punctuation">;</span>
	<span class="token comment">//处理背面高光线性</span>
	<span class="token keyword">float</span> flag <span class="token operator">=</span> <span class="token function">step</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token function">dot</span><span class="token punctuation">(</span><span class="token operator">-</span>lightDir<span class="token punctuation">,</span> normal<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> specularColor <span class="token operator">*</span> flag <span class="token operator">*</span> specularMaskColor<span class="token punctuation">.</span>x<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//计算立方体贴图环境反射光</span>
<span class="token keyword">vec3</span> <span class="token function">calculateAmbient</span><span class="token punctuation">(</span><span class="token keyword">vec3</span> viewDirN<span class="token punctuation">,</span> <span class="token keyword">vec3</span> normalN<span class="token punctuation">,</span> <span class="token keyword">vec3</span> objColor<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">//计算反射向量</span>
	<span class="token keyword">vec3</span> reflectDir <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span><span class="token function">reflect</span><span class="token punctuation">(</span>viewDirN<span class="token punctuation">,</span> normalN<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//根据反射向量去立方体贴图采样</span>
	<span class="token keyword">return</span> <span class="token function">texture</span><span class="token punctuation">(</span>cubeEnvSampler<span class="token punctuation">,</span> reflectDir<span class="token punctuation">)</span><span class="token punctuation">.</span>rgb <span class="token operator">*</span> objColor<span class="token punctuation">;</span>

<span class="token punctuation">&#125;</span>

<span class="token keyword">vec3</span> <span class="token function">getDirectionLightResult</span><span class="token punctuation">(</span>DirectionLight light<span class="token punctuation">,</span> <span class="token keyword">vec3</span> normal<span class="token punctuation">,</span> <span class="token keyword">vec3</span> objColor<span class="token punctuation">,</span> <span class="token keyword">vec3</span> viewDirection<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">vec3</span> result <span class="token operator">=</span> <span class="token keyword">vec3</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	result <span class="token operator">+=</span> <span class="token function">calculateDiffuse</span><span class="token punctuation">(</span>light<span class="token punctuation">.</span>direction<span class="token punctuation">,</span> normal<span class="token punctuation">,</span> light<span class="token punctuation">.</span>color<span class="token punctuation">,</span> objColor<span class="token punctuation">)</span><span class="token punctuation">;</span>
	result <span class="token operator">+=</span> <span class="token function">calculateSpecular</span><span class="token punctuation">(</span>light<span class="token punctuation">.</span>direction<span class="token punctuation">,</span> viewDirection<span class="token punctuation">,</span> normal<span class="token punctuation">,</span> light<span class="token punctuation">.</span>color<span class="token punctuation">,</span> light<span class="token punctuation">.</span>specularIntensity<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>


<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token comment">//计算通用数据</span>
	<span class="token keyword">vec3</span> normalN <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>normal<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">vec3</span> viewDirection <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>worldPosition <span class="token operator">-</span> cameraPosition<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">vec3</span> objColor <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>diffuseSampler<span class="token punctuation">,</span> uv<span class="token punctuation">)</span><span class="token punctuation">.</span>xyz<span class="token punctuation">;</span>
	<span class="token keyword">float</span> alpha <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>diffuseSampler<span class="token punctuation">,</span> uv<span class="token punctuation">)</span><span class="token punctuation">.</span>a<span class="token punctuation">;</span>


	<span class="token keyword">vec3</span> finalColor <span class="token operator">=</span> <span class="token keyword">vec3</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//计算平行光</span>
	finalColor <span class="token operator">+=</span> <span class="token function">getDirectionLightResult</span><span class="token punctuation">(</span>directionLight<span class="token punctuation">,</span> normalN<span class="token punctuation">,</span> objColor<span class="token punctuation">,</span> viewDirection<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//计算环境光</span>
	<span class="token keyword">vec3</span> ambientColor <span class="token operator">=</span> <span class="token function">calculateAmbient</span><span class="token punctuation">(</span>viewDirection<span class="token punctuation">,</span> normalN<span class="token punctuation">,</span> objColor<span class="token punctuation">)</span><span class="token punctuation">;</span>
	finalColor <span class="token operator">+=</span> ambientColor<span class="token punctuation">;</span>
	
	FragColor <span class="token operator">=</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span>finalColor<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250727234541835.png" alt="image-20250727234541835" style="zoom:80%;" />
<h2 id="实例化（Instancing）"><a class="header-anchor" href="#实例化（Instancing）"></a>实例化（Instancing）</h2>
<h3 id="介绍-k11"><a class="header-anchor" href="#介绍-k11"></a>介绍</h3>
<p>在之前的绘制中，我们的策略是对每一个mesh都调用一次绘制函数（DrawCall），但是执行一次绘制函数非常昂贵，会对性能产生非常大的影响。每次调用绘制时，都需要CPU向GPU发送一些数据和命令，对性能影响非常大。如果绘制一个大型场景，每个mesh都调用一次绘制函数，那么场景就会变得非常卡顿。</p>
<p>如果在一个大型场景中，大部分的模型包含的是同一组顶点数据和材质，只是模型变换不同。对于这样的物体，我们可用使用实例化的方式，只调用一次绘制函数，直接告诉GPU渲染N个这样的物体，可用大大提高性能。</p>
<p>由于每个物体只有模型变换不同，所以每个物体的模型变换矩阵（ModelMatrix）需要给出，以物体的不同变换。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250728113821698.png" alt="image-20250728113821698" style="zoom:50%;" />
<h3 id="API-k5"><a class="header-anchor" href="#API-k5"></a>API</h3>
<p>可以通过调用<strong>glDrawArraysInstanced</strong>或<strong>glDrawElementsInstanced</strong>函数即可实现实例化绘制。但是相比<strong>glDrawArrays</strong>和<strong>glDrawElements</strong>函数，实例化绘制函数的参数列表最后**多了一个实例数量(Instance Count)**的参数，它能够设置我们需要渲染的实例个数。</p>
<p>这样我们只需要将必须的数据发送到GPU一次，然后使用一次函数调用告诉GPU它应该如何绘制这些实例。GPU将会直接渲染这些实例，而不用不断地与CPU进行通信。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;实例化绘制函数和原始绘制函数参数列表相同，只是最后多了一个额外的参数instancecount，设置该实例渲染几个

&#x2F;&#x2F;根据顶点顺序绘制
void glDrawArrays(GLenum mode, GLint first, GLsizei count);
&#x2F;&#x2F;根据顶点顺序绘制（实例化版本）
void glDrawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei instancecount);

&#x2F;&#x2F;根据顶点索引绘制
void glDrawElements(GLenum mode, GLsizei count, GLenum type, const void *indices);
&#x2F;&#x2F;根据顶点索引绘制（实例化版本）
void glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>CPU向GPU传输数据有两种方式：Uniform和Attribute，我们要传输的<strong>模型变换矩阵数组</strong>也可以通过这两种方式传送到GPU。</p>
<h3 id="uniform更新策略"><a class="header-anchor" href="#uniform更新策略"></a>uniform更新策略</h3>
<p>由于每个实例的模型变换矩阵不同，所以设置一个Uniform变量存储模型变换矩阵。</p>
<p>glsl中内置变量<strong>gl_InstanceID</strong>表示<strong>当前绘制的是第几个实例</strong>。在<strong>使用实例化渲染调用</strong>时，<strong>gl_InstanceID</strong>会<strong>从0开始</strong>，在<strong>每个实例被渲染时递增1</strong>。这样以来，对于<strong>每个实例的所有顶点</strong>来说，使用的都是<strong>同一个模型变换矩阵</strong>，也就能正确的应用模型变换。</p>
<p>结合模型变换矩阵数组和gl_InstanceID，我们就能正确地绘制出多个不同模型变换的物体，而且只调用了一次绘制函数。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250728115028104.png" alt="image-20250728115028104" style="zoom:50%;" />
<h3 id="Attribute更新策略"><a class="header-anchor" href="#Attribute更新策略"></a>Attribute更新策略</h3>
<p>使用Uniform变量传输数据虽然较为简单，但是如果绘制一个非常大的场景，需要实例化的物体数量非常多，我们最终会超过最大能够发送至着色器的uniform数据大小（上限）。</p>
<p>因此可以采取<strong>实例化数组(Instanced Array)<strong>的方式传输数据，可以将这些模型变换矩阵数组</strong>存放到一个VBO</strong>中，让这些模型变换矩阵作为每个顶点的属性。</p>
<p>对于VBO中的每个属性（坐标、UV、法线等）来说，都是<strong>逐顶点进行更新</strong>的，也就是每处理下一个新的顶点，VBO都会自动跳到该属性的下一组数据中作为该顶点的属性，也就是说<strong>每个顶点拿到的属性值都不一样</strong>。但是对于我们的模型变换矩阵来说，<strong>每个实例的所有顶点的模型变换矩阵都应该一样</strong>，我们<strong>希望每渲染一个实例才更新到下一组矩阵数据</strong>。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250728120532989.png" alt="image-20250728120532989" style="zoom: 50%;" />
<p>为了实现这一效果，我们可以用glVertexAttribDivisor函数设置某个属性值的更新策略。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250728120843150.png" alt="image-20250728120843150" style="zoom:50%;" />
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void glVertexAttribDivisor(Gluint index, Gluint divisor);

&#x2F;&#x2F;案例
&#x2F;&#x2F;设置uvVBO的属性
glBindVertexArray(VAO);
glBindBuffer(GL_ARRAY_BUFFER, uvVBO);
glEnableVertexAttribArray(1);
glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, sizeof(float)*2 (void*)0);

glVertexAttribDivisor(1, 0);&#x2F;&#x2F;每个顶点更新一次，所有顶点拿到的都不一样
glVertexAttribDivisor(1, 1);&#x2F;&#x2F;每个实例更新一次，同一实例的所有顶点拿到的都一样
glVertexAttribDivisor(1, n);&#x2F;&#x2F;每n个实例更新一次，每n个实例的所有顶点拿到的都一样<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于我们传入的是一个四维矩阵的数组，里面有16个数据，但是opengl中一个顶点的<strong>Attribute最多支持四维向量</strong>的属性，我们没办法在一个属性内将矩阵传过去。</p>
<p>我们可以将四维矩阵拆分为4个四维列向量进行传输，每个列向量作为一个属性值，在shader中拿到四个列向量后再拼接为一个四维矩阵。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250728122259641.png" alt="image-20250728122259641" style="zoom:67%;" />
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;假设instanceCount &#x3D; 3，准备大小为3的模型变换矩阵数组
glm::mat4 transforms[3];
transforms[0] &#x3D; glm::mat4(1.0f);
transforms[1] &#x3D; glm::translate(glm::mat4(1.0f), glm::vec3(3.0f, 0.0f, 0.0f));
transforms[2] &#x3D; glm::translate(glm::mat4(1.0f), glm::vec3(2.0f, 3.0f, 0.0f));


&#x2F;&#x2F;创建VBO，并将每个实例的变换矩阵数据传送到VBO中
glGenBuffers(1, &amp;transformMatrixVBO);
glBindBuffer(GL_ARRAY_BUFFER, transformMatrixVBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(glm::mat4) * instanceCount, transformMatrixs, GL_DYNAMIC_DRAW);
&#x2F;&#x2F;将vbo绑定到vao
glBindVertexArray(vao);
&#x2F;&#x2F;设置属性
glEnableVertexAttribArray(3);
glVertexAttribPointer(3, 4, GL_FLOAT, GL_FALSE, sizeof(glm::mat4), (void*)0);
&#x2F;&#x2F;设置3号属性，每一个实例换到下一组数据
glVertexAttribDivisor(3, 1);

glEnableVertexAttribArray(4);
glVertexAttribPointer(4, 4, GL_FLOAT, GL_FALSE, sizeof(glm::mat4), (void*)(sizeof(float)*4) );
&#x2F;&#x2F;设置4号属性，每一个实例换到下一组数据
glVertexAttribDivisor(4, 1);

glEnableVertexAttribArray(5);
glVertexAttribPointer(5, 4, GL_FLOAT, GL_FALSE, sizeof(glm::mat4), (void*)(sizeof(float)*8));
&#x2F;&#x2F;设置5号属性，每一个实例换到下一组数据
glVertexAttribDivisor(5, 1);

glEnableVertexAttribArray(6);
glVertexAttribPointer(6, 4, GL_FLOAT, GL_FALSE, sizeof(glm::mat4), (void*)(sizeof(float)*12));
&#x2F;&#x2F;设置6号属性，每一个实例换到下一组数据
glVertexAttribDivisor(6, 1);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最终只调用了一次绘制函数，就绘制出了多个不同模型变换的同一物体。</p>
<img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/posts/picgo/image-20250728122328266.png" alt="image-20250728122328266" style="zoom:50%;" />

                
            </div>
            <hr/>

            



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/OpenGL/">
                                    <span class="chip bg-color">OpenGL</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2025/11/22/Games101/">
                    <div class="card-image">
                        
                        
                        <img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/feature_map/6.png" class="responsive-img" alt="Games101课堂笔记和作业">
                        
                        <span class="card-title">Games101课堂笔记和作业</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            GAME101课程的笔记和作业总结
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2025-11-22
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/" class="post-category">
                                    计算机图形学
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/">
                        <span class="chip bg-color">计算机图形学</span>
                    </a>
                    
                    <a href="/tags/GAMES101/">
                        <span class="chip bg-color">GAMES101</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2025/11/22/%E7%AE%97%E6%B3%95/">
                    <div class="card-image">
                        
                        
                        <img src="https://pub-afa265e5b09847ed9cfbc292d8a9fd94.r2.dev/hexo/feature_map/10.png" class="responsive-img" alt="刷题算法模板">
                        
                        <span class="card-title">刷题算法模板</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            刷算法题的一些算符模板
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2025-11-22
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%88%B7%E9%A2%98/" class="post-category">
                                    刷题
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E7%AE%97%E6%B3%95/">
                        <span class="chip bg-color">算法</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('1'),
            headingSelector: 'h1, h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2025</span>
            
            <a href="/about" target="_blank">小明</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
                <span id="translate">|&nbsp;繁/简：</span><a id="translateLink" href="javascript:translatePage();">繁</a>
            
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">106.6k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
                <span id="sitetime"> Loading ...</span>
                <script>
                    var calcSiteTime = function () {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = "2025";
                        var startMonth = "11";
                        var startDate = "22";
                        var startHour = "16";
                        var startMinute = "0";
                        var startSecond = "0";
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);
                        // 补全计算时、分、秒的部分
                        // 计算剩余毫秒数（扣除已计算的年和天）
                        var remainingMs = diff - (diffYears * years) - (diffDays * days);
                        // 计算小时数
                        var diffHours = Math.floor(remainingMs / hours);
                        remainingMs = remainingMs % hours;
                        // 计算分钟数
                        var diffMinutes = Math.floor(remainingMs / minutes);
                        remainingMs = remainingMs % minutes;
                        // 计算秒数
                        var diffSeconds = Math.floor(remainingMs / seconds);

                        // 区分是否有年份.
                        var language = 'zh-CN';
                        if (startYear === String(todayYear)) {
                            document.getElementById("year").innerHTML = todayYear;
                            var daysTip = 'This site has been running for ' + diffDays + ' days'+  diffHours + ' hours'  + diffMinutes + ' minutes'  + diffSeconds + ' seconds';
                            if (language === 'zh-CN') {
                                daysTip = `本站已运行 ${diffDays} 天 ${String(diffHours).padStart(2, '0')} 时 ${String(diffMinutes).padStart(2, '0')} 分 ${String(diffSeconds).padStart(2, '0')} 秒`;
                            } else if (language === 'zh-HK') {
                                daysTip = '本站已運行 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = daysTip;
                        } else {
                            document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                            var yearsAndDaysTip = 'This site has been running for ' + diffYears + ' years and '
                                + diffDays + ' days';
                            if (language === 'zh-CN') {
                                yearsAndDaysTip = `本站已运行 ${diffYears}年 ${diffDays} 天 ${String(diffHours).padStart(2, '0')} 时 ${String(diffMinutes).padStart(2, '0')} 分 ${String(diffSeconds).padStart(2, '0')} 秒`;
                            } else if (language === 'zh-HK') {
                                yearsAndDaysTip = '本站已運行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
                        }
                    }
                    setInterval(calcSiteTime, 1000)
                </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/6xiaoming6" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:2022790507@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2022790507" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2022790507" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    
        <!-- <script src='https://unpkg.com/mermaid@latest/dist/mermaid.min.js'></script> -->
        <script src='/libs/mermaid/mermaid.min.js'></script>
        <script>
          if (window.mermaid) {
            mermaid.initialize({theme: 'forest'});
          }
        </script>
    

    
        <script type="text/javascript" src="/js/tw_cn.js"></script>
        <script type="text/javascript">
          var defaultEncoding = 2; //网站编写字体是否繁体，1-繁体，2-简体
          var translateDelay = 0; //延迟时间,若不在前, 要设定延迟翻译时间, 如100表示100ms,默认为0
          var cookieDomain = "http://example.com"; //Cookie地址, 一定要设定, 通常为你的网址
          var msgToTraditionalChinese = "繁"; //此处可以更改为你想要显示的文字
          var msgToSimplifiedChinese = "简"; //同上，但两处均不建议更改
          var translateButtonId = "translateLink"; //默认互换id
          translateInitilization();
        </script>
    
    
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/minecraft_click.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="/libs/background/canvas-nest.js"></script>
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
